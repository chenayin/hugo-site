<!DOCTYPE html>





    

    

    

    

<html lang="zh-CN"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <title>结束语 - 技术之外的几点成长建议 | 别人打药我拽管</title>
    <meta name="robots" content="noindex">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="Documentation, Hugo, Hugo Theme, Bootstrap" />
    <meta name="author" content="Colin Wilson - Lotus Labs" />
    <meta name="email" content="support@aigis.uk" />
    <meta name="website" content="https://lotusdocs.dev" />
    <meta name="Version" content="v0.1.0" />
    
    <link rel="icon" href="http://localhost:1313/favicon.ico" sizes="any">
<link rel="icon" type="image/svg+xml" href="http://localhost:1313/favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="manifest" crossorigin="use-credentials" href="http://localhost:1313/site.webmanifest">
<meta property="og:title" content="结束语 - 技术之外的几点成长建议" />
<meta property="og:description" content="你好，我是景霄。
不知不觉，专栏上线已经4个月了，终于到了和你们说再见的时候，心中既有兴奋，又有不舍。说兴奋，是因为自己坚持完成了40多篇文章的写作，这对我而言是一项体力与脑力的“马拉松”，颇有成就感；说不舍，是因为你们的热情远超乎我当时的想象，和你们一起交流学习真的很高兴，收获也很大。
这里也非常感谢极客时间能提供这个平台，让我得以和一万多的学员分享经验。当然，虽然课程结束了，但是技术人的学习并未终止，最后我还想再着重强调这么几点。
计算机科学是一门需要实践的学科 link无论是对于Python这门课程，还是其他语言，或是计算机的其他领域，我认为实践永远是至关重要的。计算机科学是一门偏向工程的学科，所以一定要多实践，多写代码，多交流，多思考。实际生活中，我见过不少同学虽然看了很多的书籍，但是代码功底非常差，这是一个很严重的问题。
那么，怎么提高呢？答案就是，请尽可能地参与更多的项目。俗话说“实践出真知”，说的正是这个道理。当你做的东西多了以后，你就会发现，很多的知识都会自然而然地串接起来，感觉自己的任督二脉似乎被打通了一般。
选择适合自己的职业方向 link关于职业方向的问题，我还是那句话，对于尚不清晰自己兴趣所在的同学，最好的办法就是多尝试，因为在尝试的过程中，你就会发现自己的特长，发现自己的喜好，从而坚定不移、一步一步地走下去。
当然，我了解到很多同学都是转行做程序员，以前都不是学计算机的，所以，很多人首先都会遇到“找工作”或者“跳槽”的难题。这种情况下，请不要气馁或是放弃。我也不完全算是科班出身的，我身边好多同事都不是科班出身，但是几年以后，你就会发现，好多当年非科班出身的同学，干得甚至比科班出身的都要好。因此，只要你坚定信念，不要放弃，风雨之后必有彩虹。
能用代码解决的问题都不是问题 link这句话，主要送给有一定工作经验的朋友。其实，有了一定的积累后，你就会发现，能用代码解决的问题都不是问题。职场上，要想出类拔萃，除了能在技术上独当一面，如何与他人进行沟通交流，如何正确地处理同事间的关系，都是你额外需要学习的东西。实际工作中，我也见过不少人，代码能力天赋异禀，但是沟通交流不行，这同样也会阻碍你向上晋升。
就拿一个很简单的例子来说。如果你和周围的同事合作一个项目，你觉得他有一样东西做得不好，你会直接说诸如“你很傻”，“你这样做大错特错”的话吗？你如果这样说了，那可真的是“大错特错了”。事实上，我们通常的一个措辞是，“我觉得你这里做得很好，不过，如果你可以……的话，那就更好了”。
说了这么多，最后，还是要感谢你的订阅，感谢你的一路陪伴，祝你的生活学习一帆风顺，永远幸福！课程虽然已经结束，但是你仍然可以留言，我会尽可能多地一一回复，让你的学习没有遗憾。
结束不是终点，而是更高阶旅程的重新启航。最后的最后，我们专栏的编辑同学，特意为你准备了一份毕业调查问卷，希望你能抽出两三分钟时间，写下你的学习经历和感受。这既是你课程学习的仪式感，作为你这几个月学习的记录和总结；也是我后续为你优化课程的重要参考资料，很有价值。感谢你的反馈，学习不停，精进不止！






  



  
    
      
    
  

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%BB%93%E6%9D%9F%E8%AF%AD---%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96%E7%9A%84%E5%87%A0%E7%82%B9%E6%88%90%E9%95%BF%E5%BB%BA%E8%AE%AE/" /><meta property="og:image" content="http://localhost:1313/opengraph/card-base-2_hu_b5d035b61dc30bc7.png"/><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2025-08-04T02:43:00+08:00" />
<meta property="article:modified_time" content="2025-08-04T02:43:00+08:00" /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://localhost:1313/opengraph/card-base-2_hu_b5d035b61dc30bc7.png"/>
<meta name="twitter:title" content="结束语 - 技术之外的几点成长建议"/>
<meta name="twitter:description" content="你好，我是景霄。
不知不觉，专栏上线已经4个月了，终于到了和你们说再见的时候，心中既有兴奋，又有不舍。说兴奋，是因为自己坚持完成了40多篇文章的写作，这对我而言是一项体力与脑力的“马拉松”，颇有成就感；说不舍，是因为你们的热情远超乎我当时的想象，和你们一起交流学习真的很高兴，收获也很大。
这里也非常感谢极客时间能提供这个平台，让我得以和一万多的学员分享经验。当然，虽然课程结束了，但是技术人的学习并未终止，最后我还想再着重强调这么几点。
计算机科学是一门需要实践的学科 link无论是对于Python这门课程，还是其他语言，或是计算机的其他领域，我认为实践永远是至关重要的。计算机科学是一门偏向工程的学科，所以一定要多实践，多写代码，多交流，多思考。实际生活中，我见过不少同学虽然看了很多的书籍，但是代码功底非常差，这是一个很严重的问题。
那么，怎么提高呢？答案就是，请尽可能地参与更多的项目。俗话说“实践出真知”，说的正是这个道理。当你做的东西多了以后，你就会发现，很多的知识都会自然而然地串接起来，感觉自己的任督二脉似乎被打通了一般。
选择适合自己的职业方向 link关于职业方向的问题，我还是那句话，对于尚不清晰自己兴趣所在的同学，最好的办法就是多尝试，因为在尝试的过程中，你就会发现自己的特长，发现自己的喜好，从而坚定不移、一步一步地走下去。
当然，我了解到很多同学都是转行做程序员，以前都不是学计算机的，所以，很多人首先都会遇到“找工作”或者“跳槽”的难题。这种情况下，请不要气馁或是放弃。我也不完全算是科班出身的，我身边好多同事都不是科班出身，但是几年以后，你就会发现，好多当年非科班出身的同学，干得甚至比科班出身的都要好。因此，只要你坚定信念，不要放弃，风雨之后必有彩虹。
能用代码解决的问题都不是问题 link这句话，主要送给有一定工作经验的朋友。其实，有了一定的积累后，你就会发现，能用代码解决的问题都不是问题。职场上，要想出类拔萃，除了能在技术上独当一面，如何与他人进行沟通交流，如何正确地处理同事间的关系，都是你额外需要学习的东西。实际工作中，我也见过不少人，代码能力天赋异禀，但是沟通交流不行，这同样也会阻碍你向上晋升。
就拿一个很简单的例子来说。如果你和周围的同事合作一个项目，你觉得他有一样东西做得不好，你会直接说诸如“你很傻”，“你这样做大错特错”的话吗？你如果这样说了，那可真的是“大错特错了”。事实上，我们通常的一个措辞是，“我觉得你这里做得很好，不过，如果你可以……的话，那就更好了”。
说了这么多，最后，还是要感谢你的订阅，感谢你的一路陪伴，祝你的生活学习一帆风顺，永远幸福！课程虽然已经结束，但是你仍然可以留言，我会尽可能多地一一回复，让你的学习没有遗憾。
结束不是终点，而是更高阶旅程的重新启航。最后的最后，我们专栏的编辑同学，特意为你准备了一份毕业调查问卷，希望你能抽出两三分钟时间，写下你的学习经历和感受。这既是你课程学习的仪式感，作为你这几个月学习的记录和总结；也是我后续为你优化课程的重要参考资料，很有价值。感谢你的反馈，学习不停，精进不止！






  



  
    
      
    
  

"/>

    
        <link rel="alternate" type="application/atom+xml" title="Atom feed for 别人打药我拽管" href="/index.xml" />
    
    
    
            
                <script type="text/javascript" src="http://localhost:1313/docs/js/flexsearch.bundle.js"></script>
            
        
    
    

    <link rel="stylesheet" href="/docs/scss/style.css" crossorigin="anonymous">
    
    
    </head>
<body>
        <div class="content">
            <div class="page-wrapper toggled">
<nav id="sidebar" class="sidebar-wrapper">
    <div class="sidebar-brand">
        <a href='/' aria-label="HomePage" alt="HomePage">
            
                <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
            
        </a>
    </div>
    <div class="sidebar-content" style="height: calc(100% - 131px);">
        <ul class="sidebar-menu">
            
                
                
                    
                    
                        <li class="sidebar-dropdown  current active">
                            <button class="btn">
                                <i class="material-icons me-2">Summarize</i>
                                Python
                            </button>
                            <div class="sidebar-submenu d-block">
                                <ul>
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python/">Python学习笔记</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/">Python中的集合</a></li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  current active">
                                                <button class="btn">
                                                    
                                                    Python核心技术与实战
                                                </button>
                                                <div class="sidebar-submenu d-block">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/00---%E5%BC%80%E7%AF%87%E8%AF%8D/">Python核心技术与实战</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/01---%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E7%AA%81%E7%A0%B4%E6%88%90%E4%B8%BApython%E9%AB%98%E6%89%8B/">01-如何逐步突破，成为Python高手</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/02---jupyter-notebook%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%B0%E4%BB%A3python%E7%9A%84%E5%BF%85%E5%AD%A6%E6%8A%80%E6%9C%AF/">02-Jupyter Notebook 为什么是现在Python的必学技术</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/03---%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E5%88%B0%E5%BA%95%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA/">03-列表和元组，到底用哪一个？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/04---%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/">04-字典、集合，你真的了解吗？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/05---%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/">05-深入浅出字符串</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/06---python-%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/">06 - Python &#34;黑箱&#34;：输入与输出</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/07---%E4%BF%AE%E7%82%BC%E5%9F%BA%E6%9C%AC%E5%8A%9F%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/">07 - 修炼基本功：条件与循环</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/08---%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/">08 - 异常处理：如何提高程序的稳定性？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/09---%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/">09 - 不可或缺的自定义函数</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/30---%E7%9C%9F%E7%9A%84%E6%9C%89%E5%BF%85%E8%A6%81%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%90%97/">30 - 真的有必要写单元测试吗？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/31---pdb--cprofile%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E6%B3%95%E5%AE%9D/">31 - pdb &amp; cProfile：调试和性能分析的法宝</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/32---%E7%AD%94%E7%96%91%E4%B8%89%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/">32 - 答疑（三）：如何选择合适的异常处理方式？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/33---%E5%B8%A6%E4%BD%A0%E5%88%9D%E6%8E%A2%E9%87%8F%E5%8C%96%E4%B8%96%E7%95%8C/">33 - 带你初探量化世界</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/34---restful--socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/">34 - RESTful &amp; Socket：搭建交易执行层核心</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/35---restful--socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/">35 - RESTful &amp; Socket：行情数据对接和抓取</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/36---pandas--numpy%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F/">36 - Pandas &amp; Numpy：策略与回测系统</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/37---kafka--zmq%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E6%98%93%E6%B5%81%E6%B0%B4%E7%BA%BF/">37 - Kafka &amp; ZMQ：自动化交易流水线</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/38---mysql%E6%97%A5%E5%BF%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">38 - MySQL：日志和数据存储系统</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/39---django%E6%90%AD%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/">39 - Django：搭建监控平台</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/40---%E6%80%BB%E7%BB%93python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A8%E6%99%AF/">40 - 总结：Python中的数据结构与算法全景</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/41---%E7%A1%85%E8%B0%B7%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%BD%93%E9%AA%8C/">41 - 硅谷一线互联网公司的工作体验</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/42---%E7%BB%86%E6%95%B0%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">42 - 细数技术研发的注意事项</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/43---qa%E8%81%8A%E4%B8%80%E8%81%8A%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E5%92%8C%E9%80%89%E6%8B%A9/">43 - Q&amp;A：聊一聊职业发展和选择</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%8A%A0%E9%A4%90---%E5%B8%A6%E4%BD%A0%E4%B8%8A%E6%89%8Bswig%E4%B8%80%E4%BB%BD%E6%B8%85%E6%99%B0%E5%A5%BD%E7%94%A8%E7%9A%84swig%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/">加餐 - 带你上手SWIG：一份清晰好用的SWIG编程实践指南</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%BB%93%E8%AF%BE%E6%B5%8B%E8%AF%95---%E5%85%B3%E4%BA%8Epython%E7%9A%84%E8%BF%99%E4%BA%9B%E7%9F%A5%E8%AF%86%E4%BD%A0%E9%83%BD%E6%8E%8C%E6%8F%A1%E4%BA%86%E5%90%97/">结课测试 - 关于Python的这些知识，你都掌握了吗？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class="current "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%BB%93%E6%9D%9F%E8%AF%AD---%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96%E7%9A%84%E5%87%A0%E7%82%B9%E6%88%90%E9%95%BF%E5%BB%BA%E8%AE%AE/">结束语 - 技术之外的几点成长建议</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">Newsmode</i>
                                资讯文章
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/%E6%97%A5%E5%B8%B8/%E5%91%8A%E5%88%AB%E4%BB%A3%E7%A0%81%E5%B7%A5%E4%BA%BA/">告别代码工人</a></li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">Newsmode</i>
                                AI 实践
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/ai/mcp-%E5%88%9D%E8%AF%95%E9%AA%8C/">MCP 初试验</a></li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
            
        </ul>
        
    </div>
    
        <ul class="sidebar-footer list-unstyled mb-0">
            
        </ul>
    
</nav>

                    <main class="page-content bg-transparent">
                        
<div id="top-header" class="top-header d-print-none">
    <div class="header-bar d-flex justify-content-between">
        <div class="d-flex align-items-center">
            <a href='/' class="logo-icon me-3" aria-label="HomePage" alt="HomePage">
                <div class="small">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
                <div class="big">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
            </a>
            <button id="close-sidebar" class="btn btn-icon btn-soft">
                <span class="material-icons size-20 menu-icon align-middle">menu</span>
            </button>
            
            
                    
                    <button id="flexsearch-button" class="ms-3 btn btn-soft" data-bs-toggle="collapse" data-bs-target="#FlexSearchCollapse" aria-expanded="false" aria-controls="FlexSearchCollapse">
                        <span class="material-icons size-20 menu-icon align-middle">search</span>
                        <span class="flexsearch-button-placeholder ms-1 me-2 d-none d-sm-block">Search</span>
                        <div class="d-none d-sm-block">
                            <span class="flexsearch-button-keys">
                                <kbd class="flexsearch-button-cmd-key">
                                    <svg width="44" height="15"><path d="M2.118,11.5A1.519,1.519,0,0,1,1,11.042,1.583,1.583,0,0,1,1,8.815a1.519,1.519,0,0,1,1.113-.458h.715V6.643H2.118A1.519,1.519,0,0,1,1,6.185,1.519,1.519,0,0,1,.547,5.071,1.519,1.519,0,0,1,1,3.958,1.519,1.519,0,0,1,2.118,3.5a1.519,1.519,0,0,1,1.114.458A1.519,1.519,0,0,1,3.69,5.071v.715H5.4V5.071A1.564,1.564,0,0,1,6.976,3.5,1.564,1.564,0,0,1,8.547,5.071,1.564,1.564,0,0,1,6.976,6.643H6.261V8.357h.715a1.575,1.575,0,0,1,1.113,2.685,1.583,1.583,0,0,1-2.227,0A1.519,1.519,0,0,1,5.4,9.929V9.214H3.69v.715a1.519,1.519,0,0,1-.458,1.113A1.519,1.519,0,0,1,2.118,11.5Zm0-.857a.714.714,0,0,0,.715-.714V9.214H2.118a.715.715,0,1,0,0,1.429Zm4.858,0a.715.715,0,1,0,0-1.429H6.261v.715a.714.714,0,0,0,.715.714ZM3.69,8.357H5.4V6.643H3.69ZM2.118,5.786h.715V5.071a.714.714,0,0,0-.715-.714.715.715,0,0,0-.5,1.22A.686.686,0,0,0,2.118,5.786Zm4.143,0h.715a.715.715,0,0,0,.5-1.22.715.715,0,0,0-1.22.5Z" fill="currentColor"></path><path d="M12.4,11.475H11.344l3.879-7.95h1.056Z" fill="currentColor"></path><path d="M25.073,5.384l-.864.576a2.121,2.121,0,0,0-1.786-.923,2.207,2.207,0,0,0-2.266,2.326,2.206,2.206,0,0,0,2.266,2.325,2.1,2.1,0,0,0,1.782-.918l.84.617a3.108,3.108,0,0,1-2.622,1.293,3.217,3.217,0,0,1-3.349-3.317,3.217,3.217,0,0,1,3.349-3.317A3.046,3.046,0,0,1,25.073,5.384Z" fill="currentColor"></path><path d="M30.993,5.142h-2.07v5.419H27.891V5.142h-2.07V4.164h5.172Z" fill="currentColor"></path><path d="M34.67,4.164c1.471,0,2.266.658,2.266,1.851,0,1.087-.832,1.809-2.134,1.855l2.107,2.691h-1.28L33.591,7.87H33.07v2.691H32.038v-6.4Zm-1.6.969v1.8h1.572c.832,0,1.22-.3,1.22-.918s-.411-.882-1.22-.882Z" fill="currentColor"></path><path d="M42.883,10.561H38.31v-6.4h1.033V9.583h3.54Z" fill="currentColor"></path></svg>
                                </kbd>
                                <kbd class="flexsearch-button-key">
                                    <svg width="15" height="15"><path d="M5.926,12.279H4.41L9.073,2.721H10.59Z" fill="currentColor"/></svg>
                                </kbd>
                            </span>
                        </div>
                    </button>
                
            </div>

        <div class="d-flex align-items-center">
            <ul class="list-unstyled mb-0">
                
            </ul>
            
        </div>
    </div>
    
    
            <div class="collapse" id="FlexSearchCollapse">
                <div class="flexsearch-container">
                    <div class="flexsearch-keymap">
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to navigate</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to select</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to close</span>
                        </li>
                    </div>
                    <form class="flexsearch position-relative flex-grow-1 ms-2 me-2">
                        <div class="d-flex flex-row">
                            <input id="flexsearch" class="form-control" type="search" placeholder="Search" aria-label="Search" autocomplete="off">
                            <button id="hideFlexsearch" type="button" class="ms-2 btn btn-soft">
                                cancel
                            </button>
                        </div>
                        <div id="suggestions" class="shadow rounded-1 d-none"></div>
                    </form>
                </div>
            </div>
        
    
    
</div>


                            <div class="container-fluid">
                                <div class="layout-spacing">
                                    
                                        <div class="d-md-flex justify-content-between align-items-center"><nav aria-label="breadcrumb" class="d-inline-block pb-2 mt-1 mt-sm-0">
    <ul id="breadcrumbs" class="breadcrumb bg-transparent mb-0" itemscope itemtype="https://schema.org/BreadcrumbList">
        
            
                <li class="breadcrumb-item text-capitalize active" aria-current="page" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/">
                        <i class="material-icons size-20 align-text-bottom" itemprop="name">Home</i>
                    </a>
                    <meta itemprop="position" content='1' />
                </li>
            
            
                <li class="breadcrumb-item text-capitalize" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/python/">
                        <span itemprop="name">Python</span>
                    </a>
                    <meta itemprop="position" content='2' />
                </li>
            
            
                <li class="breadcrumb-item text-capitalize" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/">
                        <span itemprop="name">Python核心技术与实战</span>
                    </a>
                    <meta itemprop="position" content='3' />
                </li>
            
        
            <li class="breadcrumb-item text-capitalize active" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                <span itemprop="name">结束语 - 技术之外的几点成长建议</span>
                <meta itemprop="position" content='4' />
            </li>
        
    </ul>
</nav></div>
                                    
                                    <div class="row flex-xl-nowrap">
                                        
                                        <div class="docs-toc col-xl-3    d-xl-block"><toc>
    <div class="fw-bold text-uppercase mb-2">On this page</div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#计算机科学是一门需要实践的学科">计算机科学是一门需要实践的学科</a></li>
    <li><a href="#选择适合自己的职业方向">选择适合自己的职业方向</a></li>
    <li><a href="#能用代码解决的问题都不是问题">能用代码解决的问题都不是问题</a></li>
  </ul>
</nav>
    </toc></div>
                                        
                                        
                                        <div class="docs-toc-mobile    d-print-none d-xl-none">
                                            <button id="toc-dropdown-btn" class="btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" data-bs-offset="0,0" aria-expanded="false">
                                                Table of Contents
                                            </button>
<nav id="toc-mobile">
  <ul class="dropdown-menu">
    <li><a href="#计算机科学是一门需要实践的学科">计算机科学是一门需要实践的学科</a></li>
    <li><a href="#选择适合自己的职业方向">选择适合自己的职业方向</a></li>
    <li><a href="#能用代码解决的问题都不是问题">能用代码解决的问题都不是问题</a></li>
  </ul>
</nav></div>
                                        <div class="docs-content col-12 col-xl-9 mt-0">
                                            <div class="mb-0 d-flex">
                                                
                                                <i class="material-icons title-icon me-2">article</i>
                                                
                                                <h1 class="content-title mb-0">
                                                    结束语 - 技术之外的几点成长建议
                                                    
                                                </h1>
                                            </div>
                                            
                                            <div id="content" class="main-content" >
                                                
    
    <div data-prismjs-copy="" data-prismjs-copy-success="" data-prismjs-copy-error="">
        <p>你好，我是景霄。</p>
<p>不知不觉，专栏上线已经4个月了，终于到了和你们说再见的时候，心中既有兴奋，又有不舍。说兴奋，是因为自己坚持完成了40多篇文章的写作，这对我而言是一项体力与脑力的“马拉松”，颇有成就感；说不舍，是因为你们的热情远超乎我当时的想象，和你们一起交流学习真的很高兴，收获也很大。</p>
<p>这里也非常感谢极客时间能提供这个平台，让我得以和一万多的学员分享经验。当然，虽然课程结束了，但是技术人的学习并未终止，最后我还想再着重强调这么几点。</p>
<h2 id="计算机科学是一门需要实践的学科">计算机科学是一门需要实践的学科 <a href="#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e6%98%af%e4%b8%80%e9%97%a8%e9%9c%80%e8%a6%81%e5%ae%9e%e8%b7%b5%e7%9a%84%e5%ad%a6%e7%a7%91" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>无论是对于Python这门课程，还是其他语言，或是计算机的其他领域，我认为实践永远是至关重要的。计算机科学是一门偏向工程的学科，所以一定要<strong>多实践，多写代码，多交流，多思考</strong>。实际生活中，我见过不少同学虽然看了很多的书籍，但是代码功底非常差，这是一个很严重的问题。</p>
<p>那么，怎么提高呢？答案就是，请尽可能地参与更多的项目。俗话说“实践出真知”，说的正是这个道理。当你做的东西多了以后，你就会发现，很多的知识都会自然而然地串接起来，感觉自己的任督二脉似乎被打通了一般。</p>
<h2 id="选择适合自己的职业方向">选择适合自己的职业方向 <a href="#%e9%80%89%e6%8b%a9%e9%80%82%e5%90%88%e8%87%aa%e5%b7%b1%e7%9a%84%e8%81%8c%e4%b8%9a%e6%96%b9%e5%90%91" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>关于职业方向的问题，我还是那句话，<strong>对于尚不清晰自己兴趣所在的同学，最好的办法就是多尝试</strong>，因为在尝试的过程中，你就会发现自己的特长，发现自己的喜好，从而坚定不移、一步一步地走下去。</p>
<p>当然，我了解到很多同学都是转行做程序员，以前都不是学计算机的，所以，很多人首先都会遇到“找工作”或者“跳槽”的难题。这种情况下，请不要气馁或是放弃。我也不完全算是科班出身的，我身边好多同事都不是科班出身，但是几年以后，你就会发现，好多当年非科班出身的同学，干得甚至比科班出身的都要好。因此，只要你坚定信念，不要放弃，风雨之后必有彩虹。</p>
<h2 id="能用代码解决的问题都不是问题">能用代码解决的问题都不是问题 <a href="#%e8%83%bd%e7%94%a8%e4%bb%a3%e7%a0%81%e8%a7%a3%e5%86%b3%e7%9a%84%e9%97%ae%e9%a2%98%e9%83%bd%e4%b8%8d%e6%98%af%e9%97%ae%e9%a2%98" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>这句话，主要送给有一定工作经验的朋友。其实，有了一定的积累后，你就会发现，能用代码解决的问题都不是问题。职场上，要想出类拔萃，除了能在技术上独当一面，<strong>如何与他人进行沟通交流，如何正确地处理同事间的关系，都是你额外需要学习的东西</strong>。实际工作中，我也见过不少人，代码能力天赋异禀，但是沟通交流不行，这同样也会阻碍你向上晋升。</p>
<p>就拿一个很简单的例子来说。如果你和周围的同事合作一个项目，你觉得他有一样东西做得不好，你会直接说诸如“你很傻”，“你这样做大错特错”的话吗？你如果这样说了，那可真的是“大错特错了”。事实上，我们通常的一个措辞是，“我觉得你这里做得很好，不过，如果你可以……的话，那就更好了”。</p>
<p>说了这么多，最后，还是要感谢你的订阅，感谢你的一路陪伴，祝你的生活学习一帆风顺，永远幸福！课程虽然已经结束，但是你仍然可以留言，我会尽可能多地一一回复，让你的学习没有遗憾。</p>
<p>结束不是终点，而是更高阶旅程的重新启航。最后的最后，我们专栏的编辑同学，特意为你准备了一份<strong>毕业调查问卷</strong>，希望你能抽出两三分钟时间，写下你的学习经历和感受。这既是你课程学习的仪式感，作为你这几个月学习的记录和总结；也是我后续为你优化课程的重要参考资料，很有价值。感谢你的反馈，学习不停，精进不止！</p>
<p><a href="https://jinshuju.net/f/40SCVf" rel="external" target="_blank">





  



  
    
      <img src="/b1bd25655f8d05d12f719877b4d15946_11444300385840776799.jpg" alt="" width="1142" height="801" loading="lazy">
    
  
<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/></svg></a></p>
<!-- raw HTML omitted -->

    </div>

    

    
                                            </div>
                                            <div><hr class="doc-hr">
<div id="doc-nav" class="d-print-none">

	<div class="row flex-xl-nowrap ">
	<div class="col-sm-6 pt-2 doc-next">
		<a href="/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%BB%93%E8%AF%BE%E6%B5%8B%E8%AF%95---%E5%85%B3%E4%BA%8Epython%E7%9A%84%E8%BF%99%E4%BA%9B%E7%9F%A5%E8%AF%86%E4%BD%A0%E9%83%BD%E6%8E%8C%E6%8F%A1%E4%BA%86%E5%90%97/">
			<div class="card h-100 my-1">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0"><i class="material-icons align-middle">navigate_before</i> 结课测试 - 关于Python的这些知识，你都掌握了吗？</p>
					
				</div>
			</div>
		</a>
        </div>
	<div class="col-sm-6 pt-2 doc-prev">
		<a class="ms-auto" href="/docs/%E6%97%A5%E5%B8%B8/%E5%91%8A%E5%88%AB%E4%BB%A3%E7%A0%81%E5%B7%A5%E4%BA%BA/">
			<div class="card h-100 my-1 text-end">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0">告别代码工人 <i class="material-icons align-middle">navigate_next</i></p>
					
				</div>
			</div>
		</a>
        </div>
	</div>
</div></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
<footer class="shadow py-3 d-print-none">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col">
                <div class="text-sm-start text-center mx-md-2">
                    <p class="mb-0">
                        
                        <strong>NineDoller</strong>@<strong><a href="http://net.chenayin.com">Chenayin</a></strong>
                    </p>
                </div>
            </div>
        </div>
    </div>
</footer>
</main>
            </div>
        </div>

        
        
        <button onclick="topFunction()" id="back-to-top" aria-label="Back to Top Button" class="back-to-top fs-5"><svg width="24" height="24"><path d="M12,10.224l-6.3,6.3L4.32,15.152,12,7.472l7.68,7.68L18.3,16.528Z" style="fill:#fff"/></svg></button>
        
        

        
        




    
    
    






    <script src="/docs/js/bootstrap.js" defer></script>


    <script type="text/javascript" src="http://localhost:1313/docs/js/bundle.js" defer></script>

        

        
        <script type="module">
    var suggestions = document.getElementById('suggestions');
    var search = document.getElementById('flexsearch');

    const flexsearchContainer = document.getElementById('FlexSearchCollapse');

    const hideFlexsearchBtn = document.getElementById('hideFlexsearch');

    const configObject = { toggle: false }
    const flexsearchContainerCollapse = new Collapse(flexsearchContainer, configObject) 

    if (search !== null) {
        document.addEventListener('keydown', inputFocus);
        flexsearchContainer.addEventListener('shown.bs.collapse', function () {
            search.focus();
        });
        
        var topHeader = document.getElementById("top-header");
        document.addEventListener('click', function(elem) {
            if (!flexsearchContainer.contains(elem.target) && !topHeader.contains(elem.target))
                flexsearchContainerCollapse.hide();
        });
    }

    hideFlexsearchBtn.addEventListener('click', () =>{
        flexsearchContainerCollapse.hide()
    })

    function inputFocus(e) {
        if (e.ctrlKey && e.key === '/') {
            e.preventDefault();
            flexsearchContainerCollapse.toggle();
        }
        if (e.key === 'Escape' ) {
            search.blur();
            
            flexsearchContainerCollapse.hide();
        }
    };

    document.addEventListener('click', function(event) {

    var isClickInsideElement = suggestions.contains(event.target);

    if (!isClickInsideElement) {
        suggestions.classList.add('d-none');
    }

    });

    


    document.addEventListener('keydown',suggestionFocus);

    function suggestionFocus(e) {
    const suggestionsHidden = suggestions.classList.contains('d-none');
    if (suggestionsHidden) return;

    const focusableSuggestions= [...suggestions.querySelectorAll('a')];
    if (focusableSuggestions.length === 0) return;

    const index = focusableSuggestions.indexOf(document.activeElement);

    if (e.key === "ArrowUp") {
        e.preventDefault();
        const nextIndex = index > 0 ? index - 1 : 0;
        focusableSuggestions[nextIndex].focus();
    }
    else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
        focusableSuggestions[nextIndex].focus();
    }

    }

    


    (function(){

    var index = new FlexSearch.Document({
        
        tokenize: "forward",
        minlength:  0 ,
        cache:  100 ,
        optimize:  true ,
        document: {
        id: 'id',
        store: [
            "href", "title", "description"
        ],
        index: ["title", "description", "content"]
        }
    });


    


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    

    

    index.add(
            {
                id:  0 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/00---%E5%BC%80%E7%AF%87%E8%AF%8D\/",
                title: "Python核心技术与实战",
                description: "课程介绍 linkPython核心技术与实战\n人工智能时代下，Python毫无疑问是最热的编程语言。有人夸它功能强大还上手轻松，有人说它学习曲线不那么陡峭，但是更多的人，在推开Python的大门后却发现，Python入门容易但精通却不易。\n你是否也曾傻傻分不清“列表”“元组”“字典”“集合”等的用法，甚至试图在集合中采用索引方式？ 你是否也曾苦苦钻研面向对象的理念，却在被要求设计一个稍复杂点的系统时束手无策？ 你是否也曾羡慕别人能巧用装饰器、生成器等高级操作，可自己在写代码时，却连异常抛出、内存不足等边界条件都战战兢兢搞不定呢？ 由此可见，想要精通这门语言，必须真正理解知识概念，比如适当从源码层面深化认知，然后熟悉实际的工程应用，独立完成项目开发。这样，你才能成为真正的语言高手。\n在这个专栏里，景霄会从工程的角度，带你学习Python。专栏基于Python最新的3.7版本，以语言知识结合工程应用为主线，其中包含了大量的独家解读和实际工作案例。内容难易兼顾，既可以带你巩固核心基础，更会教你各种高级进阶操作，让你循序渐进、系统掌握Python这门语言。\n专栏按照进阶难度分为4个模块。\n前两部分主要是Python的基础篇和进阶篇。除去必要的概念、操作讲解，基础篇和进阶篇都着重强调了学习中的重难点和易错点，并从性能分析、实际应用举例等不同维度出发，让你轻松理解和掌握它们。\n第三部分是规范篇，通过讲解合理分解代码、运用assert、写单元测试等具体编程技巧，教你写出高质量的Python程序。\n第四部分则是实战篇，这部分会通过量化交易系统项目的开发，带你串联起前面所学的Python知识，并加入大量的实战经验和技巧，让你在独立项目开发中获得质的提高。\n课程的练习代码：\nhttps://github.com/zwdnet/PythonPractice\n开篇词 link你好，我是景霄。\n我是Facebook的一名全栈工程师，目前从事机器学习的相关工作，主要工作领域是人工智能的推荐排序系统与算法。工作期间，我曾领导多个上亿用户级产品的开发与落地，有丰富的工程与实战经验。\n一听机器学习，很多人第一反应可能是“好难呀、厉害呀”。可事实上，我的编程之路并非一路高光。\n不同于大城市长大或竞赛出身、十一二岁接触编程的人，在刚上大学时，我的编程基础几乎为零。大一上的C语言，便是我出生起学到的第一门编程语言。初识计算机语言的世界，很有趣也很吸引我，这也是我成为程序员的最初动力。\n和很多对编程感兴趣的人一样，哪怕老师只是在讲台上，照本宣科地读着N年前的课件，我也会竖起耳朵认真听讲、认真做笔记。并且，私下里我还买了不少厚重的大块头书，在网上查了不少博客、帖子，照着上面的例子一行行地敲代码。很多内容我并不理解，比如指针、递归这类抽象的概念，查了一堆资料也没看明白。但靠着死记硬背，考试基本可以过关，虽然这个过程比较痛苦，也比较累。\n后来，为了更深入了解计算机，我去了哥伦比亚大学攻读计算机硕士学位，又陆续学到不少新的编程语言，比如Node.js、Python、PHP、Scala等等。这个阶段，我边学习，边做项目，却发现轻松了很多。\n这两个学习阶段，收获和感受天差地别，难道仅仅是因为“万事入门难”吗？我不止一次反思过这个问题，终于发现，问题出在了资料本身上。\n为什么这么说呢？一是因为书上或网上的很多东西，非常理论化，实例少之又少，单凭死记硬背很难真正掌握；二是这些内容中，原创的观点和经验更少，大多互相抄袭，内容雷同且不实用，远离实际工程，毫无借鉴价值。\n但显然，市面上的资料问题，我们个人是很难解决的。我们能做的，便是克服常见资料的弊端，另辟蹊径来学习。这其中，最重要的一点就是，从工程的角度思考学习，以实用为出发点，多练习、多阅读、多做项目，这样才能有质的提高。\n",
                content: "课程介绍 linkPython核心技术与实战\n人工智能时代下，Python毫无疑问是最热的编程语言。有人夸它功能强大还上手轻松，有人说它学习曲线不那么陡峭，但是更多的人，在推开Python的大门后却发现，Python入门容易但精通却不易。\n你是否也曾傻傻分不清“列表”“元组”“字典”“集合”等的用法，甚至试图在集合中采用索引方式？ 你是否也曾苦苦钻研面向对象的理念，却在被要求设计一个稍复杂点的系统时束手无策？ 你是否也曾羡慕别人能巧用装饰器、生成器等高级操作，可自己在写代码时，却连异常抛出、内存不足等边界条件都战战兢兢搞不定呢？ 由此可见，想要精通这门语言，必须真正理解知识概念，比如适当从源码层面深化认知，然后熟悉实际的工程应用，独立完成项目开发。这样，你才能成为真正的语言高手。\n在这个专栏里，景霄会从工程的角度，带你学习Python。专栏基于Python最新的3.7版本，以语言知识结合工程应用为主线，其中包含了大量的独家解读和实际工作案例。内容难易兼顾，既可以带你巩固核心基础，更会教你各种高级进阶操作，让你循序渐进、系统掌握Python这门语言。\n专栏按照进阶难度分为4个模块。\n前两部分主要是Python的基础篇和进阶篇。除去必要的概念、操作讲解，基础篇和进阶篇都着重强调了学习中的重难点和易错点，并从性能分析、实际应用举例等不同维度出发，让你轻松理解和掌握它们。\n第三部分是规范篇，通过讲解合理分解代码、运用assert、写单元测试等具体编程技巧，教你写出高质量的Python程序。\n第四部分则是实战篇，这部分会通过量化交易系统项目的开发，带你串联起前面所学的Python知识，并加入大量的实战经验和技巧，让你在独立项目开发中获得质的提高。\n课程的练习代码：\nhttps://github.com/zwdnet/PythonPractice\n开篇词 link你好，我是景霄。\n我是Facebook的一名全栈工程师，目前从事机器学习的相关工作，主要工作领域是人工智能的推荐排序系统与算法。工作期间，我曾领导多个上亿用户级产品的开发与落地，有丰富的工程与实战经验。\n一听机器学习，很多人第一反应可能是“好难呀、厉害呀”。可事实上，我的编程之路并非一路高光。\n不同于大城市长大或竞赛出身、十一二岁接触编程的人，在刚上大学时，我的编程基础几乎为零。大一上的C语言，便是我出生起学到的第一门编程语言。初识计算机语言的世界，很有趣也很吸引我，这也是我成为程序员的最初动力。\n和很多对编程感兴趣的人一样，哪怕老师只是在讲台上，照本宣科地读着N年前的课件，我也会竖起耳朵认真听讲、认真做笔记。并且，私下里我还买了不少厚重的大块头书，在网上查了不少博客、帖子，照着上面的例子一行行地敲代码。很多内容我并不理解，比如指针、递归这类抽象的概念，查了一堆资料也没看明白。但靠着死记硬背，考试基本可以过关，虽然这个过程比较痛苦，也比较累。\n后来，为了更深入了解计算机，我去了哥伦比亚大学攻读计算机硕士学位，又陆续学到不少新的编程语言，比如Node.js、Python、PHP、Scala等等。这个阶段，我边学习，边做项目，却发现轻松了很多。\n这两个学习阶段，收获和感受天差地别，难道仅仅是因为“万事入门难”吗？我不止一次反思过这个问题，终于发现，问题出在了资料本身上。\n为什么这么说呢？一是因为书上或网上的很多东西，非常理论化，实例少之又少，单凭死记硬背很难真正掌握；二是这些内容中，原创的观点和经验更少，大多互相抄袭，内容雷同且不实用，远离实际工程，毫无借鉴价值。\n但显然，市面上的资料问题，我们个人是很难解决的。我们能做的，便是克服常见资料的弊端，另辟蹊径来学习。这其中，最重要的一点就是，从工程的角度思考学习，以实用为出发点，多练习、多阅读、多做项目，这样才能有质的提高。\n在Facebook工作的这么多年，也验证了我的观点。我身边的新手，他们学习新的语言总是只会啃书练习，还难以上手；而有经验的同事则不同，他们能花很短的时间看完基础语法，然后找行家去了解一些重难点、易错点，最后亲自动手完成一个项目，达到融会贯通的效果。这样下来，可能几周时间就掌握得差不多了。\n这样的差距，确实让人心塞，而这也是我开这个专栏的最初动力——帮助更多入门级程序员迅速成长。至于专栏主题，我选择了Python这门编程语言，原因也很明了。\n这首先来自于我个人的重要感悟。经过多年学习工作的积累，我深刻认识到，牢牢掌握一门编程语言及其学习方法，是日后在所有领域深造的根基。而在实际工作和生活中，我更是见过不少反例，比如搞机器学习的工程师，算法、理论等极强，但是编程水平或是工程水平很一般，于是涉及到偏工程的工作或合作时，就显得力不从心，这样就非常可惜了。\n另外，不可否认，Python确实是这个时代最流行、也必须要掌握的编程语言。Python可以运用在数据处理、Web开发、人工智能等多个领域，它的语言简洁、开发效率高、可移植性强，并且可以和其他编程语言（比如C++）轻松无缝衔接。现如今，不少学校的文科生甚至中学生也开设了此课程，可见其重要程度。\n因此，我决定开设这么一个专栏，从工程的角度去讲解Python这门编程语言。我不是语言学专家，不会死抠一些很偏的知识点；相反，作为一名工程师，我会从实际出发，以工作中遇到的实例为主线，去讲解Python的核心技术和应用。\n专栏的所有内容都基于Python最新的3.7版本，其中有大量独家解读、案例，以及不少我阅读源码后的发现和体会。同时，在层次划分上，我希望能难易兼顾，循序渐进。专栏中既有核心的基础知识，也有高级的进阶操作，尽量做到“老少皆宜”。\n从内容上来说，专栏主要分为四大版块。\n1. Python基础篇\n第一部分主要讲解Python的基础知识。当然，不同于其他基础教材，专栏的基础版块并不只有基础概念、操作，我同时加入了很多进阶难度的知识，或是一些重难点、易错点等需要注意的地方。如果你觉得自己基础的东西都会了，这部分不用学了，那你就大错特错了。比如，\n列表和元组存储结构的差异是怎样的？它们性能的详细比较又如何？ 字符串相加的时间复杂度，你真的清楚吗？ 基础不牢，地动山摇。更深刻、实质的基础理解，才是更牢固的知识大厦的根基。我希望这一版块，不仅可以让入门级的程序员查漏补缺、打牢基础，也能让有经验的程序员，重新从工程角度认识基础、升华理解。\n2. Python进阶篇\n这部分讲的是 Python的一些进阶知识，比如装饰器、并发编程等等。如果你的工作只是写100行以下的脚本程序，可能不怎么会用得到。但如果你做的是大型程序的开发，则非常有必要。我希望通过这一版块，让你熟悉各种高级用法，真正理解Python，理解这门编程语言的特点。\n3. Python规范篇\n这部分着重于教你把程序写得更加规范、更加稳定。我在实际工作中见过不少程序员，会写程序，但写得实在有点“惨不忍睹”，导致最后调试起来错误不断，修改非常费劲儿。因此，我觉得用单独一个版块讲解这个问题非常有必要。\n当然，我不会用一些似是而非的规范来说教，而是会用具体的编程操作和技巧，教你提高代码质量。比如，如何合理地分解代码、运用assert，如何写单元测试等等。\n4. Python实战篇\n没上过战场开过枪的人，不可能做主官；没有实战经验的语言学习者，不可能成为高手。这部分，我会通过量化交易系统这个具体的实战案例，带你综合运用前面所学的Python知识。\n真正要掌握一门编程语言，仅仅学会分散的知识点是不够的，还必须要把知识点串联起来，做一些中型的项目才能有更深的领悟与提高。\n专栏篇幅只有40多篇，但是每篇绝对都是干货满满。我希望这个专栏，能帮助更多入门级和有一定项目基础的程序员，真正掌握Python，并且给你一些学习上的启发。\n100天后，晋级为Python高手，让我们一起加油吧！\n课程的练习代码：https://github.com/zwdnet/PythonPractice\n"
            }
        );
    index.add(
            {
                id:  1 ,
                href: "\/docs\/python\/python\/",
                title: "Python学习笔记",
                description: " 笔者为 Javaer 所以仅记录和Java语言的不同之处，方便快速学习\n基础数据类型 link 数字 bool（布尔型）：True | False\n笔者按： 布尔值要驼峰命令\ncomplex （复数），如 1 + 2j、 1.1 + 2.2j。\n笔者按： 已经忘记复数这个数学概念啦~\n字符串 索引 字符串的组成元素为字符，每个字符在字符串中有对应的索引。\n和java不同的是，不光有正序索引，还有倒序索引\n截取 字符串的截取，都是 前闭后开 或者 叫 含头不含尾\npython字符串的截取和索引强相关；\n但又因为有正序和倒序，两排索引，所以截取时非常灵活，使用时也要谨慎\n图片来自网络，倒数第二个例子有点奇怪： 描述和结果都不对；要实现输出结果ab，可通过如下方式\nprint(str[:2]) # ab\rprint(str[:-5]) # ab str=\"abcdefg\"\rprint(str[1:]) # bcdefg\rprint(str[:5]) # abcde\rprint(str[1:5]) # bcde\rprint(str[-4:]) # defg\rprint(str[-2:-6]) # 空字符串 是 '' 不是None\rprint(str[-6:-2]) #bcde\rprint(str[::-1]) # 字符串反转 gfedcba\rprint(str[:2]) # ab\rprint(str[:-5]) # ab 列表 笔者按： 和Java中的数组特点一样； 最大最大的区别是 一个数组可以有不同类型的元素；\n",
                content: " 笔者为 Javaer 所以仅记录和Java语言的不同之处，方便快速学习\n基础数据类型 link 数字 bool（布尔型）：True | False\n笔者按： 布尔值要驼峰命令\ncomplex （复数），如 1 + 2j、 1.1 + 2.2j。\n笔者按： 已经忘记复数这个数学概念啦~\n字符串 索引 字符串的组成元素为字符，每个字符在字符串中有对应的索引。\n和java不同的是，不光有正序索引，还有倒序索引\n截取 字符串的截取，都是 前闭后开 或者 叫 含头不含尾\npython字符串的截取和索引强相关；\n但又因为有正序和倒序，两排索引，所以截取时非常灵活，使用时也要谨慎\n图片来自网络，倒数第二个例子有点奇怪： 描述和结果都不对；要实现输出结果ab，可通过如下方式\nprint(str[:2]) # ab\rprint(str[:-5]) # ab str=\"abcdefg\"\rprint(str[1:]) # bcdefg\rprint(str[:5]) # abcde\rprint(str[1:5]) # bcde\rprint(str[-4:]) # defg\rprint(str[-2:-6]) # 空字符串 是 '' 不是None\rprint(str[-6:-2]) #bcde\rprint(str[::-1]) # 字符串反转 gfedcba\rprint(str[:2]) # ab\rprint(str[:-5]) # ab 列表 笔者按： 和Java中的数组特点一样； 最大最大的区别是 一个数组可以有不同类型的元素；\n换句话说： 一个数组中可以同时存在 数字，字符串。\nlist1 = ['Google', 'baidu', 1997, 2000] 删除方法\ndel list[1] 添加方法\nlist.append('red') 【思考】如何预创建一个容量为n的列表？\n📝 注意事项\nPython 列表是动态数组，不需要像 C++ 的 vector 或 Java 的 ArrayList 那样“预分配容量”来提高性能。 如果你只是想创建一个将来要存 n 个元素的列表，直接使用空列表即可： python深色版本\nlst = [] 然后通过 append() 添加元素即可。\n如果非要创建呢？\nlst = [None] * 6\rprint(lst) # 输出: [None, None, None, None, None, None] 元组 和列表功能类似，区别有两个\n元祖不可变： 不可变指：元素数量和值在定义之后都不允许发生变化\n元祖用 () ; 列表用 [] .\ntup = (1, 2, 3, 4, 5 )\rprint(tup) # (1, 2, 3, 4, 5)\r#tup[0] = 15\r#print(tup) # TypeError: 'tuple' object does not support item assignment\r#tup.append(6)\r#print(tup) # AttributeError: 'tuple' object has no attribute 'append' 集合 使用方式:注意是 {}\n特点有三：\n可变 无序 元素唯一 （不重复） 和Java的Set的特点相似，在Python中也叫Set;\n元素唯一的特性常常用来去重\nfruits = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\rprint(fruits) # 这⾥演示的是去重功能 {'pear', 'orange', 'banana', 'apple'}\rprint( 'orange' in fruits) # 快速判断元素是否在集合内 True\rprint( 'crabgrass' in fruits) # False 字典 字典就是KV；可以依据key，查询value\n在Java中就是Map; put的方式不一样\n字典的初始化、进和出 示例如下:\nzhangsan={\r\"name\":\"zhangsan\",\r\"age\":\"17\",\r\"height\":\"180\",\r\"weight\":\"80kg\"\r}\r#给字典添加元素\rzhangsan[\"city\"]=\"BeiJing\"\r#获取字典的元素\rprint(zhangsan.get(\"age\")) 数据类型的判断和转换 link判断 linktype(变量)\n常规的判断就不展示了，展示一些有悖常规的。\n\u003e\u003e\u003e type([1,2,3])\r"
            }
        );
    index.add(
            {
                id:  2 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/01---%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E7%AA%81%E7%A0%B4%E6%88%90%E4%B8%BApython%E9%AB%98%E6%89%8B\/",
                title: "01-如何逐步突破，成为Python高手",
                description: "你好，我是景霄。\n工作中，我总听到很多程序员抱怨，说现在的计算机编程语言太多了，学不过来了。一些人Java用了很多年，但是最近的项目突然需要用Python，就会不知所措，压力很大。\n众所周知，Facebook的主流语言是Hack（PHP的进化版本）。不过，我敢拍着胸脯说，就刚入职的工程师而言，100个里至少有95个，以前都从未用过Hack或者PHP。但是，这些人上手都特别快，基本上一两周后，日常编程便毫无压力了。\n他们是怎么做到的呢？\n事实上，他们遵循的，正是我在开篇词中提到的方法，也是本专栏学习的中心观点：“从工程的角度去学习Python”。那么具体来说，到底要怎么学，学习的过程中又要特别注意哪些地方呢？\n不同语言，需融会贯通 link其实，如果你在学一门语言的时候多阅读、多练习、多思考，你就会发现，不同语言都是类似的。编程语言本就是人类控制计算机的指令，语法规则等方面自然大同小异。\n而在原有基础上，学习一门新的编程语言，其实也没有那么难，你首先要做到的是明确区分。比如，在学习Python的条件与循环语句时，多回忆一下其他语言的语法是怎样的。再如，遇到Python中的字符串相加时，你能分析出它的复杂度吗？再联想到其他语言，比如Java中字符串相加的复杂度，它们之间有什么相同点、又有什么区别呢？\n除了能够明确区分语言的不同点，我们还要能联系起来灵活运用。比如，最典型的“编程语言两问”：\n你了解你学过的每种编程语言的特点吗？ 你能根据不同的产品需求，选用合适的编程语言吗？ 举个例子，Python的优点之一是特别擅长数据分析，所以广泛应用于人工智能、机器学习等领域，如机器学习中TensorFlow的框架，就是用Python写的。但是涉及到底层的矩阵运算等等，还是要依赖于C++完成，因为C++的速度快，运行效率更高。\n事实上，很多公司都是这样，服务器端开发基于Python，但底层的基础架构依赖于C++。这就是典型的“不同需求选用不同语言”。毕竟，你要明白，哪怕只是几十到几百毫秒的速度差距，对于公司、对于用户体验来说都是决定性的。\n唯一语言，可循序渐进 link当然，如果Python是你学的第一门编程语言，那也不必担心。我们知道，虽然同为人机交互的桥梁，Python语言比起C++、Java等主流语言，语法更简洁，也更接近英语，对编程世界的新人还是很友好的，这也是其显著优点。这种情况下，你要做的就是专注于Python这一门语言，明确学习的重点，把握好节奏循序渐进地学习。\n根据我多年的学习工作经验，我把编程语言的学习重点，总结成了下面这三步，无论你是否有其他语言的基础，都可以对照来做，稳步进阶。\n第一步：大厦之基，勤加练习 link任何一门编程语言，其覆盖范围都是相当广泛的，从基本的变量赋值、条件循环，到并发编程、Web开发等等，我想市面上几乎没有任何一本书能够罗列完全。\n所以，我建议你，在掌握必要的基础时，就得多上手操作了。千万不要等到把教材上所有东西都学完了才开始，因为到那时候你会发现，前面好不容易记住的一堆东西似乎又忘记了。计算机科学是一门十分讲究实战的学科，因此越早上手练习，练得越多越勤，就越好。\n不过，到底什么叫做必要的基础呢？以Python为例，如果你能够理解变量间的赋值、基本的数据类型、条件与循环语句、函数的用法，那么你就达到了第一步的底线标准，应该开始在课下多多练习了。\n比方说，你可以自己动手编程做一个简易的计算器，这应该也是大多数程序员实操的第一个小项目。用户输入数字和运算符后，你的程序能够检查输入是否合法并且返回正确的结果吗？\n在做这个小项目的过程中，你可能会遇到不少问题。我的建议是，遇到不懂的问题时，多去Stack Overflow上查询，这样你还能阅读别人优秀的代码，借鉴别人的思路，对于你的学习肯定大有帮助。当然，实在解决不了的问题，也可以写在留言区，我们一起来解决。\n",
                content: "你好，我是景霄。\n工作中，我总听到很多程序员抱怨，说现在的计算机编程语言太多了，学不过来了。一些人Java用了很多年，但是最近的项目突然需要用Python，就会不知所措，压力很大。\n众所周知，Facebook的主流语言是Hack（PHP的进化版本）。不过，我敢拍着胸脯说，就刚入职的工程师而言，100个里至少有95个，以前都从未用过Hack或者PHP。但是，这些人上手都特别快，基本上一两周后，日常编程便毫无压力了。\n他们是怎么做到的呢？\n事实上，他们遵循的，正是我在开篇词中提到的方法，也是本专栏学习的中心观点：“从工程的角度去学习Python”。那么具体来说，到底要怎么学，学习的过程中又要特别注意哪些地方呢？\n不同语言，需融会贯通 link其实，如果你在学一门语言的时候多阅读、多练习、多思考，你就会发现，不同语言都是类似的。编程语言本就是人类控制计算机的指令，语法规则等方面自然大同小异。\n而在原有基础上，学习一门新的编程语言，其实也没有那么难，你首先要做到的是明确区分。比如，在学习Python的条件与循环语句时，多回忆一下其他语言的语法是怎样的。再如，遇到Python中的字符串相加时，你能分析出它的复杂度吗？再联想到其他语言，比如Java中字符串相加的复杂度，它们之间有什么相同点、又有什么区别呢？\n除了能够明确区分语言的不同点，我们还要能联系起来灵活运用。比如，最典型的“编程语言两问”：\n你了解你学过的每种编程语言的特点吗？ 你能根据不同的产品需求，选用合适的编程语言吗？ 举个例子，Python的优点之一是特别擅长数据分析，所以广泛应用于人工智能、机器学习等领域，如机器学习中TensorFlow的框架，就是用Python写的。但是涉及到底层的矩阵运算等等，还是要依赖于C++完成，因为C++的速度快，运行效率更高。\n事实上，很多公司都是这样，服务器端开发基于Python，但底层的基础架构依赖于C++。这就是典型的“不同需求选用不同语言”。毕竟，你要明白，哪怕只是几十到几百毫秒的速度差距，对于公司、对于用户体验来说都是决定性的。\n唯一语言，可循序渐进 link当然，如果Python是你学的第一门编程语言，那也不必担心。我们知道，虽然同为人机交互的桥梁，Python语言比起C++、Java等主流语言，语法更简洁，也更接近英语，对编程世界的新人还是很友好的，这也是其显著优点。这种情况下，你要做的就是专注于Python这一门语言，明确学习的重点，把握好节奏循序渐进地学习。\n根据我多年的学习工作经验，我把编程语言的学习重点，总结成了下面这三步，无论你是否有其他语言的基础，都可以对照来做，稳步进阶。\n第一步：大厦之基，勤加练习 link任何一门编程语言，其覆盖范围都是相当广泛的，从基本的变量赋值、条件循环，到并发编程、Web开发等等，我想市面上几乎没有任何一本书能够罗列完全。\n所以，我建议你，在掌握必要的基础时，就得多上手操作了。千万不要等到把教材上所有东西都学完了才开始，因为到那时候你会发现，前面好不容易记住的一堆东西似乎又忘记了。计算机科学是一门十分讲究实战的学科，因此越早上手练习，练得越多越勤，就越好。\n不过，到底什么叫做必要的基础呢？以Python为例，如果你能够理解变量间的赋值、基本的数据类型、条件与循环语句、函数的用法，那么你就达到了第一步的底线标准，应该开始在课下多多练习了。\n比方说，你可以自己动手编程做一个简易的计算器，这应该也是大多数程序员实操的第一个小项目。用户输入数字和运算符后，你的程序能够检查输入是否合法并且返回正确的结果吗？\n在做这个小项目的过程中，你可能会遇到不少问题。我的建议是，遇到不懂的问题时，多去Stack Overflow上查询，这样你还能阅读别人优秀的代码，借鉴别人的思路，对于你的学习肯定大有帮助。当然，实在解决不了的问题，也可以写在留言区，我们一起来解决。\n第二步：代码规范，必不可少 link诚然，学习编程讲究快和高效。但是，与此同时，请一定不要忽略每一种语言必要的编程规范。在你自己刚开始写代码练习时，你可以不写单元测试，但总不能几百行的代码却没有一个函数，而是从头顺序写到尾吧？你可以省略一些可有可无的注释，但总不能把很多行代码全部并到一行吧？\n比如，我们来看下面这行代码：\nv.A(param1, param2, param3).B(param4, param5).C(param6, param7).D() 显然，这样写十分不科学，应该把它拆分成多行：\nv.A(param1, param2, param3) \\ # 字符'\\'表示换行\r.B(param4, param5) \\\r.C(param6, param7) \\\r.D() 再比如，变量和函数的命名虽有一定的随意性，但一定要有意义。如果你图省事，直接把变量依次命名为v1、v2、v3等，把函数依次命名为func1、func2、func3等等，不仅让其他人难理解，就算是你自己，日后维护起来都费劲儿。\n一名优秀的程序员，一定遵守编程语言的代码规范。像Facebook的工程师，每次写完代码都必须经过别人的review才能提交。如果有不遵守代码规范的例子，哪怕只是一个函数或是一个变量的命名，我们都会要求原作者加以修改，严格规范才能保证代码库的代码质量。\n第三步：开发经验，质的突破 link想要真正熟练地掌握Python或者是任何一门其他的编程语言，拥有大中型产品的开发经验是必不可少的。因为实战经验才能让你站得更高，望得更远。\n比如我们每天都在用搜索引擎，但你了解一个搜索引擎的服务器端实现吗？这是一个典型的面向对象设计，你需要定义一系列相关的类和函数，需要从产品需求、代码复杂度、效率以及可读性等多个方面考虑，同时，上线后还要进行各种优化等等。\n当然，在专栏里我没办法让你完成一个上亿用户级的实践产品，但是我会把自己这些年的开发经验倾囊相授，并通过量化交易这个实战案例，带你踏入“高级战场”，帮你掌握必要的开发知识。\n最后，我专门为你绘制了一张Python学习的知识图谱，里面涵盖了Python最高频的核心知识，大部分内容我在专栏中都会讲到。你可以保存或者打印出来，作为学习参考。\n今天，我跟你分享了Python的学习方法和注意事项，其实这些观点不只适用于Python，也能帮助你学习任何一门其他计算机编程语言，希望你能牢记在心。在接下来的课程里，我会带你逐步突破，最终成为一名Python高手。\n那么，对于学习Python或者是其他编程语言，你有什么困扰或是心得吗？欢迎在留言区与我交流！\n"
            }
        );
    index.add(
            {
                id:  3 ,
                href: "\/docs\/python\/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84\/",
                title: "Python中的集合",
                description: "一、列表和元组 link共同点 link 任意数据类型的有序集合\n都⽀持负数索引\n都⽀持切⽚操作\n可以随意嵌套（其实就是任意数据类型的一种表现）\n通过list()和tuple()函数相互转换\n不同点 link 列表 元组 动态 静态 list.reverse() 倒转列表list.sort() 排序 没有内置的这两个函数 存储空间可变包含以下内容：- 指针- 已分配内容- 元素内容 存储空间固定 各有千秋 link 占用空间 集合元素少，空间差异可忽略；\n集合元素数量级大，空间差异明显 ，列表空间明显大于元组；\n可用作选择 列表和元组的参考因素\n性能 元组性能略优\n原因如下：\npython优化静态数据-\u003e资源缓存；\n元组属于静态数据，会被缓存，资源重复利用率高；\n在初始化方面，元组性能高于列表；\n二、字典和集合 link",
                content: "一、列表和元组 link共同点 link 任意数据类型的有序集合\n都⽀持负数索引\n都⽀持切⽚操作\n可以随意嵌套（其实就是任意数据类型的一种表现）\n通过list()和tuple()函数相互转换\n不同点 link 列表 元组 动态 静态 list.reverse() 倒转列表list.sort() 排序 没有内置的这两个函数 存储空间可变包含以下内容：- 指针- 已分配内容- 元素内容 存储空间固定 各有千秋 link 占用空间 集合元素少，空间差异可忽略；\n集合元素数量级大，空间差异明显 ，列表空间明显大于元组；\n可用作选择 列表和元组的参考因素\n性能 元组性能略优\n原因如下：\npython优化静态数据-\u003e资源缓存；\n元组属于静态数据，会被缓存，资源重复利用率高；\n在初始化方面，元组性能高于列表；\n二、字典和集合 link"
            }
        );
    index.add(
            {
                id:  4 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/02---jupyter-notebook%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%B0%E4%BB%A3python%E7%9A%84%E5%BF%85%E5%AD%A6%E6%8A%80%E6%9C%AF\/",
                title: "02-Jupyter Notebook 为什么是现在Python的必学技术",
                description: "你好，我是景霄。\nStack Overflow 曾在2017年底，发布了在该站上各种语言的提问流量。其中，Python已经超过了JavaScript成为了流量最高的语言，预测在2020年前会远远甩开JavaScript。\n可能你已经知道，Python在14年后的“崛起”，得益于机器学习和数学统计应用的兴起。那为什么Python如此适合数学统计和机器学习呢？作为“老司机”的我可以肯定地告诉你，Jupyter Notebook （https://jupyter.org/）功不可没。\n毫不夸张地说，根据我对Facebook等硅谷一线大厂的了解，一个Python工程师如果现在还不会使用Jupyter Notebook的话，可能就真的太落伍了。\n磨刀不误砍柴工，高效的工具让我们的编程事半功倍。这一节课，我就来带你学习一下Jupyter Notebook，为后面的Python学习打下必备基础。\n什么是Jupyter Notebook？ link说了这么多，到底什么是Jupyter Notebook？按照Jupyter 创始人 Fernando Pérez的说法，他最初的梦想是做一个综合 Ju （Julia）、Py （Python）和 R 三种科学运算语言的计算工具平台，所以将其命名为Ju-Py-te-R。发展到现在，Jupyter 已经成为一个几乎支持所有语言，能够把软件代码、计算输出、解释文档、多媒体资源整合在一起的多功能科学运算平台。\n",
                content: "你好，我是景霄。\nStack Overflow 曾在2017年底，发布了在该站上各种语言的提问流量。其中，Python已经超过了JavaScript成为了流量最高的语言，预测在2020年前会远远甩开JavaScript。\n可能你已经知道，Python在14年后的“崛起”，得益于机器学习和数学统计应用的兴起。那为什么Python如此适合数学统计和机器学习呢？作为“老司机”的我可以肯定地告诉你，Jupyter Notebook （https://jupyter.org/）功不可没。\n毫不夸张地说，根据我对Facebook等硅谷一线大厂的了解，一个Python工程师如果现在还不会使用Jupyter Notebook的话，可能就真的太落伍了。\n磨刀不误砍柴工，高效的工具让我们的编程事半功倍。这一节课，我就来带你学习一下Jupyter Notebook，为后面的Python学习打下必备基础。\n什么是Jupyter Notebook？ link说了这么多，到底什么是Jupyter Notebook？按照Jupyter 创始人 Fernando Pérez的说法，他最初的梦想是做一个综合 Ju （Julia）、Py （Python）和 R 三种科学运算语言的计算工具平台，所以将其命名为Ju-Py-te-R。发展到现在，Jupyter 已经成为一个几乎支持所有语言，能够把软件代码、计算输出、解释文档、多媒体资源整合在一起的多功能科学运算平台。\n英文里说一图胜千言（A picture is worth a thousand words）。看下面这个图片，你就明白什么是Jupyter Notebook了。\n你在一个框框中直接输入代码，运行，它立马就在下面给你输出。怎么样，是不是很酷？你可能会纳闷儿，这样一个看起来“华而不实”的玩意儿，真的就成了Python社区的颠覆者吗？说实话放在几年前我也是不信的。所以 Jupyter Notebook 的影响究竟有多大呢？\nJupyter Notebook 的影响力 link我们衡量一个技术的影响力，或者说要用自己的技术去影响世界时，必定绕不开这个技术对教育界的影响力。\n就拿微软的Word文本处理系统来说吧。从纯技术角度来讲，Word的单机设计理念早已落后时代20年。但以Google Doc为代表的在线文档系统，却并没有像想象中那样，实现对Word的降维打击。\n直观的原因是用户习惯，使用Word修改文档，那就来回发几十遍呗，用着也还可以。但更深刻来想，之所以养成这样的用户习惯，是因为我们的教育根源。教育系统从娃娃抓起，用小学中学大学十几年的时间，训练了用户Word的使用习惯。到工作中，老员工又会带着新员工继续使用Word，如此形成技术影响力生生不息的正向反馈。\n回到我们今天的主题，我们来看Jupyter Notebook。从2017年开始，已有大量的北美顶尖计算机课程，开始完全使用Jupyter Notebook作为工具。比如李飞飞的CS231N《计算机视觉与神经网络》课程，在16年时作业还是命令行Python的形式，但是17年的作业就全部在Jupyter Notebook上完成了。再如UC Berkeley的《数据科学基础》课程，从17年起，所有作业也全部用Jupyter Notebook完成。\n而Jupyter Notebook 在工业界的影响力更甚。在Facebook，虽然大规模的后台开发仍然借助于功能齐全的IDE，但是几乎所有的中小型程序，比如内部的一些线下分析软件，机器学习模块的训练都是借助于Jupyter Notebook完成的。据我了解，在别的硅谷一线大厂，例如Google的AI Research部门Google Brain，也是清一色地全部使用Jupyter Notebook，虽然用的是他们自己的改进定制版，叫 Google Colab。\n看到这里，相信你已经认可了Jupter Notebook现如今的江湖地位。不过，说到技术的选择，有些人会说，这个技术流行，我们应该用；有些人认为，阿里已经在用这个技术了，这就是未来，我们也要用等等。不得不说，这些都是片面的认知。不管是阿里还是Facebook用的技术，其实不一定适用你的应用场景。\n我经常会鼓励技术同行，对于技术选择要有独立的思考，不要人云亦云。最起码你要去思考，Facebook为什么选择这个技术？这个技术解决了哪些问题？Facebook为什么不选择别的技术？有哪些局限？单从选择结果而言，Facebook选择的技术很可能是因为它有几百个产品线，几万个工程师。而同样的技术，在一个十人的团队里，反而成了拖累。\n在这里，我不想忽悠你任何技术，我想教会你的是辩证分析技术的思考方法。接下来，我们就来看看，Jupyter究竟解决了哪些别人没有解决的问题。\nJupyter的优点 link整合所有的资源 link在真正的软件开发中，上下文切换占用了大量的时间。什么意思呢？举个例子你就很好理解了，比如你需要切换窗口去看一些文档，再切换窗口去用另一个工具画图等等。这些都是影响生产效率的因素。\n正如我前面提到的，Jupyter通过把所有和软件编写有关的资源全部放在一个地方，解决了这个问题。当你打开一个Jupyter Notebook时，就已经可以看到相应的文档、图表、视频和相应的代码。这样，你就不需要切换窗口去找资料，只要看一个文件，就可以获得项目的所有信息。\n交互性编程体验 link在机器学习和数学统计领域，Python编程的实验性特别强，经常出现的情况是，一小块代码需要重写100遍，比如为了尝试100种不同的方法，但别的代码都不想动。这一点和传统的Python开发有很大不同。如果是在传统的Python开发流程中，每一次实验都要把所有代码重新跑一遍，会花费开发者很多时间。特别是在像Facebook这样千万行级别的代码库里，即使整个公司的底层架构已经足够优化，真要重新跑一遍，也需要几分钟的时间。\n而Jupyter Notebook 引进了Cell的概念，每次实验可以只跑一小个Cell里的代码；并且，所见即所得，在代码下面立刻就可以看到结果。这样强的互动性，让Python研究员可以专注于问题本身，不被繁杂的工具链所累，不用在命令行直接切换，所有科研工作都能在Jupyter上完成。\n零成本重现结果 link同样在机器学习和数学统计领域，Python的使用是非常短平快的。常见的场景是，我在论文里看到别人的方法效果很好，可是当我去重现时，却发现需要pip重新安装一堆依赖软件。这些准备工作可能会消耗你80%的时间，却并不是真正的生产力。\nJupyter Notebook如何解决这个问题呢？\n其实最初的Jupyter Notebook也是挺麻烦的，需要你先在本机上安装IPython引擎及其各种依赖软件。不过现在的技术趋势，则是彻底云端化了，例如Jupyter官方的Binder平台（介绍文档：https://mybinder.readthedocs.io/en/latest/index.html）和Google提供的 Google Colab环境（介绍：https://colab.research.google.com/notebooks/welcome.ipynb）。它们让Jupyter Notebook变得和石墨文档、Google Doc在线文档一样，在浏览器点开链接就能运行。\n所以，现在当你用Binder打开一份GitHub上的Jupyter Notebook时，你不需要安装任何软件，直接在浏览器打开一份代码，就能在云端运行。\nJupyter Notebook 初体验 link学习技术的最好方法就是用技术。不过，在今天的篇幅里，我不可能带你完全学会Jupyter Notebook的所有技巧。我想先带你直接感受一下，使用Jupyter Notebook的工作体验。\n比如这样一个GitHub文件。在Binder中，你只要输入其对应的GitHub Repository的名字或者URL，就能在云端打开整个Repository，选择你需要的notebook，你就能看到下图这个界面。\n每一个Jupyter的运行单元都包含了In、Out的Cell。如图所示，你可以使用Run按钮，运行单独的一个Cell。当然，你也可以在此基础上加以修改，或者新建一个notebook，写成自己想要的程序。赶紧打开链接试一试吧！\n另外，我还推荐下面这些Jupyter Notebook，作为你实践的第一站。\n第一个是Jupyter官方：https://mybinder.org/v2/gh/binder-examples/matplotlib-versions/mpl-v2.0/?filepath=matplotlib_versions_demo.ipynb 第二个是Google Research提供的Colab环境，尤其适合机器学习的实践应用：https://colab.research.google.com/notebooks/basic_features_overview.ipynb 如果你想在本地或者远程的机器上安装Jupyter Notebook，可以参考下面的两个文档。\n安装：https://jupyter.org/install.html\n运行：https://jupyter.readthedocs.io/en/latest/running.html#running\n总结 link这节课，我为你介绍了Jupyter Notebook，并告诉你它为什么日趋成为Python社区的必学技术。这主要是因为它的三大特点：整合所有的资源、交互性编程体验和零成本重现结果。但还是那句话，学习技术必须动手实操。这节课后，希望你能自己动手试一试Jupyter Notebook，后面我们的一些课程代码，我也会用Jupyter Notebook的形式分享给你。\n思考题 link你尝试Jupyter Notebook了吗？欢迎在留言区和我分享你的使用体验。\n"
            }
        );
    index.add(
            {
                id:  5 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/03---%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E5%88%B0%E5%BA%95%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA\/",
                title: "03-列表和元组，到底用哪一个？",
                description: "你好，我是景霄。\n前面的课程，我们讲解了Python语言的学习方法，并且带你了解了Python必知的常用工具——Jupyter。那么从这节课开始，我们将正式学习Python的具体知识。\n对于每一门编程语言来说，数据结构都是其根基。了解掌握Python的基本数据结构，对于学好这门语言至关重要。今天我们就一起来学习，Python中最常见的两种数据结构：列表（list）和元组（tuple）。\n列表和元组基础 link首先，我们需要弄清楚最基本的概念，什么是列表和元组呢？\n实际上，列表和元组，都是一个可以放置任意数据类型的有序集合。\n在绝大多数编程语言中，集合的数据类型必须一致。不过，对于Python的列表和元组来说，并无此要求：\nl = [1, 2, 'hello', 'world'] # 列表中同时含有int和string类型的元素\rl\r[1, 2, 'hello', 'world']\rtup = ('jason', 22) # 元组中同时含有int和string类型的元素\rtup\r('jason', 22) 其次，我们必须掌握它们的区别。\n列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。 下面的例子中，我们分别创建了一个列表与元组。你可以看到，对于列表，我们可以很轻松地让其最后一个元素，由4变为40；但是，如果你对元组采取相同的操作，Python 就会报错，原因就是元组是不可变的。\nl = [1, 2, 3, 4]\rl[3] = 40 # 和很多语言类似，python中索引同样从0开始，l[3]表示访问列表的第四个元素\rl\r[1, 2, 3, 40]\rtup = (1, 2, 3, 4)\rtup[3] = 40\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: 'tuple' object does not support item assignment 可是，如果你想对已有的元组做任何\"改变\"，该怎么办呢？那就只能重新开辟一块内存，创建新的元组了。\n",
                content: "你好，我是景霄。\n前面的课程，我们讲解了Python语言的学习方法，并且带你了解了Python必知的常用工具——Jupyter。那么从这节课开始，我们将正式学习Python的具体知识。\n对于每一门编程语言来说，数据结构都是其根基。了解掌握Python的基本数据结构，对于学好这门语言至关重要。今天我们就一起来学习，Python中最常见的两种数据结构：列表（list）和元组（tuple）。\n列表和元组基础 link首先，我们需要弄清楚最基本的概念，什么是列表和元组呢？\n实际上，列表和元组，都是一个可以放置任意数据类型的有序集合。\n在绝大多数编程语言中，集合的数据类型必须一致。不过，对于Python的列表和元组来说，并无此要求：\nl = [1, 2, 'hello', 'world'] # 列表中同时含有int和string类型的元素\rl\r[1, 2, 'hello', 'world']\rtup = ('jason', 22) # 元组中同时含有int和string类型的元素\rtup\r('jason', 22) 其次，我们必须掌握它们的区别。\n列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。 下面的例子中，我们分别创建了一个列表与元组。你可以看到，对于列表，我们可以很轻松地让其最后一个元素，由4变为40；但是，如果你对元组采取相同的操作，Python 就会报错，原因就是元组是不可变的。\nl = [1, 2, 3, 4]\rl[3] = 40 # 和很多语言类似，python中索引同样从0开始，l[3]表示访问列表的第四个元素\rl\r[1, 2, 3, 40]\rtup = (1, 2, 3, 4)\rtup[3] = 40\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: 'tuple' object does not support item assignment 可是，如果你想对已有的元组做任何\"改变\"，该怎么办呢？那就只能重新开辟一块内存，创建新的元组了。\n比如下面的例子，我们想增加一个元素5给元组，实际上就是创建了一个新的元组，然后把原来两个元组的值依次填充进去。\n而对于列表来说，由于其是动态的，我们只需简单地在列表末尾，加入对应元素就可以了。如下操作后，会修改原来列表中的元素，而不会创建新的列表。\ntup = (1, 2, 3, 4)\rnew_tup = tup + (5, ) # 创建新的元组new_tup，并依次填充原元组的值\rnew _tup\r(1, 2, 3, 4, 5)\rl = [1, 2, 3, 4]\rl.append(5) # 添加元素5到原列表的末尾\rl\r[1, 2, 3, 4, 5] 通过上面的例子，相信你肯定掌握了列表和元组的基本概念。接下来我们来看一些列表和元组的基本操作和注意事项。\n首先，和其他语言不同，Python中的列表和元组都支持负数索引，-1表示最后一个元素，-2表示倒数第二个元素，以此类推。\nl = [1, 2, 3, 4]\rl[-1]\r4\rtup = (1, 2, 3, 4)\rtup[-1]\r4 除了基本的初始化，索引外，列表和元组都支持切片操作：\nl = [1, 2, 3, 4]\rl[1:3] # 返回列表中索引从1到2的子列表\r[2, 3]\rtup = (1, 2, 3, 4)\rtup[1:3] # 返回元组中索引从1到2的子元组\r(2, 3) 另外，列表和元组都可以随意嵌套：\nl = [[1, 2, 3], [4, 5]] # 列表的每一个元素也是一个列表\rtup = ((1, 2, 3), (4, 5, 6)) # 元组的每一个元素也是一个元组 当然，两者也可以通过list()和tuple()函数相互转换：\nlist((1, 2, 3))\r[1, 2, 3]\rtuple([1, 2, 3])\r(1, 2, 3) 最后，我们来看一些列表和元组常用的内置函数：\nl = [3, 2, 3, 7, 8, 1]\rl.count(3) 2\rl.index(7)\r3\rl.reverse()\rl\r[1, 8, 7, 3, 2, 3]\rl.sort()\rl\r[1, 2, 3, 3, 7, 8]\rtup = (3, 2, 3, 7, 8, 1)\rtup.count(3)\r2\rtup.index(7)\r3\rlist(reversed(tup))\r[1, 8, 7, 3, 2, 3]\rsorted(tup)\r[1, 2, 3, 3, 7, 8] 这里我简单解释一下这几个函数的含义。\ncount(item)表示统计列表/元组中item出现的次数。 index(item)表示返回列表/元组中item第一次出现的索引。 list.reverse()和list.sort()分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。 reversed()和sorted()同样表示对列表/元组进行倒转和排序，reversed()返回一个倒转后的迭代器（上文例子使用list()函数再将其转换为列表）；sorted()返回排好序的新列表。 列表和元组存储方式的差异 link前面说了，列表和元组最重要的区别就是，列表是动态的、可变的，而元组是静态的、不可变的。这样的差异，势必会影响两者存储方式。我们可以来看下面的例子：\nl = [1, 2, 3]\rl.__sizeof__()\r64\rtup = (1, 2, 3)\rtup.__sizeof__()\r48 你可以看到，对列表和元组，我们放置了相同的元素，但是元组的存储空间，却比列表要少16字节。这是为什么呢？\n事实上，由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于int型，8字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。\nl = []\rl.__sizeof__() // 空列表的存储空间为40字节\r40\rl.append(1)\rl.__sizeof__() 72 // 加入了元素1之后，列表为其分配了可以存储4个元素的空间 (72 - 40)/8 = 4\rl.append(2) l.__sizeof__()\r72 // 由于之前分配了空间，所以加入元素2，列表空间不变\rl.append(3)\rl.__sizeof__() 72 // 同上\rl.append(4)\rl.__sizeof__() 72 // 同上\rl.append(5)\rl.__sizeof__() 104 // 加入元素5之后，列表的空间不足，所以又额外分配了可以存储4个元素的空间 上面的例子，大概描述了列表空间分配的过程。我们可以看到，为了减小每次增加/删减操作时空间分配的开销，Python每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加/删除的时间复杂度均为O(1)。\n但是对于元组，情况就不同了。元组长度大小固定，元素不可变，所以存储空间固定。\n看了前面的分析，你也许会觉得，这样的差异可以忽略不计。但是想象一下，如果列表和元组存储元素的个数是一亿，十亿甚至更大数量级时，你还能忽略这样的差异吗？\n列表和元组的性能 link通过学习列表和元组存储方式的差异，我们可以得出结论：元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。\n另外，Python会在后台，对静态数据做一些资源缓存（resource caching）。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。\n但是对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。\n下面的例子，是计算初始化一个相同元素的列表和元组分别所需的时间。我们可以看到，元组的初始化速度，要比列表快5倍。\npython3 -m timeit 'x=(1,2,3,4,5,6)'\r20000000 loops, best of 5: 9.97 nsec per loop\rpython3 -m timeit 'x=[1,2,3,4,5,6]'\r5000000 loops, best of 5: 50.1 nsec per loop 但如果是索引操作的话，两者的速度差别非常小，几乎可以忽略不计。\npython3 -m timeit -s 'x=[1,2,3,4,5,6]' 'y=x[3]'\r10000000 loops, best of 5: 22.2 nsec per loop\rpython3 -m timeit -s 'x=(1,2,3,4,5,6)' 'y=x[3]'\r10000000 loops, best of 5: 21.9 nsec per loop 当然，如果你想要增加、删减或者改变元素，那么列表显然更优。原因你现在肯定知道了，那就是对于元组，你必须得通过新建一个元组来完成。\n列表和元组的使用场景 link那么列表和元组到底用哪一个呢？根据上面所说的特性，我们具体情况具体分析。\n1. 如果存储的数据和数量不变，比如你有一个函数，需要返回的是一个地点的经纬度，然后直接传给前端渲染，那么肯定选用元组更合适。\ndef get_location():\r..... return (longitude, latitude) 2. 如果存储的数据或数量是可变的，比如社交平台上的一个日志功能，是统计一个用户在一周之内看了哪些用户的帖子，那么则用列表更合适。\nviewer_owner_id_list = [] # 里面的每个元素记录了这个viewer一周内看过的所有owner的id\rrecords = queryDB(viewer_id) # 索引数据库，拿到某个viewer一周内的日志\rfor record in records:\rviewer_owner_id_list.append(record.id) 总结 link关于列表和元组，我们今天聊了很多，最后一起总结一下你必须掌握的内容。\n总的来说，列表和元组都是有序的，可以存储任意数据类型的集合，区别主要在于下面这两点。\n列表是动态的，长度可变，可以随意的增加、删减或改变元素。列表的存储空间略大于元组，性能略逊于元组。 元组是静态的，长度大小固定，不可以对元素进行增加、删减或者改变操作。元组相对于列表更加轻量级，性能稍优。 思考题 link1. 想创建一个空的列表，我们可以用下面的A、B两种方式，请问它们在效率上有什么区别吗？我们应该优先考虑使用哪种呢？可以说说你的理由。\n# 创建空列表\r# option A\rempty_list = list()\r# option B\rempty_list = [] 2. 你在平时的学习工作中，是在什么场景下使用列表或者元组呢？欢迎留言和我分享。\n"
            }
        );
    index.add(
            {
                id:  6 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/04---%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97\/",
                title: "04-字典、集合，你真的了解吗？",
                description: "你好，我是景霄。\n前面的课程，我们学习了Python中的列表和元组，了解了他们的基本操作和性能比较。这节课，我们再来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在Python被广泛使用，并且性能进行了高度优化，其重要性不言而喻。\n字典和集合基础 link那究竟什么是字典，什么是集合呢？字典是一系列由键（key）和值（value）配对组成的元素的集合，在Python3.7+，字典被确定为有序（注意：在3.6中，字典有序是一个implementation detail，在3.7才正式成为语言特性，因此3.6中无法100%确保其有序性），而3.6之前是无序的，其长度大小可变，元素可以任意地删减和改变。\n相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。\n而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。\n首先我们来看字典和集合的创建，通常有下面这几种方式：\nd1 = {'name': 'jason', 'age': 20, 'gender': 'male'}\rd2 = dict({'name': 'jason', 'age': 20, 'gender': 'male'})\rd3 = dict([('name', 'jason'), ('age', 20), ('gender', 'male')])\rd4 = dict(name='jason', age=20, gender='male') d1 == d2 == d3 ==d4\rTrue\rs1 = {1, 2, 3}\rs2 = set([1, 2, 3])\rs1 == s2\rTrue 这里注意，Python中字典和集合，无论是键还是值，都可以是混合类型。比如下面这个例子，我创建了一个元素为1，'hello'，5.0的集合：\ns = {1, 'hello', 5.0} 再来看元素访问的问题。字典访问可以直接索引键，如果不存在，就会抛出异常：\n",
                content: "你好，我是景霄。\n前面的课程，我们学习了Python中的列表和元组，了解了他们的基本操作和性能比较。这节课，我们再来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在Python被广泛使用，并且性能进行了高度优化，其重要性不言而喻。\n字典和集合基础 link那究竟什么是字典，什么是集合呢？字典是一系列由键（key）和值（value）配对组成的元素的集合，在Python3.7+，字典被确定为有序（注意：在3.6中，字典有序是一个implementation detail，在3.7才正式成为语言特性，因此3.6中无法100%确保其有序性），而3.6之前是无序的，其长度大小可变，元素可以任意地删减和改变。\n相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。\n而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。\n首先我们来看字典和集合的创建，通常有下面这几种方式：\nd1 = {'name': 'jason', 'age': 20, 'gender': 'male'}\rd2 = dict({'name': 'jason', 'age': 20, 'gender': 'male'})\rd3 = dict([('name', 'jason'), ('age', 20), ('gender', 'male')])\rd4 = dict(name='jason', age=20, gender='male') d1 == d2 == d3 ==d4\rTrue\rs1 = {1, 2, 3}\rs2 = set([1, 2, 3])\rs1 == s2\rTrue 这里注意，Python中字典和集合，无论是键还是值，都可以是混合类型。比如下面这个例子，我创建了一个元素为1，'hello'，5.0的集合：\ns = {1, 'hello', 5.0} 再来看元素访问的问题。字典访问可以直接索引键，如果不存在，就会抛出异常：\nd = {'name': 'jason', 'age': 20}\rd['name']\r'jason'\rd['location']\rTraceback (most recent call last):\rFile \"\", line 1, in KeyError: 'location' 也可以使用get(key, default)函数来进行索引。如果键不存在，调用get()函数可以返回一个默认值。比如下面这个示例，返回了'null'。\nd = {'name': 'jason', 'age': 20}\rd.get('name')\r'jason'\rd.get('location', 'null')\r'null' 说完了字典的访问，我们再来看集合。\n首先我要强调的是，集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样。所以，下面这样的操作是错误的，Python会抛出异常：\ns = {1, 2, 3}\rs[0]\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: 'set' object does not support indexing 想要判断一个元素在不在字典或集合内，我们可以用value in dict/set 来判断。\ns = {1, 2, 3}\r1 in s\rTrue\r10 in s\rFalse\rd = {'name': 'jason', 'age': 20}\r'name' in d\rTrue\r'location' in d\rFalse 当然，除了创建和访问，字典和集合也同样支持增加、删除、更新等操作。\nd = {'name': 'jason', 'age': 20}\rd['gender'] = 'male' # 增加元素对'gender': 'male'\rd['dob'] = '1999-02-01' # 增加元素对'dob': '1999-02-01'\rd\r{'name': 'jason', 'age': 20, 'gender': 'male', 'dob': '1999-02-01'}\rd['dob'] = '1998-01-01' # 更新键'dob'对应的值 d.pop('dob') # 删除键为'dob'的元素对\r'1998-01-01'\rd\r{'name': 'jason', 'age': 20, 'gender': 'male'}\rs = {1, 2, 3}\rs.add(4) # 增加元素4到集合\rs\r{1, 2, 3, 4}\rs.remove(4) # 从集合中删除元素4\rs\r{1, 2, 3} 不过要注意，集合的pop()操作是删除集合中最后一个元素，可是集合本身是无序的，你无法知道会删除哪个元素，因此这个操作得谨慎使用。\n实际应用中，很多情况下，我们需要对字典或集合进行排序，比如，取出值最大的50对。\n对于字典，我们通常会根据键或值，进行升序或降序排序：\nd = {'b': 1, 'a': 2, 'c': 10}\rd_sorted_by_key = sorted(d.items(), key=lambda x: x[0]) # 根据字典键的升序排序\rd_sorted_by_value = sorted(d.items(), key=lambda x: x[1]) # 根据字典值的升序排序\rd_sorted_by_key\r[('a', 2), ('b', 1), ('c', 10)]\rd_sorted_by_value\r[('b', 1), ('a', 2), ('c', 10)] 这里返回了一个列表。列表中的每个元素，是由原字典的键和值组成的元组。\n而对于集合，其排序和前面讲过的列表、元组很类似，直接调用sorted(set)即可，结果会返回一个排好序的列表。\ns = {3, 4, 2, 1}\rsorted(s) # 对集合的元素进行升序排序\r[1, 2, 3, 4] 字典和集合性能 link文章开头我就说到了，字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作。那接下来，我们就来看看，它们在具体场景下的性能表现，以及与列表等其他数据结构的对比。\n比如电商企业的后台，存储了每件产品的ID、名称和价格。现在的需求是，给定某件商品的ID，我们要找出其价格。\n如果我们用列表来存储这些数据结构，并进行查找，相应的代码如下：\ndef find_product_price(products, product_id):\rfor id, price in products:\rif id == product_id:\rreturn price\rreturn None products = [\r(143121312, 100), (432314553, 30),\r(32421912367, 150) ]\rprint('The price of product 432314553 is {}'.format(find_product_price(products, 432314553)))\r# 输出\rThe price of product 432314553 is 30 假设列表有n个元素，而查找的过程要遍历列表，那么时间复杂度就为O(n)。即使我们先对列表进行排序，然后使用二分查找，也会需要O(logn)的时间复杂度，更何况，列表的排序还需要O(nlogn)的时间。\n但如果我们用字典来存储这些数据，那么查找就会非常便捷高效，只需O(1)的时间复杂度就可以完成。原因也很简单，刚刚提到过的，字典的内部组成是一张哈希表，你可以直接通过键的哈希值，找到其对应的值。\nproducts = {\r143121312: 100,\r432314553: 30,\r32421912367: 150\r}\rprint('The price of product 432314553 is {}'.format(products[432314553])) # 输出\rThe price of product 432314553 is 30 类似的，现在需求变成，要找出这些商品有多少种不同的价格。我们还用同样的方法来比较一下。\n如果还是选择使用列表，对应的代码如下，其中，A和B是两层循环。同样假设原始列表有n个元素，那么，在最差情况下，需要O(n^2)的时间复杂度。\n# list version\rdef find_unique_price_using_list(products):\runique_price_list = []\rfor _, price in products: # A\rif price not in unique_price_list: #B\runique_price_list.append(price)\rreturn len(unique_price_list)\rproducts = [\r(143121312, 100), (432314553, 30),\r(32421912367, 150),\r(937153201, 30)\r]\rprint('number of unique price is: {}'.format(find_unique_price_using_list(products)))\r# 输出\rnumber of unique price is: 3 但如果我们选择使用集合这个数据结构，由于集合是高度优化的哈希表，里面元素不能重复，并且其添加和查找操作只需O(1)的复杂度，那么，总的时间复杂度就只有O(n)。\n# set version\rdef find_unique_price_using_set(products):\runique_price_set = set()\rfor _, price in products:\runique_price_set.add(price)\rreturn len(unique_price_set) products = [\r(143121312, 100), (432314553, 30),\r(32421912367, 150),\r(937153201, 30)\r]\rprint('number of unique price is: {}'.format(find_unique_price_using_set(products)))\r# 输出\rnumber of unique price is: 3 可能你对这些时间复杂度没有直观的认识，我可以举一个实际工作场景中的例子，让你来感受一下。\n下面的代码，初始化了含有100,000个元素的产品，并分别计算了使用列表和集合来统计产品价格数量的运行时间：\nimport time\rid = [x for x in range(0, 100000)]\rprice = [x for x in range(200000, 300000)]\rproducts = list(zip(id, price))\r# 计算列表版本的时间\rstart_using_list = time.perf_counter()\rfind_unique_price_using_list(products)\rend_using_list = time.perf_counter()\rprint(\"time elapse using list: {}\".format(end_using_list - start_using_list))\r## 输出\rtime elapse using list: 41.61519479751587\r# 计算集合版本的时间\rstart_using_set = time.perf_counter()\rfind_unique_price_using_set(products)\rend_using_set = time.perf_counter()\rprint(\"time elapse using set: {}\".format(end_using_set - start_using_set))\r# 输出\rtime elapse using set: 0.008238077163696289 你可以看到，仅仅十万的数据量，两者的速度差异就如此之大。事实上，大型企业的后台数据往往有上亿乃至十亿数量级，如果使用了不合适的数据结构，就很容易造成服务器的崩溃，不但影响用户体验，并且会给公司带来巨大的财产损失。\n字典和集合的工作原理 link我们通过举例以及与列表的对比，看到了字典和集合操作的高效性。不过，字典和集合为什么能够如此高效，特别是查找、插入和删除操作？\n这当然和字典、集合内部的数据结构密不可分。不同于其他数据结构，字典和集合的内部结构都是一张哈希表。\n对于字典而言，这张表存储了哈希值（hash）、键和值这3个元素。 而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。 我们来看，老版本Python的哈希表结构如下所示：\n--+-------------------------------+\r| 哈希值(hash) 键(key) 值(value)\r--+-------------------------------+\r0 | hash0 key0 value0\r--+-------------------------------+\r1 | hash1 key1 value1\r--+-------------------------------+\r2 | hash2 key2 value2\r--+-------------------------------+\r. | ...\r__+_______________________________+ 不难想象，随着哈希表的扩张，它会变得越来越稀疏。举个例子，比如我有这样一个字典：\n{'name': 'mike', 'dob': '1999-01-01', 'gender': 'male'} 那么它会存储为类似下面的形式：\nentries = [\r['--', '--', '--']\r[-230273521, 'dob', '1999-01-01'],\r['--', '--', '--'],\r['--', '--', '--'],\r[1231236123, 'name', 'mike'],\r['--', '--', '--'],\r[9371539127, 'gender', 'male']\r] 这样的设计结构显然非常浪费存储空间。为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是下面这样新的结构：\nIndices\r----------------------------------------------------\rNone | index | None | None | index | None | index ...\r----------------------------------------------------\rEntries\r--------------------\rhash0 key0 value0\r---------------------\rhash1 key1 value1\r---------------------\rhash2 key2 value2\r---------------------\r...\r--------------------- 那么，刚刚的这个例子，在新的哈希表结构下的存储形式，就会变成下面这样：\nindices = [None, 1, None, None, 0, None, 2]\rentries = [\r[1231236123, 'name', 'mike'],\r[-230273521, 'dob', '1999-01-01'],\r[9371539127, 'gender', 'male']\r] 我们可以很清晰地看到，空间利用率得到很大的提高。\n清楚了具体的设计结构，我们接着来看这几个操作的工作原理。\n插入操作 link每次向字典或集合插入一个元素时，Python会首先计算键的哈希值（hash(key)），再和 mask = PyDicMinSize - 1做与操作，计算这个元素应该插入哈希表的位置index = hash(key) \u0026 mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。\n而如果此位置已被占用，Python便会比较两个元素的哈希值和键是否相等。\n若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。 若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两个元素的键不相等，但是哈希值相等。这种情况下，Python便会继续寻找表中空余的位置，直到找到位置为止。 值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。当然，Python内部对此进行了优化（这一点无需深入了解，你有兴趣可以查看源码，我就不再赘述），让这个步骤更加高效。\n查找操作 link和前面的插入操作类似，Python会根据哈希值，找到其应该处于的位置；然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。\n删除操作 link对于删除操作，Python会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。\n不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有1/3的剩余空间。随着元素的不停插入，当剩余空间小于1/3时，Python会重新获取更大的内存空间，扩充哈希表。不过，这种情况下，表内所有的元素位置都会被重新排放。\n虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为O(1)。\n总结 link这节课，我们一起学习了字典和集合的基本操作，并对它们的高性能和内部存储结构进行了讲解。\n字典在Python3.7+是有序的数据结构，而集合是无序的，其内部的哈希表存储结构，保证了其查找、插入、删除操作的高效性。所以，字典和集合通常运用在对元素的高效查找、去重等场景。\n思考题 link1. 下面初始化字典的方式，哪一种更高效？\n# Option A\rd = {'name': 'jason', 'age': 20, 'gender': 'male'}\r# Option B\rd = dict({'name': 'jason', 'age': 20, 'gender': 'male'}) 2. 字典的键可以是一个列表吗？下面这段代码中，字典的初始化是否正确呢？如果不正确，可以说出你的原因吗？\nd = {'name': 'jason', ['education']: ['Tsinghua University', 'Stanford University']} 欢迎留言和我分享，也欢迎你把这篇文章分享给你的同事、朋友。\n思考题 2: 用列表作为 Key 在这里是不被允许的，因为列表是一个动态变化的数据结构，字典当中的 key 要求是不可变的，原因也很好理解，key 首先是不重复的，如果 Key 是可以变化的话，那么随着 Key 的变化，这里就有可能就会有重复的 Key，那么这就和字典的定义相违背；如果把这里的列表换成之前我们讲过的元组是可以的，因为元组不可变\n第一种数据结构，如何可以o(1)的查找一个key？ 没有索引啊 这篇文章感觉写的不好，例子没有讲透 稀疏一定浪费吗，里面没有值的话能占用多少空间 我理解耗费空间的应该是k v的存储吧2019-05-29Hoo-Ah 👍（12） 💬（7）1. 直接使用大括号更高效，避免了使用类生成实例其他不必要的操作； 2. 列表不可以作为key，因为列表是可变类型，可变类型不可hash。 问题：为什么在旧哈希表中元素会越来越稀？2019-05-17力维 👍（10） 💬（3）内容挺好的，但好像有个小错误：关于查找价格的例子，列表查找并没有用到双重循环吧？A是循环，B只是判断语句，不构成循环。2019-11-14Jon徐 👍（8） 💬（1）list indices就是哈希表，None表示该位置目前尚未被占用，索引的值即是在list entries中存储dict键值和哈希值的下标。 作业中初始化dict，key不能使用可变类型吧，value可以使任意对象。2019-05-17天凉好个秋 👍（7） 💬（2）不难想象，随着哈希表的扩张，它会变得越来越稀疏。 后面例子中解释的原因没看懂，能详细说说吗？2019-05-17farFlight 👍（7） 💬（1）老师好，在王争老师的数据结构课程中提到哈希表常与链表一起使用，譬如用来解决哈希冲突。请问python底层对字典和集合的实现是否也是这样的呢？2019-05-17鱼腐 👍（4） 💬（1）Indices:none | one | none | index | none | index 是什么意思？能补充讲解下吗2019-05-17Geek_cj8r3q 👍（3） 💬（2）这些都是线程安全的么 列表 元组 集合 字典2019-10-30张胜坡 👍（1） 💬（2）d = {'name': 'jason', 'age': 20} d.get('name') 'jason' d.get('location', 'null')'null'\n其中d.get('location', 'null')，这里的写法是什么意思2020-02-13Redevil 👍（1） 💬（1）set version 的查找unique price的product的代码，不是O(1)，是O(n)吧。 至少要遍历N个元素啊。2019-05-17夜行 👍（1） 💬（1）旧的字典没有索引吗2019-05-17daowuli_chihai 👍（0） 💬（2）你好，集合的pop()我测试，好像每次都删除 集合第一个元素，下面 Microsoft Windows [版本 6.1.7601] 版权所有 (c) 2009 Microsoft Corporation。保留所有权利。\nC:\\Users\\Administrator\u003epython Python 3.8.0 (tags/v3.8.0:fa919fd, Oct 14 2019, 19:21:23) [MSC v.1916 32 bit (I tel)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e set1 = {1,2,3,4,5} \u003e\u003e\u003e set1.pop() 1 \u003e\u003e\u003e set1 {2, 3, 4, 5} \u003e\u003e\u003e set1.pop() 2 \u003e\u003e\u003e set1 {3, 4, 5} \u003e\u003e\u003e\n"
            }
        );
    index.add(
            {
                id:  7 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/05---%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2\/",
                title: "05-深入浅出字符串",
                description: "你好，我是景霄。\nPython的程序中充满了字符串（string），在平常阅读代码时也屡见不鲜。字符串同样是Python中很常见的一种数据类型，比如日志的打印、程序中函数的注释、数据库的访问、变量的基本操作等等，都用到了字符串。\n当然，我相信你本身对字符串已经有所了解。今天这节课，我主要带你回顾一下字符串的常用操作，并对其中的一些小tricks详细地加以解释。\n字符串基础 link什么是字符串呢？字符串是由独立字符组成的一个序列，通常包含在单引号（''）双引号（\"\"）或者三引号之中（''' '''或\"\"\" \"\"\"，两者一样），比如下面几种写法。\nname = 'jason'\rcity = 'beijing'\rtext = \"welcome to jike shijian\" 这里定义了name、city和text三个变量，都是字符串类型。我们知道，Python中单引号、双引号和三引号的字符串是一模一样的，没有区别，比如下面这个例子中的s1、s2、s3完全一样。\ns1 = 'hello'\rs2 = \"hello\"\rs3 = \"\"\"hello\"\"\"\rs1 == s2 == s3\rTrue Python同时支持这三种表达方式，很重要的一个原因就是，这样方便你在字符串中，内嵌带引号的字符串。比如：\n\"I'm a student\" Python的三引号字符串，则主要应用于多行字符串的情境，比如函数的注释等等。\ndef calculate_similarity(item1, item2):\r\"\"\"\rCalculate similarity between two items\rArgs:\ritem1: 1st item\ritem2: 2nd item\rReturns:\rsimilarity score between item1 and item2\r\"\"\" 同时，Python也支持转义字符。所谓的转义字符，就是用反斜杠开头的字符串，来表示一些特定意义的字符。我把常见的的转义字符，总结成了下面这张表格。\n",
                content: "你好，我是景霄。\nPython的程序中充满了字符串（string），在平常阅读代码时也屡见不鲜。字符串同样是Python中很常见的一种数据类型，比如日志的打印、程序中函数的注释、数据库的访问、变量的基本操作等等，都用到了字符串。\n当然，我相信你本身对字符串已经有所了解。今天这节课，我主要带你回顾一下字符串的常用操作，并对其中的一些小tricks详细地加以解释。\n字符串基础 link什么是字符串呢？字符串是由独立字符组成的一个序列，通常包含在单引号（''）双引号（\"\"）或者三引号之中（''' '''或\"\"\" \"\"\"，两者一样），比如下面几种写法。\nname = 'jason'\rcity = 'beijing'\rtext = \"welcome to jike shijian\" 这里定义了name、city和text三个变量，都是字符串类型。我们知道，Python中单引号、双引号和三引号的字符串是一模一样的，没有区别，比如下面这个例子中的s1、s2、s3完全一样。\ns1 = 'hello'\rs2 = \"hello\"\rs3 = \"\"\"hello\"\"\"\rs1 == s2 == s3\rTrue Python同时支持这三种表达方式，很重要的一个原因就是，这样方便你在字符串中，内嵌带引号的字符串。比如：\n\"I'm a student\" Python的三引号字符串，则主要应用于多行字符串的情境，比如函数的注释等等。\ndef calculate_similarity(item1, item2):\r\"\"\"\rCalculate similarity between two items\rArgs:\ritem1: 1st item\ritem2: 2nd item\rReturns:\rsimilarity score between item1 and item2\r\"\"\" 同时，Python也支持转义字符。所谓的转义字符，就是用反斜杠开头的字符串，来表示一些特定意义的字符。我把常见的的转义字符，总结成了下面这张表格。\n为了方便你理解，我举一个例子来说明。\ns = 'a\\nb\\tc'\rprint(s)\ra\rb\tc 这段代码中的'\\n'，表示一个字符——换行符；'\\t'也表示一个字符——横向制表符。所以，最后打印出来的输出，就是字符a，换行，字符b，然后制表符，最后打印字符c。不过要注意，虽然最后打印的输出横跨了两行，但是整个字符串s仍然只有5个元素。\nlen(s)\r5 在转义字符的应用中，最常见的就是换行符'\\n'的使用。比如文件读取，如果我们一行行地读取，那么每一行字符串的末尾，都会包含换行符'\\n'。而最后做数据处理时，我们往往会丢掉每一行的换行符。\n字符串的常用操作 link讲完了字符串的基本原理，下面我们一起来看看字符串的常用操作。你可以把字符串想象成一个由单个字符组成的数组，所以，Python的字符串同样支持索引，切片和遍历等等操作。\nname = 'jason'\rname[0]\r'j'\rname[1:3]\r'as' 和其他数据结构，如列表、元组一样，字符串的索引同样从0开始，index=0表示第一个元素（字符），[index:index+2]则表示第index个元素到index+1个元素组成的子字符串。\n遍历字符串同样很简单，相当于遍历字符串中的每个字符。\nfor char in name:\rprint(char) j\ra\rs\ro\rn 特别要注意，Python的字符串是不可变的（immutable）。因此，用下面的操作，来改变一个字符串内部的字符是错误的，不允许的。\ns = 'hello'\rs[0] = 'H'\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: 'str' object does not support item assignment Python中字符串的改变，通常只能通过创建新的字符串来完成。比如上述例子中，想把'hello'的第一个字符'h'，改为大写的'H'，我们可以采用下面的做法：\ns = 'H' + s[1:]\rs = s.replace('h', 'H') 第一种方法，是直接用大写的'H'，通过加号'+'操作符，与原字符串切片操作的子字符串拼接而成新的字符串。 第二种方法，是直接扫描原字符串，把小写的'h'替换成大写的'H'，得到新的字符串。 你可能了解到，在其他语言中，如Java，有可变的字符串类型，比如StringBuilder，每次添加、改变或删除字符（串），无需创建新的字符串，时间复杂度仅为O(1)。这样就大大提高了程序的运行效率。\n但可惜的是，Python中并没有相关的数据类型，我们还是得老老实实创建新的字符串。因此，每次想要改变字符串，往往需要O(n)的时间复杂度，其中，n为新字符串的长度。\n你可能注意到了，上述例子的说明中，我用的是“往往”、“通常”这样的字眼，并没有说“一定”。这是为什么呢？显然，随着版本的更新，Python也越来越聪明，性能优化得越来越好了。\n这里，我着重讲解一下，使用加法操作符'+='的字符串拼接方法。因为它是一个例外，打破了字符串不可变的特性。\n操作方法如下所示：\nstr1 += str2 # 表示str1 = str1 + str2 我们来看下面这个例子：\ns = ''\rfor n in range(0, 100000):\rs += str(n) 你觉得这个例子的时间复杂度是多少呢？\n每次循环，似乎都得创建一个新的字符串；而每次创建一个新的字符串，都需要O(n)的时间复杂度。因此，总的时间复杂度就为O(1) + O(2) + … + O(n) = O(n^2)。这样到底对不对呢？\n乍一看，这样分析确实很有道理，但是必须说明，这个结论只适用于老版本的Python了。自从Python2.5开始，每次处理字符串的拼接操作时（str1 += str2），Python首先会检测str1还有没有其他的引用。如果没有的话，就会尝试原地扩充字符串buffer的大小，而不是重新分配一块内存来创建新的字符串并拷贝。这样的话，上述例子中的时间复杂度就仅为O(n)了。\n因此，以后你在写程序遇到字符串拼接时，如果使用’+=‘更方便，就放心地去用吧，不用过分担心效率问题了。\n另外，对于字符串拼接问题，除了使用加法操作符，我们还可以使用字符串内置的join函数。string.join(iterable)，表示把每个元素都按照指定的格式连接起来。\nl = []\rfor n in range(0, 100000):\rl.append(str(n))\rl = ' '.join(l) 由于列表的append操作是O(1)复杂度，字符串同理。因此，这个含有for循环例子的时间复杂度为n*O(1)=O(n)。\n接下来，我们看一下字符串的分割函数split()。string.split(separator)，表示把字符串按照separator分割成子字符串，并返回一个分割后子字符串组合的列表。它常常应用于对数据的解析处理，比如我们读取了某个文件的路径，想要调用数据库的API，去读取对应的数据，我们通常会写成下面这样：\ndef query_data(namespace, table):\r\"\"\"\rgiven namespace and table, query database to get corresponding\rdata \"\"\"\rpath = 'hive://ads/training_table'\rnamespace = path.split('//')[1].split('/')[0] # 返回'ads'\rtable = path.split('//')[1].split('/')[1] # 返回 'training_table'\rdata = query_data(namespace, table) 此外，常见的函数还有：\nstring.strip(str)，表示去掉首尾的str字符串； string.lstrip(str)，表示只去掉开头的str字符串； string.rstrip(str)，表示只去掉尾部的str字符串。 这些在数据的解析处理中同样很常见。比如很多时候，从文件读进来的字符串中，开头和结尾都含有空字符，我们需要去掉它们，就可以用strip()函数：\ns = ' my name is jason '\rs.strip()\r'my name is jason' 当然，Python中字符串还有很多常用操作，比如，string.find(sub, start, end)，表示从start到end查找字符串中子字符串sub的位置等等。这里，我只强调了最常用并且容易出错的几个函数，其他内容你可以自行查找相应的文档、范例加以了解，我就不一一赘述了。\n字符串的格式化 link最后，我们一起来看看字符串的格式化。什么是字符串的格式化呢？\n通常，我们使用一个字符串作为模板，模板中会有格式符。这些格式符为后续真实值预留位置，以呈现出真实值应该呈现的格式。字符串的格式化，通常会用在程序的输出、logging等场景。\n举一个常见的例子。比如我们有一个任务，给定一个用户的userid，要去数据库中查询该用户的一些信息，并返回。而如果数据库中没有此人的信息，我们通常会记录下来，这样有利于往后的日志分析，或者是线上bug的调试等等。\n我们通常会用下面的方法来表示：\nprint('no data available for person with id: {}, name: {}'.format(id, name)) 其中的string.format()，就是所谓的格式化函数；而大括号{}就是所谓的格式符，用来为后面的真实值——变量name预留位置。如果id = '123'、name='jason'，那么输出便是：\n'no data available for person with id: 123, name: jason' 这样看来，是不是非常简单呢？\n不过要注意，string.format()是最新的字符串格式函数与规范。自然，我们还有其他的表示方法，比如在Python之前版本中，字符串格式化通常用%来表示，那么上述的例子，就可以写成下面这样：\nprint('no data available for person with id: %s, name: %s' % (id, name)) 其中%s表示字符串型，%d表示整型等等，这些属于常识，你应该都了解。\n当然，现在你写程序时，我还是推荐使用format函数，毕竟这是最新规范，也是官方文档推荐的规范。\n也许有人会问，为什么非要使用格式化函数，上述例子用字符串的拼接不也能完成吗？没错，在很多情况下，字符串拼接确实能满足格式化函数的需求。但是使用格式化函数，更加清晰、易读，并且更加规范，不易出错。\n总结 link这节课，我们主要学习了Python字符串的一些基本知识和常用操作，并且结合具体的例子与场景加以说明，特别需要注意下面几点。\nPython中字符串使用单引号、双引号或三引号表示，三者意义相同，并没有什么区别。其中，三引号的字符串通常用在多行字符串的场景。 Python中字符串是不可变的（前面所讲的新版本Python中拼接操作’+=‘是个例外）。因此，随意改变字符串中字符的值，是不被允许的。 Python新版本（2.5+）中，字符串的拼接变得比以前高效了许多，你可以放心使用。 Python中字符串的格式化（string.format）常常用在输出、日志的记录等场景。 思考题 link最后，给你留一道思考题。在新版本的Python（2.5+）中，下面的两个字符串拼接操作，你觉得哪个更优呢？欢迎留言和我分享你的观点，也欢迎你把这篇文章分享给你的同事、朋友。\ns = ''\rfor n in range(0, 100000):\rs += str(n) l = []\rfor n in range(0, 100000):\rl.append(str(n))\rs = ' '.join(l) 测试 1000 条数据，方式二 linkimport time start_time = time.perf_counter() s = [] for n in range(0, 1000): s.append(str(n)) ''.join(s) end_time = time.perf_counter() print('Time elapse: {}'.format(end_time - start_time)) 返回结果: Time elapse: 0.0004917513579130173\n测试 1000 条数据，方式三 linkimport time start_time = time.perf_counter() s = ''.join(map(str, range(0, 1000))) end_time = time.perf_counter() print('Time elapse: {}'.format(end_time - start_time)) 返回结果：Time elapse: 0.00021015387028455734\n分别测试一百万和一千万条数据，结果如下： 100万: 方式一：Time elapse: 0.3384760869666934 方式二：Time elapse: 0.34538754168897867 方式三：Time elapse: 0.2445415174588561\n1000万： 方式一：Time elapse: 4.24716751743108 方式二：Time elapse: 3.1754934675991535 方式三：Time elapse: 2.2939002392813563\n综上，方式三性能最优，其次是在超过1000万条数据以上时，方式二优于方式一，相反，方式一优于方式二。2019-05-20LJK 👍（59） 💬（5）最新的f\"\"用法了解一下？2019-05-20ssikiki 👍（25） 💬（8）使用加法操作符'+='的字符串拼接方法。因为它是一个例外 … 可是 x = 'a' id(x) # 4345659208 x += 'b' id(x) # 4376614424 做完+=操作后， x的内存地址变了， 说明新生成了字符串，请问老师这为什么说是例外？2019-05-21\n"
            }
        );
    index.add(
            {
                id:  8 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/06---python-%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA\/",
                title: "06 - Python \"黑箱\"：输入与输出",
                description: "你好，我是景霄。\n世纪之交的论坛上曾有一句流行语：在互联网上，没人知道你是一条狗。互联网刚刚兴起时，一根网线链接到你家，信息通过这条高速线缆直达你的屏幕，你通过键盘飞速回应朋友的消息，信息再次通过网线飞入错综复杂的虚拟世界，再进入朋友家。抽象来看，一台台的电脑就是一个个黑箱，黑箱有了输入和输出，就拥有了图灵机运作的必要条件。\nPython 程序也是一个黑箱：通过输入流将数据送达，通过输出流将处理后的数据送出，可能 Python 解释器后面藏了一个人，还是一个史莱哲林？No one cares。\n好了废话不多说，今天我们就由浅及深讲讲 Python 的输入和输出。\n输入输出基础 link最简单直接的输入来自键盘操作，比如下面这个例子。\nname = input('your name:')\rgender = input('you are a boy?(y/n)')\r###### 输入 ######\ryour name:Jack\ryou are a boy?\rwelcome_str = 'Welcome to the matrix {prefix} {name}.'\rwelcome_dic = {\r'prefix': 'Mr.' if gender == 'y' else 'Mrs',\r'name': name\r}\rprint('authorizing...')\rprint(welcome_str.format(**welcome_dic))\r########## 输出 ##########\rauthorizing...\rWelcome to the matrix Mr. Jack. input() 函数暂停程序运行，同时等待键盘输入；直到回车被按下，函数的参数即为提示语，输入的类型永远是字符串型（str）。注意，初学者在这里很容易犯错，下面的例子我会讲到。print() 函数则接受字符串、数字、字典、列表甚至一些自定义类的输出。\n",
                content: "你好，我是景霄。\n世纪之交的论坛上曾有一句流行语：在互联网上，没人知道你是一条狗。互联网刚刚兴起时，一根网线链接到你家，信息通过这条高速线缆直达你的屏幕，你通过键盘飞速回应朋友的消息，信息再次通过网线飞入错综复杂的虚拟世界，再进入朋友家。抽象来看，一台台的电脑就是一个个黑箱，黑箱有了输入和输出，就拥有了图灵机运作的必要条件。\nPython 程序也是一个黑箱：通过输入流将数据送达，通过输出流将处理后的数据送出，可能 Python 解释器后面藏了一个人，还是一个史莱哲林？No one cares。\n好了废话不多说，今天我们就由浅及深讲讲 Python 的输入和输出。\n输入输出基础 link最简单直接的输入来自键盘操作，比如下面这个例子。\nname = input('your name:')\rgender = input('you are a boy?(y/n)')\r###### 输入 ######\ryour name:Jack\ryou are a boy?\rwelcome_str = 'Welcome to the matrix {prefix} {name}.'\rwelcome_dic = {\r'prefix': 'Mr.' if gender == 'y' else 'Mrs',\r'name': name\r}\rprint('authorizing...')\rprint(welcome_str.format(**welcome_dic))\r########## 输出 ##########\rauthorizing...\rWelcome to the matrix Mr. Jack. input() 函数暂停程序运行，同时等待键盘输入；直到回车被按下，函数的参数即为提示语，输入的类型永远是字符串型（str）。注意，初学者在这里很容易犯错，下面的例子我会讲到。print() 函数则接受字符串、数字、字典、列表甚至一些自定义类的输出。\n我们再来看下面这个例子。\na = input()\r1\rb = input()\r2\rprint('a + b = {}'.format(a + b))\r########## 输出 ##############\ra + b = 12\rprint('type of a is {}, type of b is {}'.format(type(a), type(b)))\r########## 输出 ##############\rtype of a is "
            }
        );
    index.add(
            {
                id:  9 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/07---%E4%BF%AE%E7%82%BC%E5%9F%BA%E6%9C%AC%E5%8A%9F%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF\/",
                title: "07 - 修炼基本功：条件与循环",
                description: "你好，我是景霄。\n前面几节，我们一起学习了列表、元组、字典、集合和字符串等一系列Python的基本数据类型。但是，如何把这一个个基本的数据结构类型串接起来，组成一手漂亮的代码呢？这就是我们今天所要讨论的“条件与循环”。\n我习惯把“条件与循环”，叫做编程中的基本功。为什么称它为基本功呢？因为它控制着代码的逻辑，可以说是程序的中枢系统。如果把写程序比作盖楼房，那么条件与循环就是楼房的根基，其他所有东西都是在此基础上构建而成。\n毫不夸张地说，写一手简洁易读的条件与循环代码，对提高程序整体的质量至关重要。\n条件语句 link首先，我们一起来看一下Python的条件语句，用法很简单。比如，我想要表示y=|x|这个函数，那么相应的代码便是：\n# y = |x|\rif x \u003c 0:\ry = -x\relse:\ry = x 和其他语言不一样，我们不能在条件语句中加括号，写成下面这样的格式。\nif (x \u003c 0) 但需要注意的是，在条件语句的末尾必须加上冒号（:），这是Python特定的语法规范。\n由于Python不支持switch语句，因此，当存在多个条件判断时，我们需要用else if来实现，这在Python中的表达是elif。语法如下：\nif condition_1:\rstatement_1\relif condition_2:\rstatement_2\r...\relif condition_i:\rstatement_i\relse:\rstatement_n 整个条件语句是顺序执行的，如果遇到一个条件满足，比如condition_i满足时，在执行完statement_i后，便会退出整个if、elif、else条件语句，而不会继续向下执行。这个语句在工作中很常用，比如下面的这个例子。\n实际工作中，我们经常用ID表示一个事物的属性，然后进行条件判断并且输出。比如，在integrity的工作中，通常用0、1、2分别表示一部电影的色情暴力程度。其中，0的程度最高，是red级别；1其次，是yellow级别；2代表没有质量问题，属于green。\n如果给定一个ID，要求输出某部电影的质量评级，则代码如下：\nif id == 0:\rprint('red')\relif id == 1:\rprint('yellow')\relse:\rprint('green') 不过要注意，if语句是可以单独使用的，但elif、else都必须和if成对使用。\n另外，在我们进行条件判断时， 不少人喜欢省略判断的条件，比如写成下面这样：\nif s: # s is a string\r...\rif l: # l is a list\r...\rif i: # i is an int\r...\r... 关于省略判断条件的常见用法，我大概总结了一下：\n",
                content: "你好，我是景霄。\n前面几节，我们一起学习了列表、元组、字典、集合和字符串等一系列Python的基本数据类型。但是，如何把这一个个基本的数据结构类型串接起来，组成一手漂亮的代码呢？这就是我们今天所要讨论的“条件与循环”。\n我习惯把“条件与循环”，叫做编程中的基本功。为什么称它为基本功呢？因为它控制着代码的逻辑，可以说是程序的中枢系统。如果把写程序比作盖楼房，那么条件与循环就是楼房的根基，其他所有东西都是在此基础上构建而成。\n毫不夸张地说，写一手简洁易读的条件与循环代码，对提高程序整体的质量至关重要。\n条件语句 link首先，我们一起来看一下Python的条件语句，用法很简单。比如，我想要表示y=|x|这个函数，那么相应的代码便是：\n# y = |x|\rif x \u003c 0:\ry = -x\relse:\ry = x 和其他语言不一样，我们不能在条件语句中加括号，写成下面这样的格式。\nif (x \u003c 0) 但需要注意的是，在条件语句的末尾必须加上冒号（:），这是Python特定的语法规范。\n由于Python不支持switch语句，因此，当存在多个条件判断时，我们需要用else if来实现，这在Python中的表达是elif。语法如下：\nif condition_1:\rstatement_1\relif condition_2:\rstatement_2\r...\relif condition_i:\rstatement_i\relse:\rstatement_n 整个条件语句是顺序执行的，如果遇到一个条件满足，比如condition_i满足时，在执行完statement_i后，便会退出整个if、elif、else条件语句，而不会继续向下执行。这个语句在工作中很常用，比如下面的这个例子。\n实际工作中，我们经常用ID表示一个事物的属性，然后进行条件判断并且输出。比如，在integrity的工作中，通常用0、1、2分别表示一部电影的色情暴力程度。其中，0的程度最高，是red级别；1其次，是yellow级别；2代表没有质量问题，属于green。\n如果给定一个ID，要求输出某部电影的质量评级，则代码如下：\nif id == 0:\rprint('red')\relif id == 1:\rprint('yellow')\relse:\rprint('green') 不过要注意，if语句是可以单独使用的，但elif、else都必须和if成对使用。\n另外，在我们进行条件判断时， 不少人喜欢省略判断的条件，比如写成下面这样：\nif s: # s is a string\r...\rif l: # l is a list\r...\rif i: # i is an int\r...\r... 关于省略判断条件的常见用法，我大概总结了一下：\n不过，切记，在实际写代码时，我们鼓励，除了boolean类型的数据，条件判断最好是显性的。比如，在判断一个整型数是否为0时，我们最好写出判断的条件：\nif i != 0:\r... 而不是只写出变量名：\nif i:\r... 循环语句 link讲完了条件语句，我们接着来看循环语句。所谓循环，顾名思义，本质上就是遍历集合中的元素。和其他语言一样，Python中的循环一般通过for循环和while循环实现。\n比如，我们有一个列表，需要遍历列表中的所有元素并打印输出，代码如下：\nl = [1, 2, 3, 4]\rfor item in l:\rprint(item)\r1\r2\r3\r4 你看，是不是很简单呢？\n其实，Python中的数据结构只要是可迭代的（iterable），比如列表、集合等等，那么都可以通过下面这种方式遍历：\nfor item in :\r... 这里需要单独强调一下字典。字典本身只有键是可迭代的，如果我们要遍历它的值或者是键值对，就需要通过其内置的函数values()或者items()实现。其中，values()返回字典的值的集合，items()返回键值对的集合。\nd = {'name': 'jason', 'dob': '2000-01-01', 'gender': 'male'}\rfor k in d: # 遍历字典的键\rprint(k)\rname\rdob\rgender\rfor v in d.values(): # 遍历字典的值\rprint(v)\rjason\r2000-01-01\rmale for k, v in d.items(): # 遍历字典的键值对\rprint('key: {}, value: {}'.format(k, v))\rkey: name, value: jason\rkey: dob, value: 2000-01-01\rkey: gender, value: male 看到这里你也许会问，有没有办法通过集合中的索引来遍历元素呢？当然可以，其实这种情况在实际工作中还是很常见的，甚至很多时候，我们还得根据索引来做一些条件判断。\n我们通常通过range()这个函数，拿到索引，再去遍历访问集合中的元素。比如下面的代码，遍历一个列表中的元素，当索引小于5时，打印输出：\nl = [1, 2, 3, 4, 5, 6, 7]\rfor index in range(0, len(l)):\rif index \u003c 5:\rprint(l[index]) 1\r2\r3\r4\r5 当我们同时需要索引和元素时，还有一种更简洁的方式，那就是通过Python内置的函数enumerate()。用它来遍历集合，不仅返回每个元素，并且还返回其对应的索引，这样一来，上面的例子就可以写成:\nl = [1, 2, 3, 4, 5, 6, 7]\rfor index, item in enumerate(l):\rif index \u003c 5:\rprint(item) 1\r2\r3\r4\r5 在循环语句中，我们还常常搭配continue和break一起使用。所谓continue，就是让程序跳过当前这层循环，继续执行下面的循环；而break则是指完全跳出所在的整个循环体。在循环中适当加入continue和break，往往能使程序更加简洁、易读。\n比如，给定两个字典，分别是产品名称到价格的映射，和产品名称到颜色列表的映射。我们要找出价格小于1000，并且颜色不是红色的所有产品名称和颜色的组合。如果不用continue，代码应该是下面这样的：\n# name_price: 产品名称(str)到价格(int)的映射字典\r# name_color: 产品名字(str)到颜色(list of str)的映射字典\rfor name, price in name_price.items():\rif price \u003c 1000:\rif name in name_color:\rfor color in name_color[name]:\rif color != 'red':\rprint('name: {}, color: {}'.format(name, color))\relse:\rprint('name: {}, color: {}'.format(name, 'None')) 而加入continue后，代码显然清晰了很多：\n# name_price: 产品名称(str)到价格(int)的映射字典\r# name_color: 产品名字(str)到颜色(list of str)的映射字典\rfor name, price in name_price.items():\rif price \u003e= 1000:\rcontinue\rif name not in name_color:\rprint('name: {}, color: {}'.format(name, 'None'))\rcontinue\rfor color in name_color[name]:\rif color == 'red':\rcontinue\rprint('name: {}, color: {}'.format(name, color)) 我们可以看到，按照第一个版本的写法，从开始一直到打印输出符合条件的产品名称和颜色，共有5层for或者if的嵌套；但第二个版本加入了continue后，只有3层嵌套。\n显然，如果代码中出现嵌套里还有嵌套的情况，代码便会变得非常冗余、难读，也不利于后续的调试、修改。因此，我们要尽量避免这种多层嵌套的情况。\n前面讲了for循环，对于while循环，原理也是一样的。它表示当condition满足时，一直重复循环内部的操作，直到condition不再满足，就跳出循环体。\nwhile condition:\r.... 很多时候，for循环和while循环可以互相转换，比如要遍历一个列表，我们用while循环同样可以完成：\nl = [1, 2, 3, 4]\rindex = 0\rwhile index \u003c len(l):\rprint(l[index])\rindex += 1 那么，两者的使用场景又有什么区别呢？\n通常来说，如果你只是遍历一个已知的集合，找出满足条件的元素，并进行相应的操作，那么使用for循环更加简洁。但如果你需要在满足某个条件前，不停地重复某些操作，并且没有特定的集合需要去遍历，那么一般则会使用while循环。\n比如，某个交互式问答系统，用户输入文字，系统会根据内容做出相应的回答。为了实现这个功能，我们一般会使用while循环，大致代码如下：\nwhile True:\rtry:\rtext = input('Please enter your questions, enter \"q\" to exit')\rif text == 'q':\rprint('Exit system')\rbreak\r...\r...\rprint(response)\rexcept Exception as err:\rprint('Encountered error: {}'.format(err))\rbreak 同时需要注意的是，for循环和while循环的效率问题。比如下面的while循环：\ni = 0\rwhile i \u003c 1000000:\ri += 1 和等价的for循环：\nfor i in range(0, 1000000):\rpass 究竟哪个效率高呢？\n要知道，range()函数是直接由C语言写的，调用它速度非常快。而while循环中的“i += 1”这个操作，得通过Python的解释器间接调用底层的C语言；并且这个简单的操作，又涉及到了对象的创建和删除（因为i是整型，是immutable，i += 1相当于i = new int(i + 1)）。所以，显然，for循环的效率更胜一筹。\n条件与循环的复用 link前面两部分讲了条件与循环的一些基本操作，接下来，我们重点来看它们的进阶操作，让程序变得更简洁高效。\n在阅读代码的时候，你应该常常会发现，有很多将条件与循环并做一行的操作，例如：\nexpression1 if condition else expression2 for item in iterable 将这个表达式分解开来，其实就等同于下面这样的嵌套结构：\nfor item in iterable:\rif condition:\rexpression1\relse:\rexpression2 而如果没有else语句，则需要写成：\nexpression for item in iterable if condition 举个例子，比如我们要绘制y = 2*|x| + 5 的函数图像，给定集合x的数据点，需要计算出y的数据集合，那么只用一行代码，就可以很轻松地解决问题了：\ny = [value * 2 + 5 if value \u003e 0 else -value * 2 + 5 for value in x] 再比如我们在处理文件中的字符串时，常常遇到的一个场景：将文件中逐行读取的一个完整语句，按逗号分割单词，去掉首位的空字符，并过滤掉长度小于等于3的单词，最后返回由单词组成的列表。这同样可以简洁地表达成一行：\ntext = ' Today, is, Sunday'\rtext_list = [s.strip() for s in text.split(',') if len(s.strip()) \u003e 3]\rprint(text_list)\r['Today', 'Sunday'] 当然，这样的复用并不仅仅局限于一个循环。比如，给定两个列表x、y，要求返回x、y中所有元素对组成的元组，相等情况除外。那么，你也可以很容易表示出来：\n[(xx, yy) for xx in x for yy in y if xx != yy] 这样的写法就等价于：\nl = []\rfor xx in x:\rfor yy in y:\rif xx != yy:\rl.append((xx, yy)) 熟练之后，你会发现这种写法非常方便。当然，如果遇到逻辑很复杂的复用，你可能会觉得写成一行难以理解、容易出错。那种情况下，用正常的形式表达，也不失为一种好的规范和选择。\n总结 link今天这节课，我们一起学习了条件与循环的基本概念、进阶用法以及相应的应用。这里，我重点强调几个易错的地方。\n在条件语句中，if可以单独使用，但是elif和else必须和if同时搭配使用；而If条件语句的判断，除了boolean类型外，其他的最好显示出来。 在for循环中，如果需要同时访问索引和元素，你可以使用enumerate()函数来简化代码。 写条件与循环时，合理利用continue或者break来避免复杂的嵌套，是十分重要的。 要注意条件与循环的复用，简单功能往往可以用一行直接完成，极大地提高代码质量与效率。 思考题 link最后给你留一个思考题。给定下面两个列表attributes和values，要求针对values中每一组子列表value，输出其和attributes中的键对应后的字典，最后返回字典组成的列表。\nattributes = ['name', 'dob', 'gender']\rvalues = [['jason', '2000-01-01', 'male'], ['mike', '1999-01-01', 'male'],\r['nancy', '2001-02-01', 'female']\r]\r# expected output:\r[{'name': 'jason', 'dob': '2000-01-01', 'gender': 'male'}, {'name': 'mike', 'dob': '1999-01-01', 'gender': 'male'}, {'name': 'nancy', 'dob': '2001-02-01', 'gender': 'female'}] 你能分别用一行和多行条件循环语句，来实现这个功能吗？\n欢迎在留言区写下你的答案，还有你今天学习的心得和疑惑，也欢迎你把这篇文章分享给你的同事、朋友。\n#多行输出 list1 = [] #建议空列表 for value in values: #对值列表进行循环 dict1 = {} #简历空字典，后续对字典键值对存储 for index ,key in enumerate(attributes):#遍历建列表，返回索引与元素 dict1[key] = value[index] #键与值匹配对，组装成字典元素 list1.append(dict1) #将字典添加到列表中 print(list1)2019-11-27趣学车 👍（1） 💬（1）attributes = ['name', 'dob', 'gender'] values = [['jason', '2000-01-01', 'male'], ['mike', '1999-01-01', 'male'], ['nancy', '2001-02-01', 'female']]\nresult_list = [] for index, item in enumerate(values): result_dict = {} for i, value in enumerate(item): result_dict[attributes[i]] = value result_list.append(result_dict) print(result_list)2020-01-10建强 👍（1） 💬（1）另外，想问下老师，和Java相比，Python是不是不能用于构建企业级的应用，构建企业级的系统，是不是用Java更稳定，性能更高。另外，网上说Pyhton是一种粘合剂语言，感觉用Python是不是给人感觉很业余呢？哈哈，开个玩笑。2019-06-16daowuli_chihai 👍（0） 💬（1）文稿中下面代码，过滤掉长度小于等于5的单词，'Today'就没有了吧? 最后一行是 运行结果吧？ 也许不重要，呵呵 【\ntext = ' Today, is, Sunday' text_list = [s.strip() for s in text.split(',') if len(s.strip()) \u003e 5] print(text_list) ['Today', 'Sunday'] 】2020-06-11daowuli_chihai 👍（0） 💬（1）下面代码 第10行 except as err:\nas前面少了一个单词吧\nwhile True: try: text = input('Please enter your questions, enter \"q\" to exit') if text == 'q': print('Exit system') break … … print(response) except as err: # 第10行 print('Encountered error: {}'.format(err)) break 2020-06-11日月剑 👍（0） 💬（1）python 列表推导式的表达式是不是不能有赋值表达式？比如如下代码： a = ['A', 'B', 'C'] d = {} d[key] = 0 for key in a 这里执行的时候会有语法错误，应该怎么改呢?\n循环版： l = [] for value in values: d = {} for i in range(3): d[attributes[i]] = value[i] l.append(d)\nprint( [{ attributes[i]: value[i] for i in range(len(attributes)) } for value in values])2019-05-24呜呜啦 👍（24） 💬（4）attributes = ['name', 'dob', 'gender'] values = [ ['jason', '2000-01-01', 'male'], ['mike', '1999-01-01', 'male'], ['nancy', '2001-02-01', 'female'] ]\n多行代码版 linklist1 = [] # 建立空列表 for value in values: # 对值列表进行循环 dict1 = {} # 建立空字典，方便后续字典键值对存储 for index,key in enumerate(attributes): # 遍历键列表，返回元素与索引 dict1[key] = value[index] # 键与值配对，组装成字典元素 list1.append(dict1) # 将新字典添加到里列表中 print(list1) # 打印显示出完整列表\n一行代码版 link[{key:value[index] for index,key in enumerate(attributes)}for value in values]\n最外层[]与上面“list1=[]”和“list1.append(dict1)”等价 link\"{key:value[index] for index,key in enumerate(attributes)}\"与上面\"for value in values:\"内代码等价 link体会：先梳理逻辑，写出多行代码版，再回溯写出一行代码版，体现出Python的简洁优美2019-06-15 link "
            }
        );
    index.add(
            {
                id:  10 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/08---%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7\/",
                title: "08 - 异常处理：如何提高程序的稳定性？",
                description: "你好，我是景霄。\n今天这节课，我想和你聊聊Python的异常处理。和其他语言一样，异常处理是Python中一种很常见，并且很重要的机制与代码规范。\n我在实际工作中，见过很多次这样的情况：一位工程师提交了代码，不过代码某处忘记了异常处理。碰巧这种异常发生的频率不低，所以在代码push到线上后没多久，就会收到紧急通知——服务器崩溃了。\n如果事情严重，对用户的影响也很大，这位工程师还得去专门的会议上做自我检讨，可以说是很惨了。这类事件层出不穷，也告诉我们，正确理解和处理程序中的异常尤为关键。\n错误与异常 link首先要了解，Python中的错误和异常是什么？两者之间又有什么联系和区别呢？\n通常来说，程序中的错误至少包括两种，一种是语法错误，另一种则是异常。\n所谓语法错误，你应该很清楚，也就是你写的代码不符合编程规范，无法被识别与执行，比如下面这个例子：\nif name is not None\rprint(name) If语句漏掉了冒号，不符合Python的语法规范，所以程序就会报错invalid syntax。\n而异常则是指程序的语法正确，也可以被执行，但在执行过程中遇到了错误，抛出了异常，比如下面的3个例子：\n10 / 0\rTraceback (most recent call last):\rFile \"\", line 1, in ZeroDivisionError: integer division or modulo by zero\rorder * 2\rTraceback (most recent call last):\rFile \"\", line 1, in NameError: name 'order' is not defined\r1 + [1, 2]\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: unsupported operand type(s) for +: 'int' and 'list' 它们语法完全正确，但显然，我们不能做除法时让分母为0；也不能使用未定义的变量做运算；而让一个整型和一个列表相加也是不可取的。\n",
                content: "你好，我是景霄。\n今天这节课，我想和你聊聊Python的异常处理。和其他语言一样，异常处理是Python中一种很常见，并且很重要的机制与代码规范。\n我在实际工作中，见过很多次这样的情况：一位工程师提交了代码，不过代码某处忘记了异常处理。碰巧这种异常发生的频率不低，所以在代码push到线上后没多久，就会收到紧急通知——服务器崩溃了。\n如果事情严重，对用户的影响也很大，这位工程师还得去专门的会议上做自我检讨，可以说是很惨了。这类事件层出不穷，也告诉我们，正确理解和处理程序中的异常尤为关键。\n错误与异常 link首先要了解，Python中的错误和异常是什么？两者之间又有什么联系和区别呢？\n通常来说，程序中的错误至少包括两种，一种是语法错误，另一种则是异常。\n所谓语法错误，你应该很清楚，也就是你写的代码不符合编程规范，无法被识别与执行，比如下面这个例子：\nif name is not None\rprint(name) If语句漏掉了冒号，不符合Python的语法规范，所以程序就会报错invalid syntax。\n而异常则是指程序的语法正确，也可以被执行，但在执行过程中遇到了错误，抛出了异常，比如下面的3个例子：\n10 / 0\rTraceback (most recent call last):\rFile \"\", line 1, in ZeroDivisionError: integer division or modulo by zero\rorder * 2\rTraceback (most recent call last):\rFile \"\", line 1, in NameError: name 'order' is not defined\r1 + [1, 2]\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: unsupported operand type(s) for +: 'int' and 'list' 它们语法完全正确，但显然，我们不能做除法时让分母为0；也不能使用未定义的变量做运算；而让一个整型和一个列表相加也是不可取的。\n于是，当程序运行到这些地方时，就抛出了异常，并且终止运行。例子中的ZeroDivisionError NameError和TypeError，就是三种常见的异常类型。\n当然，Python中还有很多其他异常类型，比如KeyError是指字典中的键找不到；FileNotFoundError是指发送了读取文件的请求，但相应的文件不存在等等，我在此不一一赘述，你可以自行参考相应文档。\n如何处理异常 link刚刚讲到，如果执行到程序中某处抛出了异常，程序就会被终止并退出。你可能会问，那有没有什么办法可以不终止程序，让其照样运行下去呢？答案当然是肯定的，这也就是我们所说的异常处理，通常使用try和except来解决，比如：\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r... except ValueError as err:\rprint('Value Error: {}'.format(err))\rprint('continue')\r... 这里默认用户输入以逗号相隔的两个整形数字，将其提取后，做后续的操作（注意input函数会将输入转换为字符串类型）。如果我们输入a,b，程序便会抛出异常invalid literal for int() with base 10: 'a'，然后跳出try这个block。\n由于程序抛出的异常类型是ValueError，和except block所catch的异常类型相匹配，所以except block便会被执行，最终输出Value Error: invalid literal for int() with base 10: 'a'，并打印出continue。\nplease enter two numbers separated by comma: a,b\rValue Error: invalid literal for int() with base 10: 'a'\rcontinue 我们知道，except block只接受与它相匹配的异常类型并执行，如果程序抛出的异常并不匹配，那么程序照样会终止并退出。\n所以，还是刚刚这个例子，如果我们只输入1，程序抛出的异常就是IndexError: list index out of range，与ValueError不匹配，那么except block就不会被执行，程序便会终止并退出（continue不会被打印）。\nplease enter two numbers separated by comma: 1\rIndexError Traceback (most recent call last)\rIndexError: list index out of range 不过，很显然，这样强调一种类型的写法有很大的局限性。那么，该怎么解决这个问题呢？\n其中一种解决方案，是在except block中加入多种异常的类型，比如下面这样的写法：\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r...\rexcept (ValueError, IndexError) as err:\rprint('Error: {}'.format(err))\rprint('continue')\r... 或者第二种写法：\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r...\rexcept ValueError as err:\rprint('Value Error: {}'.format(err))\rexcept IndexError as err:\rprint('Index Error: {}'.format(err))\rprint('continue')\r... 这样，每次程序执行时，except block中只要有一个exception类型与实际匹配即可。\n不过，很多时候，我们很难保证程序覆盖所有的异常类型，所以，更通常的做法，是在最后一个except block，声明其处理的异常类型是Exception。Exception是其他所有非系统异常的基类，能够匹配任意非系统异常。那么这段代码就可以写成下面这样：\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r...\rexcept ValueError as err:\rprint('Value Error: {}'.format(err))\rexcept IndexError as err:\rprint('Index Error: {}'.format(err))\rexcept Exception as err:\rprint('Other error: {}'.format(err))\rprint('continue')\r... 或者，你也可以在except后面省略异常类型，这表示与任意异常相匹配（包括系统异常等）：\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r...\rexcept ValueError as err:\rprint('Value Error: {}'.format(err))\rexcept IndexError as err:\rprint('Index Error: {}'.format(err))\rexcept:\rprint('Other error')\rprint('continue')\r... 需要注意，当程序中存在多个except block时，最多只有一个except block会被执行。换句话说，如果多个except声明的异常类型都与实际相匹配，那么只有最前面的except block会被执行，其他则被忽略。\n异常处理中，还有一个很常见的用法是finally，经常和try、except放在一起来用。无论发生什么情况，finally block中的语句都会被执行，哪怕前面的try和excep block中使用了return语句。\n一个常见的应用场景，便是文件的读取：\nimport sys\rtry:\rf = open('file.txt', 'r')\r.... # some data processing\rexcept OSError as err:\rprint('OS error: {}'.format(err))\rexcept:\rprint('Unexpected error:', sys.exc_info()[0])\rfinally:\rf.close() 这段代码中，try block尝试读取file.txt这个文件，并对其中的数据进行一系列的处理，到最后，无论是读取成功还是读取失败，程序都会执行finally中的语句——关闭这个文件流，确保文件的完整性。因此，在finally中，我们通常会放一些无论如何都要执行的语句。\n值得一提的是，对于文件的读取，我们也常常使用with open，你也许在前面的例子中已经看到过，with open会在最后自动关闭文件，让语句更加简洁。\n用户自定义异常 link前面的例子里充斥了很多Python内置的异常类型，你可能会问，我可以创建自己的异常类型吗？\n答案是肯定是，Python当然允许我们这么做。下面这个例子，我们创建了自定义的异常类型MyInputError，定义并实现了初始化函数和str函数（直接print时调用）：\nclass MyInputError(Exception):\r\"\"\"Exception raised when there're errors in input\"\"\"\rdef __init__(self, value): # 自定义异常类型的初始化\rself.value = value\rdef __str__(self): # 自定义异常类型的string表达形式\rreturn (\"{} is invalid input\".format(repr(self.value)))\rtry:\rraise MyInputError(1) # 抛出MyInputError这个异常\rexcept MyInputError as err:\rprint('error: {}'.format(err)) 如果你执行上述代码块并输出，便会得到下面的结果：\nerror: 1 is invalid input 实际工作中，如果内置的异常类型无法满足我们的需求，或者为了让异常更加详细、可读，想增加一些异常类型的其他功能，我们可以自定义所需异常类型。不过，大多数情况下，Python内置的异常类型就足够好了。\n异常的使用场景与注意点 link学完了前面的基础知识，接下来我们着重谈一下，异常的使用场景与注意点。\n通常来说，在程序中，如果我们不确定某段代码能否成功执行，往往这个地方就需要使用异常处理。除了上述文件读取的例子，我可以再举一个例子来说明。\n大型社交网站的后台，需要针对用户发送的请求返回相应记录。用户记录往往储存在key-value结构的数据库中，每次有请求过来后，我们拿到用户的ID，并用ID查询数据库中此人的记录，就能返回相应的结果。\n而数据库返回的原始数据，往往是json string的形式，这就需要我们首先对json string进行decode（解码），你可能很容易想到下面的方法：\nimport json\rraw_data = queryDB(uid) # 根据用户的id，返回相应的信息\rdata = json.loads(raw_data) 这样的代码是不是就足够了呢？\n要知道，在json.loads()函数中，输入的字符串如果不符合其规范，那么便无法解码，就会抛出异常，因此加上异常处理十分必要。\ntry:\rdata = json.loads(raw_data)\r....\rexcept JSONDecodeError as err:\rprint('JSONDecodeError: {}'.format(err)) 不过，有一点切记，我们不能走向另一个极端——滥用异常处理。\n比如，当你想要查找字典中某个键对应的值时，绝不能写成下面这种形式：\nd = {'name': 'jason', 'age': 20}\rtry:\rvalue = d['dob']\r...\rexcept KeyError as err:\rprint('KeyError: {}'.format(err)) 诚然，这样的代码并没有bug，但是让人看了摸不着头脑，也显得很冗余。如果你的代码中充斥着这种写法，无疑对阅读、协作来说都是障碍。因此，对于flow-control（流程控制）的代码逻辑，我们一般不用异常处理。\n字典这个例子，写成下面这样就很好。\nif 'dob' in d:\rvalue = d['dob']\r... 总结 link这节课， 我们一起学习了Python的异常处理及其使用场景，你需要重点掌握下面几点。\n异常，通常是指程序运行的过程中遇到了错误，终止并退出。我们通常使用try except语句去处理异常，这样程序就不会被终止，仍能继续执行。 处理异常时，如果有必须执行的语句，比如文件打开后必须关闭等等，则可以放在finally block中。 异常处理，通常用在你不确定某段代码能否成功执行，也无法轻易判断的情况下，比如数据库的连接、读取等等。正常的flow-control逻辑，不要使用异常处理，直接用条件语句解决就可以了。 思考题 link最后，给你留一个思考题。在异常处理时，如果try block中有多处抛出异常，需要我们使用多个try except block吗？以数据库的连接、读取为例，下面两种写法，你觉得哪种更好呢？\n第一种：\ntry:\rdb = DB.connect('') # 可能会抛出异常\rraw_data = DB.queryData('') # 可能会抛出异常\rexcept (DBConnectionError, DBQueryDataError) err:\rprint('Error: {}'.format(err)) 第二种：\ntry:\rdb = DB.connect('') # 可能会抛出异常\rtry:\rraw_data = DB.queryData('')\rexcept DBQueryDataError as err:\rprint('DB query data error: {}'.format(err))\rexcept DBConnectionError as err:\rprint('DB connection error: {}'.format(err)) 欢迎在留言区写下你的答案，还有你今天学习的心得和疑惑，也欢迎你把这篇文章分享给你的同事、朋友。\nprint(e) # NameError: name 'e' is not defined 这里为什么会显示e没有被定义呢？2019-05-27Hoo-Ah 👍（95） 💬（2）第一种写法更加简洁，易于阅读。而且except后面的错误类型先抛出数据库连接错误，之后才抛出查询错误，实现的异常处理和第二种一样。2019-05-27liput 👍（17） 💬（3）想请问老师，在facebook里面开发，对于异常处理有什么规范需要遵循吗？自定义异常、抛异常、捕获异常，粒度一般怎么把控呢？ 与此相应的，我对日志输出也有同样的疑问，希望老师能结合您在大公司里的实战经验多讲讲。2019-05-27John Si 👍（4） 💬（1）1. 第一種寫法比第二種寫法簡潔 2. 因我對try語法執行流程不太清楚，還是老師跟熟悉該同學多講解一下。但我自己想法是第二種寫法跟巢狀迴圈寫法很像，假設是第二句語法發生錯誤，第二種寫法會多執行一次try 語句，從而增加了程序運行時間。\n綜上所述，我認為第一種寫法較第二種好2019-05-27小豹子 👍（3） 💬（1）老师，系统异常，非系统异常能举个例子说明下吗？2019-05-27Kevin 👍（1） 💬（1）从代码行数看第一种更简洁，第一种中，使用了一个try..expect将异常统一处理，代码简洁， 第二种，代码中有嵌套，2020-06-17王大华 👍（1） 💬（2）第一种和第二种效果类似， 都是先检查数据库连接异常，再检查query执行的异常。\n更喜欢这种写法： try: db = DB.connect('') # 可能会抛出异常 raw_data = DB.queryData('') # 可能会抛出异常 except DBConnectionError as err: print('ConnectionError: {}'.format(err)) except DBQueryDataError as err: print('QueryDataError: {}'.format(err))2020-02-02一粒 👍（1） 💬（1）老师，什么样的代码才是您说的“flow-control”2020-01-02Geek_David 👍（0） 💬（1）个人觉得这个课还要加上一本python的书，那就天衣无缝了2020-03-29百年 👍（0） 💬（1）老师的课收获比较大，Python基础课也学过，Python核心机制也学过一点，但是一写代码，特别是实时读写文件，总是报一大堆错误，这结课真的是运用上了。2019-05-29Blackwang 👍（0） 💬（2）第一种更好，不过理由说不上来…… 另外老师，请问前几天思考题的答案有吗？之前说周末放 github 的？2019-05-27Robert小七 👍（0） 💬（1）为什么不直接用except Exception as err?2019-05-27栾~龟虽寿！ 👍（0） 💬（3）老师，课越听越觉得值，可是大家如何在手机上写代码的？不会是电脑上写好，利用微信，转发给自己手机上，再复制粘贴到留言吧？还有我有些着急，是否能一天播放两课，哈哈，我有基础。2019-05-27mickle 👍（0） 💬（1）我在开发中用第一种吧，第二种代码冗余，看着难受2019-05-27Geek_b6f316 👍（35） 💬（1）第一种方法简单明了，是不是少了一个as2019-05-27\n"
            }
        );
    index.add(
            {
                id:  11 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/09---%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0\/",
                title: "09 - 不可或缺的自定义函数",
                description: "你好，我是景霄。\n实际工作生活中，我曾见到不少初学者编写的Python程序，他们长达几百行的代码中，却没有一个函数，通通按顺序堆到一块儿，不仅让人读起来费时费力，往往也是错误连连。\n一个规范的值得借鉴的Python程序，除非代码量很少（比如10行、20行以下），基本都应该由多个函数组成，这样的代码才更加模块化、规范化。\n函数是Python程序中不可或缺的一部分。事实上，在前面的学习中，我们已经用到了很多Python的内置函数，比如sorted()表示对一个集合序列排序，len()表示返回一个集合序列的长度大小等等。这节课，我们主要来学习Python的自定义函数。\n函数基础 link那么，到底什么是函数，如何在Python程序中定义函数呢？\n说白了，函数就是为了实现某一功能的代码段，只要写好以后，就可以重复利用。我们先来看下面一个简单的例子:\ndef my_func(message):\rprint('Got a message: {}'.format(message))\r# 调用函数 my_func()\rmy_func('Hello World')\r# 输出\rGot a message: Hello World 其中：\ndef是函数的声明； my_func是函数的名称； 括号里面的message则是函数的参数； 而print那行则是函数的主体部分，可以执行相应的语句； 在函数最后，你可以返回调用结果（return或yield），也可以不返回。 总结一下，大概是下面的这种形式：\ndef name(param1, param2, ..., paramN):\rstatements\rreturn/yield value # optional 和其他需要编译的语言（比如C语言）不一样的是，def是可执行语句，这意味着函数直到被调用前，都是不存在的。当程序调用函数时，def语句才会创建一个新的函数对象，并赋予其名字。\n我们一起来看几个例子，加深你对函数的印象：\ndef my_sum(a, b):\rreturn a + b\rresult = my_sum(3, 5)\rprint(result)\r# 输出\r8 这里，我们定义了my_sum()这个函数，它有两个参数a和b，作用是相加；随后，调用my_sum()函数，分别把3和5赋于a和b；最后，返回其相加的值，赋于变量result，并输出得到8。\n再来看一个例子：\ndef find_largest_element(l):\rif not isinstance(l, list):\rprint('input is not type of list')\rreturn\rif len(l) == 0:\rprint('empty input')\rreturn\rlargest_element = l[0]\rfor item in l:\rif item \u003e largest_element:\rlargest_element = item\rprint('largest element is: {}'.format(largest_element)) find_largest_element([8, 1,-3, 2, 0])\r# 输出\rlargest element is: 8 这个例子中，我们定义了函数find_largest_element，作用是遍历输入的列表，找出最大的值并打印。因此，当我们调用它，并传递列表 [8, 1, -3, 2, 0] 作为参数时，程序就会输出 largest element is: 8。\n",
                content: "你好，我是景霄。\n实际工作生活中，我曾见到不少初学者编写的Python程序，他们长达几百行的代码中，却没有一个函数，通通按顺序堆到一块儿，不仅让人读起来费时费力，往往也是错误连连。\n一个规范的值得借鉴的Python程序，除非代码量很少（比如10行、20行以下），基本都应该由多个函数组成，这样的代码才更加模块化、规范化。\n函数是Python程序中不可或缺的一部分。事实上，在前面的学习中，我们已经用到了很多Python的内置函数，比如sorted()表示对一个集合序列排序，len()表示返回一个集合序列的长度大小等等。这节课，我们主要来学习Python的自定义函数。\n函数基础 link那么，到底什么是函数，如何在Python程序中定义函数呢？\n说白了，函数就是为了实现某一功能的代码段，只要写好以后，就可以重复利用。我们先来看下面一个简单的例子:\ndef my_func(message):\rprint('Got a message: {}'.format(message))\r# 调用函数 my_func()\rmy_func('Hello World')\r# 输出\rGot a message: Hello World 其中：\ndef是函数的声明； my_func是函数的名称； 括号里面的message则是函数的参数； 而print那行则是函数的主体部分，可以执行相应的语句； 在函数最后，你可以返回调用结果（return或yield），也可以不返回。 总结一下，大概是下面的这种形式：\ndef name(param1, param2, ..., paramN):\rstatements\rreturn/yield value # optional 和其他需要编译的语言（比如C语言）不一样的是，def是可执行语句，这意味着函数直到被调用前，都是不存在的。当程序调用函数时，def语句才会创建一个新的函数对象，并赋予其名字。\n我们一起来看几个例子，加深你对函数的印象：\ndef my_sum(a, b):\rreturn a + b\rresult = my_sum(3, 5)\rprint(result)\r# 输出\r8 这里，我们定义了my_sum()这个函数，它有两个参数a和b，作用是相加；随后，调用my_sum()函数，分别把3和5赋于a和b；最后，返回其相加的值，赋于变量result，并输出得到8。\n再来看一个例子：\ndef find_largest_element(l):\rif not isinstance(l, list):\rprint('input is not type of list')\rreturn\rif len(l) == 0:\rprint('empty input')\rreturn\rlargest_element = l[0]\rfor item in l:\rif item \u003e largest_element:\rlargest_element = item\rprint('largest element is: {}'.format(largest_element)) find_largest_element([8, 1,-3, 2, 0])\r# 输出\rlargest element is: 8 这个例子中，我们定义了函数find_largest_element，作用是遍历输入的列表，找出最大的值并打印。因此，当我们调用它，并传递列表 [8, 1, -3, 2, 0] 作为参数时，程序就会输出 largest element is: 8。\n需要注意，主程序调用函数时，必须保证这个函数此前已经定义过，不然就会报错，比如：\nmy_func('hello world')\rdef my_func(message):\rprint('Got a message: {}'.format(message))\r# 输出\rNameError: name 'my_func' is not defined 但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为def是可执行语句，函数在调用之前都不存在，我们只需保证调用时，所需的函数都已经声明定义：\ndef my_func(message):\rmy_sub_func(message) # 调用my_sub_func()在其声明之前不影响程序执行\rdef my_sub_func(message):\rprint('Got a message: {}'.format(message))\rmy_func('hello world')\r# 输出\rGot a message: hello world 另外，Python函数的参数可以设定默认值，比如下面这样的写法：\ndef func(param = 0):\r... 这样，在调用函数func()时，如果参数param没有传入，则参数默认为0；而如果传入了参数param，其就会覆盖默认值。\n前面说过，Python和其他语言相比的一大特点是，Python是dynamically typed的，可以接受任何数据类型（整型，浮点，字符串等等）。对函数参数来说，这一点同样适用。比如还是刚刚的my_sum函数，我们也可以把列表作为参数来传递，表示将两个列表相连接：\nprint(my_sum([1, 2], [3, 4]))\r# 输出\r[1, 2, 3, 4] 同样，也可以把字符串作为参数传递，表示字符串的合并拼接：\nprint(my_sum('hello ', 'world'))\r# 输出\rhello world 当然，如果两个参数的数据类型不同，比如一个是列表、一个是字符串，两者无法相加，那就会报错：\nprint(my_sum([1, 2], 'hello'))\rTypeError: can only concatenate list (not \"str\") to list 我们可以看到，Python不用考虑输入的数据类型，而是将其交给具体的代码去判断执行，同样的一个函数（比如这边的相加函数my_sum()），可以同时应用在整型、列表、字符串等等的操作中。\n在编程语言中，我们把这种行为称为多态。这也是Python和其他语言，比如Java、C等很大的一个不同点。当然，Python这种方便的特性，在实际使用中也会带来诸多问题。因此，必要时请你在开头加上数据的类型检查。\nPython函数的另一大特性，是Python支持函数的嵌套。所谓的函数嵌套，就是指函数里面又有函数，比如：\ndef f1():\rprint('hello')\rdef f2():\rprint('world')\rf2()\rf1()\r# 输出\rhello\rworld 这里函数f1()的内部，又定义了函数f2()。在调用函数f1()时，会先打印字符串'hello'，然后f1()内部再调用f2()，打印字符串'world'。你也许会问，为什么需要函数嵌套？这样做有什么好处呢？\n其实，函数的嵌套，主要有下面两个方面的作用。\n第一，函数的嵌套能够保证内部函数的隐私。内部函数只能被外部函数所调用和访问，不会暴露在全局作用域，因此，如果你的函数内部有一些隐私数据（比如数据库的用户、密码等），不想暴露在外，那你就可以使用函数的的嵌套，将其封装在内部函数中，只通过外部函数来访问。比如：\ndef connect_DB():\rdef get_DB_configuration():\r...\rreturn host, username, password\rconn = connector.connect(get_DB_configuration())\rreturn conn 这里的函数get_DB_configuration，便是内部函数，它无法在connect_DB()函数以外被单独调用。也就是说，下面这样的外部直接调用是错误的：\nget_DB_configuration()\r# 输出\rNameError: name 'get_DB_configuration' is not defined 我们只能通过调用外部函数connect_DB()来访问它，这样一来，程序的安全性便有了很大的提高。\n第二，合理的使用函数嵌套，能够提高程序的运行效率。我们来看下面这个例子：\ndef factorial(input):\r# validation check\rif not isinstance(input, int):\rraise Exception('input must be an integer.')\rif input \u003c 0:\rraise Exception('input must be greater or equal to 0' )\r...\rdef inner_factorial(input):\rif input \u003c= 1:\rreturn 1\rreturn input * inner_factorial(input-1)\rreturn inner_factorial(input)\rprint(factorial(5)) 这里，我们使用递归的方式计算一个数的阶乘。因为在计算之前，需要检查输入是否合法，所以我写成了函数嵌套的形式，这样一来，输入是否合法就只用检查一次。而如果我们不使用函数嵌套，那么每调用一次递归便会检查一次，这是没有必要的，也会降低程序的运行效率。\n实际工作中，如果你遇到相似的情况，输入检查不是很快，还会耗费一定的资源，那么运用函数的嵌套就十分必要了。\n函数变量作用域 linkPython函数中变量的作用域和其他语言类似。如果变量是在函数内部定义的，就称为局部变量，只在函数内部有效。一旦函数执行完毕，局部变量就会被回收，无法访问，比如下面的例子：\ndef read_text_from_file(file_path):\rwith open(file_path) as file:\r... 我们在函数内部定义了file这个变量，这个变量只在read_text_from_file这个函数里有效，在函数外部则无法访问。\n相对应的，全局变量则是定义在整个文件层次上的，比如下面这段代码：\nMIN_VALUE = 1\rMAX_VALUE = 10\rdef validation_check(value):\rif value \u003c MIN_VALUE or value \u003e MAX_VALUE:\rraise Exception('validation check fails') 这里的MIN_VALUE和MAX_VALUE就是全局变量，可以在文件内的任何地方被访问，当然在函数内部也是可以的。不过，我们不能在函数内部随意改变全局变量的值。比如，下面的写法就是错误的：\nMIN_VALUE = 1\rMAX_VALUE = 10\rdef validation_check(value):\r...\rMIN_VALUE += 1\r...\rvalidation_check(5) 如果运行这段代码，程序便会报错：\nUnboundLocalError: local variable 'MIN_VALUE' referenced before assignment 这是因为，Python的解释器会默认函数内部的变量为局部变量，但是又发现局部变量MIN_VALUE并没有声明，因此就无法执行相关操作。所以，如果我们一定要在函数内部改变全局变量的值，就必须加上global这个声明：\nMIN_VALUE = 1\rMAX_VALUE = 10\rdef validation_check(value):\rglobal MIN_VALUE\r...\rMIN_VALUE += 1\r...\rvalidation_check(5) 这里的global关键字，并不表示重新创建了一个全局变量MIN_VALUE，而是告诉Python解释器，函数内部的变量MIN_VALUE，就是之前定义的全局变量，并不是新的全局变量，也不是局部变量。这样，程序就可以在函数内部访问全局变量，并修改它的值了。\n另外，如果遇到函数内部局部变量和全局变量同名的情况，那么在函数内部，局部变量会覆盖全局变量，比如下面这种：\nMIN_VALUE = 1\rMAX_VALUE = 10\rdef validation_check(value):\rMIN_VALUE = 3\r... 在函数validation_check()内部，我们定义了和全局变量同名的局部变量MIN_VALUE，那么，MIN_VALUE在函数内部的值，就应该是3而不是1了。\n类似的，对于嵌套函数来说，内部函数可以访问外部函数定义的变量，但是无法修改，若要修改，必须加上nonlocal这个关键字：\ndef outer():\rx = \"local\"\rdef inner():\rnonlocal x # nonlocal关键字表示这里的x就是外部函数outer定义的变量x\rx = 'nonlocal'\rprint(\"inner:\", x)\rinner()\rprint(\"outer:\", x)\router()\r# 输出\rinner: nonlocal\router: nonlocal 如果不加上nonlocal这个关键字，而内部函数的变量又和外部函数变量同名，那么同样的，内部函数变量会覆盖外部函数的变量。\ndef outer():\rx = \"local\"\rdef inner():\rx = 'nonlocal' # 这里的x是inner这个函数的局部变量\rprint(\"inner:\", x)\rinner()\rprint(\"outer:\", x)\router()\r# 输出\rinner: nonlocal\router: local 闭包 link这节课的第三个重点，我想再来介绍一下闭包（closure）。闭包其实和刚刚讲的嵌套函数类似，不同的是，这里外部函数返回的是一个函数，而不是一个具体的值。返回的函数通常赋于一个变量，这个变量可以在后面被继续执行调用。\n举个例子你就更容易理解了。比如，我们想计算一个数的n次幂，用闭包可以写成下面的代码：\ndef nth_power(exponent):\rdef exponent_of(base):\rreturn base ** exponent\rreturn exponent_of # 返回值是exponent_of函数\rsquare = nth_power(2) # 计算一个数的平方\rcube = nth_power(3) # 计算一个数的立方 square\r# 输出\r"
            }
        );
    index.add(
            {
                id:  12 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/30---%E7%9C%9F%E7%9A%84%E6%9C%89%E5%BF%85%E8%A6%81%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%90%97\/",
                title: "30 - 真的有必要写单元测试吗？",
                description: "你好，我是景霄。\n说到unit test（即单元测试，下文统一用中文称呼），大部分人的反应估计有这么两种：要么就是，单元测试啊，挺简单的呀，做不做无所谓吧；要么就是，哎呀，项目进度太赶，单元测试拖一拖之后再来吧。\n显然，这两种人，都没有正确认识到单元测试的价值，也没能掌握正确的单元测试方法。你是不是觉得自己只要了解Python的各个feature，能够编写出符合规定功能的程序就可以了呢？\n其实不然，完成产品的功能需求只是很基础的一部分，如何保证所写代码的稳定、高效、无误，才是我们工作的关键。而学会合理地使用单元测试，正是帮助你实现这一目标的重要路径。\n我们总说，测试驱动开发（TDD）。今天我就以Python为例，教你设计编写Python的单元测试代码，带你熟悉并掌握这一重要技能。\n什么是单元测试？ link单元测试，通俗易懂地讲，就是编写测试来验证某一个模块的功能正确性，一般会指定输入，验证输出是否符合预期。\n实际生产环境中，我们会对每一个模块的所有可能输入值进行测试。这样虽然显得繁琐，增加了额外的工作量，但是能够大大提高代码质量，减小bug发生的可能性，也更方便系统的维护。\n说起单元测试，就不得不提 Python unittest库，它提供了我们需要的大多数工具。我们来看下面这个简单的测试，从代码中了解其使用方法：\nimport unittest\r# 将要被测试的排序函数\rdef sort(arr):\rl = len(arr)\rfor i in range(0, l):\rfor j in range(i + 1, l):\rif arr[i] \u003e= arr[j]:\rtmp = arr[i]\rarr[i] = arr[j]\rarr[j] = tmp\r# 编写子类继承unittest.TestCase\rclass TestSort(unittest.TestCase):\r# 以test开头的函数将会被测试\rdef test_sort(self):\rarr = [3, 4, 1, 5, 6]\rsort(arr)\r# assert 结果跟我们期待的一样\rself.assertEqual(arr, [1, 3, 4, 5, 6])\rif __name__ == '__main__':\r## 如果在Jupyter下，请用如下方式运行单元测试\runittest.main(argv=['first-arg-is-ignored'], exit=False)\r## 如果是命令行下运行，则：\r## unittest.main()\r## 输出\r..\r----------------------------------------------------------------------\rRan 2 tests in 0.002s\rOK 这里，我们创建了一个排序函数的单元测试，来验证排序函数的功能是否正确。代码里我做了非常详细的注释，相信你能够大致读懂，我再来介绍一些细节。\n",
                content: "你好，我是景霄。\n说到unit test（即单元测试，下文统一用中文称呼），大部分人的反应估计有这么两种：要么就是，单元测试啊，挺简单的呀，做不做无所谓吧；要么就是，哎呀，项目进度太赶，单元测试拖一拖之后再来吧。\n显然，这两种人，都没有正确认识到单元测试的价值，也没能掌握正确的单元测试方法。你是不是觉得自己只要了解Python的各个feature，能够编写出符合规定功能的程序就可以了呢？\n其实不然，完成产品的功能需求只是很基础的一部分，如何保证所写代码的稳定、高效、无误，才是我们工作的关键。而学会合理地使用单元测试，正是帮助你实现这一目标的重要路径。\n我们总说，测试驱动开发（TDD）。今天我就以Python为例，教你设计编写Python的单元测试代码，带你熟悉并掌握这一重要技能。\n什么是单元测试？ link单元测试，通俗易懂地讲，就是编写测试来验证某一个模块的功能正确性，一般会指定输入，验证输出是否符合预期。\n实际生产环境中，我们会对每一个模块的所有可能输入值进行测试。这样虽然显得繁琐，增加了额外的工作量，但是能够大大提高代码质量，减小bug发生的可能性，也更方便系统的维护。\n说起单元测试，就不得不提 Python unittest库，它提供了我们需要的大多数工具。我们来看下面这个简单的测试，从代码中了解其使用方法：\nimport unittest\r# 将要被测试的排序函数\rdef sort(arr):\rl = len(arr)\rfor i in range(0, l):\rfor j in range(i + 1, l):\rif arr[i] \u003e= arr[j]:\rtmp = arr[i]\rarr[i] = arr[j]\rarr[j] = tmp\r# 编写子类继承unittest.TestCase\rclass TestSort(unittest.TestCase):\r# 以test开头的函数将会被测试\rdef test_sort(self):\rarr = [3, 4, 1, 5, 6]\rsort(arr)\r# assert 结果跟我们期待的一样\rself.assertEqual(arr, [1, 3, 4, 5, 6])\rif __name__ == '__main__':\r## 如果在Jupyter下，请用如下方式运行单元测试\runittest.main(argv=['first-arg-is-ignored'], exit=False)\r## 如果是命令行下运行，则：\r## unittest.main()\r## 输出\r..\r----------------------------------------------------------------------\rRan 2 tests in 0.002s\rOK 这里，我们创建了一个排序函数的单元测试，来验证排序函数的功能是否正确。代码里我做了非常详细的注释，相信你能够大致读懂，我再来介绍一些细节。\n首先，我们需要创建一个类TestSort，继承类‘unittest.TestCase’；然后，在这个类中定义相应的测试函数test_sort()，进行测试。注意，测试函数要以‘test’开头，而测试函数的内部，通常使用assertEqual()、assertTrue()、assertFalse()和assertRaise()等assert语句对结果进行验证。\n最后运行时，如果你是在IPython或者Jupyter环境下，请使用下面这行代码：\nunittest.main(argv=['first-arg-is-ignored'], exit=False) 而如果你用的是命令行，直接使用unittest.main()就可以了。你可以看到，运行结果输出’OK‘，这就表示我们的测试通过了。\n当然，这个例子中的被测函数相对简单一些，所以写起对应的单元测试来也非常自然，并不需要很多单元测试的技巧。但实战中的函数往往还是比较复杂的，遇到复杂问题，高手和新手的最大差别，便是单元测试技巧的使用。\n单元测试的几个技巧 link接下来，我将会介绍Python单元测试的几个技巧，分别是mock、side_effect和patch。这三者用法不一样，但都是一个核心思想，即用虚假的实现，来替换掉被测试函数的一些依赖项，让我们能把更多的精力放在需要被测试的功能上。\nmock linkmock是单元测试中最核心重要的一环。mock的意思，便是通过一个虚假对象，来代替被测试函数或模块需要的对象。\n举个例子，比如你要测一个后端API逻辑的功能性，但一般后端API都依赖于数据库、文件系统、网络等。这样，你就需要通过mock，来创建一些虚假的数据库层、文件系统层、网络层对象，以便可以简单地对核心后端逻辑单元进行测试。\nPython mock则主要使用mock或者MagicMock对象，这里我也举了一个代码示例。这个例子看上去比较简单，但是里面的思想很重要。下面我们一起来看下：\nimport unittest\rfrom unittest.mock import MagicMock\rclass A(unittest.TestCase):\rdef m1(self):\rval = self.m2()\rself.m3(val)\rdef m2(self):\rpass\rdef m3(self, val):\rpass\rdef test_m1(self):\ra = A()\ra.m2 = MagicMock(return_value=\"custom_val\")\ra.m3 = MagicMock()\ra.m1()\rself.assertTrue(a.m2.called) #验证m2被call过\ra.m3.assert_called_with(\"custom_val\") #验证m3被指定参数call过\rif __name__ == '__main__':\runittest.main(argv=['first-arg-is-ignored'], exit=False)\r## 输出\r..\r----------------------------------------------------------------------\rRan 2 tests in 0.002s\rOK 这段代码中，我们定义了一个类的三个方法m1()、m2()、m3()。我们需要对m1()进行单元测试，但是m1()取决于m2()和m3()。如果m2()和m3()的内部比较复杂, 你就不能只是简单地调用m1()函数来进行测试，可能需要解决很多依赖项的问题。\n这一听就让人头大了吧？但是，有了mock其实就很好办了。我们可以把m2()替换为一个返回具体数值的value，把m3()替换为另一个mock（空函数）。这样，测试m1()就很容易了，我们可以测试m1()调用m2()，并且用m2()的返回值调用m3()。\n可能你会疑惑，这样测试m1()不是基本上毫无意义吗？看起来只是象征性地测了一下逻辑呀？\n其实不然，真正工业化的代码，都是很多层模块相互逻辑调用的一个树形结构。单元测试需要测的是某个节点的逻辑功能，mock掉相关的依赖项是非常重要的。这也是为什么会被叫做单元测试unit test，而不是其他的integration test、end to end test这类。\nMock Side Effect link第二个我们来看Mock Side Effect，这个概念很好理解，就是 mock的函数，属性是可以根据不同的输入，返回不同的数值，而不只是一个return_value。\n比如下面这个示例，例子很简单，测试的是输入参数是否为负数，输入小于0则输出为1 ，否则输出为2。代码很简短，你一定可以看懂，这便是Mock Side Effect的用法。\nfrom unittest.mock import MagicMock\rdef side_effect(arg):\rif arg \u003c 0:\rreturn 1\relse:\rreturn 2\rmock = MagicMock()\rmock.side_effect = side_effect\rmock(-1)\r1\rmock(1)\r2 patch link至于patch，给开发者提供了非常便利的函数mock方法。它可以应用Python的decoration模式或是context manager概念，快速自然地mock所需的函数。它的用法也不难，我们来看代码：\nfrom unittest.mock import patch\r@patch('sort')\rdef test_sort(self, mock_sort):\r...\r... 在这个test里面，mock_sort 替代sort函数本身的存在，所以，我们可以像开始提到的mock object一样，设置return_value和side_effect。\n另一种patch的常见用法，是mock类的成员函数，这个技巧我们在工作中也经常会用到，比如说一个类的构造函数非常复杂，而测试其中一个成员函数并不依赖所有初始化的object。它的用法如下：\nwith patch.object(A, '__init__', lambda x: None):\r… 代码应该也比较好懂。在with语句里面，我们通过patch，将A类的构造函数mock为一个do nothing的函数，这样就可以很方便地避免一些复杂的初始化（initialization）。\n其实，综合前面讲的这几点来看，你应该感受到了，单元测试的核心还是mock，mock掉依赖项，测试相应的逻辑或算法的准确性。在我看来，虽然Python unittest库还有很多层出不穷的方法，但只要你能掌握了MagicMock和patch，编写绝大部分工作场景的单元测试就不成问题了。\n高质量单元测试的关键 link这节课的最后，我想谈一谈高质量的单元测试。我很理解，单元测试这个东西，哪怕是正在使用的人也是“百般讨厌”的，不少人很多时候只是敷衍了事。我也嫌麻烦，但从来不敢松懈，因为在大公司里，如果你写一个很重要的模块功能，不写单元测试是无法通过code review的。\n低质量的单元测试，可能真的就是摆设，根本不能帮我们验证代码的正确性，还浪费时间。那么，既然要做单元测试，与其浪费时间糊弄自己，不如追求高质量的单元测试，切实提高代码品质。\n那该怎么做呢？结合工作经验，我认为一个高质量的单元测试，应该特别关注下面两点。\nTest Coverage link首先我们要关注Test Coverage，它是衡量代码中语句被cover的百分比。可以说，提高代码模块的Test Coverage，基本等同于提高代码的正确性。\n为什么呢？\n要知道，大多数公司代码库的模块都非常复杂。尽管它们遵从模块化设计的理念，但因为有复杂的业务逻辑在，还是会产生逻辑越来越复杂的模块。所以，编写高质量的单元测试，需要我们cover模块的每条语句，提高Test Coverage。\n我们可以用Python的coverage tool 来衡量Test Coverage，并且显示每个模块为被coverage的语句。如果你想了解更多更详细的使用，可以点击这个链接来学习：https://coverage.readthedocs.io/en/v4.5.x/ 。\n模块化 link高质量单元测试，不仅要求我们提高Test Coverage，尽量让所写的测试能够cover每个模块中的每条语句；还要求我们从测试的角度审视codebase，去思考怎么模块化代码，以便写出高质量的单元测试。\n光讲这段话可能有些抽象，我们来看这样的场景。比如，我写了一个下面这个函数，对一个数组进行处理，并返回新的数组：\ndef work(arr):\r# pre process\r...\r...\r# sort\rl = len(arr)\rfor i in range(0, l):\rfor j in range(i + 1, j):\rif arr[i] \u003e= arr[j]:\rtmp = arr[i]\rarr[i] = arr[j]\rarr[j] = tmp\r# post process\r...\r...\rReturn arr 这段代码的大概意思是，先有个预处理，再排序，最后再处理一下然后返回。如果现在要求你，给这个函数写个单元测试，你是不是会一筹莫展呢？\n毕竟，这个函数确实有点儿复杂，以至于你都不知道应该是怎样的输入，并要期望怎样的输出。这种代码写单元测试是非常痛苦的，更别谈cover每条语句的要求了。\n所以，正确的测试方法，应该是先模块化代码，写成下面的形式：\ndef preprocess(arr):\r...\r...\rreturn arr\rdef sort(arr):\r...\r...\rreturn arr\rdef postprocess(arr):\r...\rreturn arr\rdef work(self):\rarr = preprocess(arr)\rarr = sort(arr)\rarr = postprocess(arr)\rreturn arr 接着再进行相应的测试，测试三个子函数的功能正确性；然后通过mock子函数，调用work()函数，来验证三个子函数被call过。\nfrom unittest.mock import patch\rdef test_preprocess(self):\r...\rdef test_sort(self):\r...\rdef test_postprocess(self):\r...\r@patch('%s.preprocess')\r@patch('%s.sort')\r@patch('%s.postprocess')\rdef test_work(self,mock_post_process, mock_sort, mock_preprocess):\rwork()\rself.assertTrue(mock_post_process.called)\rself.assertTrue(mock_sort.called)\rself.assertTrue(mock_preprocess.called) 你看，这样一来，通过重构代码就可以使单元测试更加全面、精确，并且让整体架构、函数设计都美观了不少。\n总结 link回顾下这节课，整体来看，单元测试的理念是先模块化代码设计，然后针对每个作用单元，编写单独的测试去验证其准确性。更好的模块化设计和更多的Test Coverage，是提高代码质量的核心。而单元测试的本质就是通过mock，去除掉不影响测试的依赖项，把重点放在需要测试的代码核心逻辑上。\n讲了这么多，还是想告诉你，单元测试是个非常非常重要的技能，在实际工作中是保证代码质量和准确性必不可少的一环。同时，单元测试的设计技能，不只是适用于Python，而是适用于任何语言。所以，单元测试必不可少。\n思考题 link那么，你在平时的学习工作中，曾经写过单元测试吗？在编写单元测试时，用到过哪些技巧或者遇到过哪些问题吗？欢迎留言与我交流，也欢迎你把这篇文章分享出去。\n在写UT的时候，编写对平台的mock即可。2019-08-07KaitoShy 👍（7） 💬（4）后面有几个代码没怎么看懂，希望老师详细说明一下： 1） from unittest.mock import patch\n@patch('sort') def test_sort(self, mock_sort): … 文档上说这个是个patch()里面是个类,但老师这里表达的是函数？ 2） @patch('%s.preprocess') 这个又是表达的什么的，运行后ModuleNotFoundError: No module named '%s'。 所以烦请老师把这块详细说明一下，不然感觉还是不怎么会使用2019-07-17hello,everyone 👍（5） 💬（0）从来没写过单元测试，在jupyter notebook 做数据分析，每步都会有结果出来，根据结果做修改，请问这样的数据分析，有必要写单元测试吗？或者数据分析过程有什么好的测试方法，感觉有时候花好长时间完成一个特征的处理，发现结果与预期不一致，很是头疼。2019-07-28magician 👍（5） 💬（0）requests 测试api2019-07-25zengyunda 👍（4） 💬（0）从来没有写过单元测试的人表示很忧伤2019-07-25武瑞霞 👍（3） 💬（0）mock下的side effect和patch，这两个完全茫然啊，希望老师能详细介绍并示范下实践运用！2020-04-14夜路破晓 👍（3） 💬（0）认知层次决定了效率高低。 虽然作为小白代码部分看得一脸懵逼，但完全get到了测试单元属于高级思维运用的高级方法与技能，因为它不仅要求代码设计拥有模块化理念的底层逻辑，还提倡代码不只是满足产品功能需求更要求持续稳定高效。 这就是码农与非码农的认知差距。2019-07-17\n"
            }
        );
    index.add(
            {
                id:  13 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/31---pdb--cprofile%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E6%B3%95%E5%AE%9D\/",
                title: "31 - pdb \u0026 cProfile：调试和性能分析的法宝",
                description: "你好，我是景霄。\n在实际生产环境中，对代码进行调试和性能分析，是一个永远都逃不开的话题。调试和性能分析的主要场景，通常有这么三个：\n一是代码本身有问题，需要我们找到root cause并修复； 二是代码效率有问题，比如过度浪费资源，增加latency，因此需要我们debug； 三是在开发新的feature时，一般都需要测试。 在遇到这些场景时，究竟应该使用哪些工具，如何正确的使用这些工具，应该遵循什么样的步骤等等，就是这节课我们要讨论的话题。\n用pdb进行代码调试 linkpdb的必要性 link首先，我们来看代码的调试。也许不少人会有疑问：代码调试？说白了不就是在程序中使用print()语句吗？\n没错，在程序中相应的地方打印，的确是调试程序的一个常用手段，但这只适用于小型程序。因为你每次都得重新运行整个程序，或是一个完整的功能模块，才能看到打印出来的变量值。如果程序不大，每次运行都非常快，那么使用print()，的确是很方便的。\n但是，如果我们面对的是大型程序，运行一次的调试成本很高。特别是对于一些tricky的例子来说，它们通常需要反复运行调试、追溯上下文代码，才能找到错误根源。这种情况下，仅仅依赖打印的效率自然就很低了。\n我们可以想象下面这个场景。比如你最常使用的极客时间App，最近出现了一个bug，部分用户无法登陆。于是，后端工程师们开始debug。\n他们怀疑错误的代码逻辑在某几个函数中，如果使用print()语句debug，很可能出现的场景是，工程师们在他们认为的10个最可能出现bug的地方，都使用print()语句，然后运行整个功能块代码（从启动到运行花了5min），看打印出来的结果值，是不是和预期相符。\n如果结果值和预期相符，并能直接找到错误根源，显然是最好的。但实际情况往往是，\n要么与预期并不相符，需要重复以上步骤，继续debug； 要么虽说与预期相符，但前面的操作只是缩小了错误代码的范围，所以仍得继续添加print()语句，再一次运行相应的代码模块（又要5min），进行debug。 你可以看到，这样的效率就很低下了。哪怕只是遇到稍微复杂一点的case，两、三个工程师一下午的时间可能就没了。\n可能又有人会说，现在很多的IDE不都有内置的debug工具吗？\n这话说的也没错。比如我们常用的Pycharm，可以很方便地在程序中设置断点。这样程序只要运行到断点处，便会自动停下，你就可以轻松查看环境中各个变量的值，并且可以执行相应的语句，大大提高了调试的效率。\n看到这里，你不禁会问，既然问题都解决了，那为什么还要学习pdb呢？其实在很多大公司，产品的创造与迭代，往往需要很多编程语言的支持；并且，公司内部也会开发很多自己的接口，尝试把尽可能多的语言给结合起来。\n这就使得，很多情况下，单一语言的IDE，对混合代码并不支持UI形式的断点调试功能，或是只对某些功能模块支持。另外，考虑到不少代码已经挪到了类似Jupyter的Notebook中，往往就要求开发者使用命令行的形式，来对代码进行调试。\n而Python的pdb，正是其自带的一个调试库。它为Python程序提供了交互式的源代码调试功能，是命令行版本的IDE断点调试器，完美地解决了我们刚刚讨论的这个问题。\n如何使用pdb link了解了pdb的重要性与必要性后，接下来，我们就一起来看看，pdb在Python中到底应该如何使用。\n首先，要启动pdb调试，我们只需要在程序中，加入“import pdb”和“pdb.set_trace()”这两行代码就行了，比如下面这个简单的例子：\na = 1\rb = 2\rimport pdb\rpdb.set_trace()\rc = 3\rprint(a + b + c) 当我们运行这个程序时时，它的输出界面是下面这样的，表示程序已经运行到了“pdb.set_trace()”这行，并且暂停了下来，等待用户输入。\n\u003e /Users/jingxiao/test.py(5)()\r-\u003e c = 3 这时，我们就可以执行，在IDE断点调试器中可以执行的一切操作，比如打印，语法是\"p \"：\n(pdb) p a\r1\r(pdb) p b\r2 你可以看到，我打印的是a和b的值，分别为1和2，与预期相符。为什么不打印c呢？显然，打印c会抛出异常，因为程序目前只运行了前面几行，此时的变量c还没有被定义：\n",
                content: "你好，我是景霄。\n在实际生产环境中，对代码进行调试和性能分析，是一个永远都逃不开的话题。调试和性能分析的主要场景，通常有这么三个：\n一是代码本身有问题，需要我们找到root cause并修复； 二是代码效率有问题，比如过度浪费资源，增加latency，因此需要我们debug； 三是在开发新的feature时，一般都需要测试。 在遇到这些场景时，究竟应该使用哪些工具，如何正确的使用这些工具，应该遵循什么样的步骤等等，就是这节课我们要讨论的话题。\n用pdb进行代码调试 linkpdb的必要性 link首先，我们来看代码的调试。也许不少人会有疑问：代码调试？说白了不就是在程序中使用print()语句吗？\n没错，在程序中相应的地方打印，的确是调试程序的一个常用手段，但这只适用于小型程序。因为你每次都得重新运行整个程序，或是一个完整的功能模块，才能看到打印出来的变量值。如果程序不大，每次运行都非常快，那么使用print()，的确是很方便的。\n但是，如果我们面对的是大型程序，运行一次的调试成本很高。特别是对于一些tricky的例子来说，它们通常需要反复运行调试、追溯上下文代码，才能找到错误根源。这种情况下，仅仅依赖打印的效率自然就很低了。\n我们可以想象下面这个场景。比如你最常使用的极客时间App，最近出现了一个bug，部分用户无法登陆。于是，后端工程师们开始debug。\n他们怀疑错误的代码逻辑在某几个函数中，如果使用print()语句debug，很可能出现的场景是，工程师们在他们认为的10个最可能出现bug的地方，都使用print()语句，然后运行整个功能块代码（从启动到运行花了5min），看打印出来的结果值，是不是和预期相符。\n如果结果值和预期相符，并能直接找到错误根源，显然是最好的。但实际情况往往是，\n要么与预期并不相符，需要重复以上步骤，继续debug； 要么虽说与预期相符，但前面的操作只是缩小了错误代码的范围，所以仍得继续添加print()语句，再一次运行相应的代码模块（又要5min），进行debug。 你可以看到，这样的效率就很低下了。哪怕只是遇到稍微复杂一点的case，两、三个工程师一下午的时间可能就没了。\n可能又有人会说，现在很多的IDE不都有内置的debug工具吗？\n这话说的也没错。比如我们常用的Pycharm，可以很方便地在程序中设置断点。这样程序只要运行到断点处，便会自动停下，你就可以轻松查看环境中各个变量的值，并且可以执行相应的语句，大大提高了调试的效率。\n看到这里，你不禁会问，既然问题都解决了，那为什么还要学习pdb呢？其实在很多大公司，产品的创造与迭代，往往需要很多编程语言的支持；并且，公司内部也会开发很多自己的接口，尝试把尽可能多的语言给结合起来。\n这就使得，很多情况下，单一语言的IDE，对混合代码并不支持UI形式的断点调试功能，或是只对某些功能模块支持。另外，考虑到不少代码已经挪到了类似Jupyter的Notebook中，往往就要求开发者使用命令行的形式，来对代码进行调试。\n而Python的pdb，正是其自带的一个调试库。它为Python程序提供了交互式的源代码调试功能，是命令行版本的IDE断点调试器，完美地解决了我们刚刚讨论的这个问题。\n如何使用pdb link了解了pdb的重要性与必要性后，接下来，我们就一起来看看，pdb在Python中到底应该如何使用。\n首先，要启动pdb调试，我们只需要在程序中，加入“import pdb”和“pdb.set_trace()”这两行代码就行了，比如下面这个简单的例子：\na = 1\rb = 2\rimport pdb\rpdb.set_trace()\rc = 3\rprint(a + b + c) 当我们运行这个程序时时，它的输出界面是下面这样的，表示程序已经运行到了“pdb.set_trace()”这行，并且暂停了下来，等待用户输入。\n\u003e /Users/jingxiao/test.py(5)()\r-\u003e c = 3 这时，我们就可以执行，在IDE断点调试器中可以执行的一切操作，比如打印，语法是\"p \"：\n(pdb) p a\r1\r(pdb) p b\r2 你可以看到，我打印的是a和b的值，分别为1和2，与预期相符。为什么不打印c呢？显然，打印c会抛出异常，因为程序目前只运行了前面几行，此时的变量c还没有被定义：\n(pdb) p c\r*** NameError: name 'c' is not defined 除了打印，常见的操作还有“n”，表示继续执行代码到下一行，用法如下：\n(pdb) n\r-\u003e print(a + b + c) 而命令”l“，则表示列举出当前代码行上下的11行源代码，方便开发者熟悉当前断点周围的代码状态：\n(pdb) l\r1 a = 1\r2 b = 2\r3 import pdb\r4 pdb.set_trace()\r5 -\u003e\tc = 3\r6 print(a + b + c) 命令“s“，就是 step into 的意思，即进入相对应的代码内部。这时，命令行中会显示”--Call--“的字样，当你执行完内部的代码块后，命令行中则会出现”--Return--“的字样。\n我们来看下面这个例子：\ndef func():\rprint('enter func()')\ra = 1\rb = 2\rimport pdb\rpdb.set_trace()\rfunc()\rc = 3\rprint(a + b + c)\r# pdb\r\u003e /Users/jingxiao/test.py(9)()\r-\u003e func()\r(pdb) s\r--Call--\r\u003e /Users/jingxiao/test.py(1)func()\r-\u003e def func():\r(Pdb) l\r1 -\u003e\tdef func():\r2 print('enter func()')\r3\r4\r5 a = 1\r6 b = 2\r7 import pdb\r8 pdb.set_trace()\r9 func()\r10 c = 3\r11 print(a + b + c)\r(Pdb) n\r\u003e /Users/jingxiao/test.py(2)func()\r-\u003e print('enter func()')\r(Pdb) n\renter func()\r--Return--\r\u003e /Users/jingxiao/test.py(2)func()-\u003eNone\r-\u003e print('enter func()')\r(Pdb) n\r\u003e /Users/jingxiao/test.py(10)()\r-\u003e c = 3 这里，我们使用命令”s“进入了函数func()的内部，显示”--Call--“；而当我们执行完函数func()内部语句并跳出后，显示”--Return--“。\n另外，\n与之相对应的命令”r“，表示step out，即继续执行，直到当前的函数完成返回。 命令”b [ ([filename:]lineno | function) [, condition] ]“可以用来设置断点。比方说，我想要在代码中的第10行，再加一个断点，那么在pdb模式下输入”b 11“即可。 而”c“则表示一直执行程序，直到遇到下一个断点。 当然，除了这些常用命令，还有许多其他的命令可以使用，这里我就不在一一赘述了。你可以参考对应的官方文档（https://docs.python.org/3/library/pdb.html#module-pdb），来熟悉这些用法。\n用cProfile进行性能分析 link关于调试的内容，我主要先讲这么多。事实上，除了要对程序进行调试，性能分析也是每个开发者的必备技能。\n日常工作中，我们常常会遇到这样的问题：在线上，我发现产品的某个功能模块效率低下，延迟（latency）高，占用的资源多，但却不知道是哪里出了问题。\n这时，对代码进行profile就显得异常重要了。\n这里所谓的profile，是指对代码的每个部分进行动态的分析，比如准确计算出每个模块消耗的时间等。这样你就可以知道程序的瓶颈所在，从而对其进行修正或优化。当然，这并不需要你花费特别大的力气，在Python中，这些需求用cProfile就可以实现。\n举个例子，比如我想计算斐波拉契数列，运用递归思想，我们很容易就能写出下面这样的代码：\ndef fib(n):\rif n == 0:\rreturn 0\relif n == 1:\rreturn 1\relse:\rreturn fib(n-1) + fib(n-2)\rdef fib_seq(n):\rres = []\rif n \u003e 0:\rres.extend(fib_seq(n-1))\rres.append(fib(n))\rreturn res\rfib_seq(30) 接下来，我想要测试一下这段代码总的效率以及各个部分的效率。那么，我就只需在开头导入cProfile这个模块，并且在最后运行cProfile.run()就可以了：\nimport cProfile\r# def fib(n)\r# def fib_seq(n):\rcProfile.run('fib_seq(30)') 或者更简单一些，直接在运行脚本的命令中，加入选项“-m cProfile”也很方便：\npython3 -m cProfile xxx.py 运行完毕后，我们可以看到下面这个输出界面：\n这里有一些参数你可能比较陌生，我来简单介绍一下：\nncalls，是指相应代码/函数被调用的次数； tottime，是指对应代码/函数总共执行所需要的时间（注意，并不包括它调用的其他代码/函数的执行时间）； tottime percall，就是上述两者相除的结果，也就是tottime / ncalls； cumtime，则是指对应代码/函数总共执行所需要的时间，这里包括了它调用的其他代码/函数的执行时间； cumtime percall，则是cumtime和ncalls相除的平均结果。 了解这些参数后，再来看这张图。我们可以清晰地看到，这段程序执行效率的瓶颈，在于第二行的函数fib()，它被调用了700多万次。\n有没有什么办法可以提高改进呢？答案是肯定的。通过观察，我们发现，程序中有很多对fib()的调用，其实是重复的，那我们就可以用字典来保存计算过的结果，防止重复。改进后的代码如下所示：\ndef memoize(f):\rmemo = {}\rdef helper(x):\rif x not in memo: memo[x] = f(x)\rreturn memo[x]\rreturn helper\r@memoize\rdef fib(n):\rif n == 0:\rreturn 0\relif n == 1:\rreturn 1\relse:\rreturn fib(n-1) + fib(n-2)\rdef fib_seq(n):\rres = []\rif n \u003e 0:\rres.extend(fib_seq(n-1))\rres.append(fib(n))\rreturn res\rfib_seq(30) 这时，我们再对其进行profile，你就会得到新的输出结果，很明显，效率得到了极大的提高。\n这个简单的例子，便是cProfile的基本用法，也是我今天想讲的重点。当然，cProfile还有很多其他功能，还可以结合stats类来使用，你可以阅读相应的 官方文档 来了解。\n总结 link这节课，我们一起学习了Python中常用的调试工具pdb，和经典的性能分析工具cProfile。pdb为Python程序提供了一种通用的、交互式的高效率调试方案；而cProfile则是为开发者提供了每个代码块执行效率的详细分析，有助于我们对程序的优化与提高。\n关于它们的更多用法，你可以通过它们的官方文档进行实践，都不太难，熟能生巧。\n思考题 link最后，留一个开放性的交流问题。你在平时的工作中，常用的调试和性能分析工具是什么呢？有发现什么独到的使用技巧吗？你曾用到过pdb、cProfile或是其他相似的工具吗？\n欢迎在下方留言与我讨论，也欢迎你把这篇文章分享出去。我们一起交流，一起进步。\ndef all_fib(n): global dict1 res =[] for i in range(n + 1): req = fibl(i) dict1[i] = req res.append(req) print(res) all_fib(100000)\n老师用的装饰器很高大上(看了好几遍才搞明白), 但是当数字大于995后会有超过递归深度报错, 所以过来皮一下/狗头2019-08-14JackLee 👍（7） 💬（0）还有一个ipdb是pdb的加强版，用法比较相近，不过需要pip安装一下2019-07-19new 👍（6） 💬（0）老师应该在这里回顾一下装饰器的用法2019-07-22泥土  👍（5） 💬（3）看到memoize装饰器，想起装饰器那节中的LRU_CACHE，发现比memoize性能更高 import functools\n@memoize\n@functools.lru_cache(None) linkdef fib(n): …2020-03-24lipan 👍（5） 💬（1）最近在用js撸小程序，一个console.log()搞定所有调试。2019-07-19未来已来 👍（4） 💬（1）被最后那个装饰器惊艳到了，以前只知道用循环，没想到 Python 还可以这么玩2019-07-19向南 👍（3） 💬（0）有时候会用装饰器试一下 def timeit_wrapper(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.perf_counter() func_return_value = func(*args, **kwargs) end_time = time.perf_counter() print('{0:\u003c10}.{1:\u003c8} : {2:\u003c8}'.format(func.module, func.name, end_time - start_time)) return func_return_value return wrapper\n@timeit_wrapper def some_func(): ….2020-03-11一一 👍（3） 💬（0）cProfile真的太好用了2020-01-31\n"
            }
        );
    index.add(
            {
                id:  14 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/32---%E7%AD%94%E7%96%91%E4%B8%89%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F\/",
                title: "32 - 答疑（三）：如何选择合适的异常处理方式？",
                description: "你好，我是景霄。\n不知不觉中，我们又一起完成了第三大章规范篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。\n大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很典型的问题，我专门摘录了出来，作为今天的答疑内容，集中回复。\n问题一：应该使用哪种异常处理方式？ link 第一个问题是code2同学的疑惑。下面这两种处理的风格，哪一种风格更有效、更优雅？\n第一种，在代码中对数据进行检测，并直接处理与抛出异常。 第二种，在异常处理代码中进行处理。 其实，第一种方法，可以翻译成下面的“if…elif…”语句：\nif [condition1]:\rraise Exception1('exception 1')\relif [condition2]:\rraise Exception2('exception 2')\r... 而第二种方法，则对应着下面异常处理的代码：\ntry:\r...\rexcept Exception as e:\r... 这两种方法很大的一个区别是，第一种方法一旦抛出异常，那么程序就会终止；而在第二种方法中，如果抛出异常，会被程序捕获（catch），程序还会继续运行。这也是我们选择这两种方法的重要依据。当然，在实际工作中，到底使用哪一种方法，还是取决于具体的场景。\n比方说，一个模块的功能是对输入进行检测，如果输入不合法，则弹出对话框进行提示，并终止程序。那么，这种情况下，使用第一种方法更加合理。\n但是，如果换成一个产品的服务器端，它需要应对各种可能发生的情况，以保证服务器不崩溃。比如在连接数据库时，如果网络异常，无法连接，那就需要捕获（catch）这个异常（exception），进行记录，并同时保证其他功能不受影响。这种情况下，我们通常会选择第二种方式。\n问题二：先写出能跑起来的代码，后期再优化可以吗？ link 第二个问题，夜路破晓同学提到了很多程序员传授的“经验之谈”，即先写出能跑起来的代码，后期再优化。很明显，这种认知是错误的。我们从一开始写代码时，就必须对功能和规范这两者双管齐下。\n代码功能完整和规范完整的优先级是不分先后的，应该是同时进行的。如果你一开始只注重代码的功能完整，而不关注其质量、规范，那么规范问题很容易越积越多。这样就会导致产品的bug越来越多，相应的代码库越发难以维护，到最后不得已只能推倒重来。\n我在Facebook工作时就遇到过这样的情况，参与过类似的项目。当时，某些功能模块因为赶时间，code review很宽松，代码写得很不规范，留下了隐患。时间一长，bug越来越多，legacy越来越多。到最后，万分无奈的情况下，我们几个工程师专门立项，花了三个多月时间，重写了这一模块的代码，才解决了这个问题。\n问题三：代码中写多少注释才合适？ link 第三个问题，小侠龙旋风同学留言说，自己的同事要求代码中有70%的注释，这显然有点过了。但是反过来说，如果你的代码中没有注释或者注释很少，仅凭规范的变量名肯定是远远不够的。\n通常来说，我们会在类的开头、函数的开头或者是某一个功能块的开头加上一段描述性的注释，来说明这段代码的功能，并指明所有的输入和输出。除此之外，我们也要求在一些比较tricky的代码上方加上注释，帮助阅读者理解代码的含义。\n总的来说，代码中到底需要有多少注释，其实并没有一个统一的要求，还是要根据代码量和代码的复杂度来决定。不过，我们平常书写时，只要满足这样的规范就可以了。\n另外，必须提醒一点，如果在写好之后修改了代码，那么代码对应的注释一定也要做出相应的修改，不然很容易造成“文不对题”的现象，给别人也给你自己带来困扰。\n问题四：项目的API文档重要吗？ link 第四个问题，是未来已来同学的留言。他提到了项目的API文档的问题，这一点说得非常好，在这里我也简单介绍一下。\n我在专栏中主要讲的是代码的规范问题，但很多情况下，光有规范的代码还是远远不够的。因为一个系统，一个产品，甚至一个功能模块的代码，都有可能非常复杂。少则几千行，动辄几十万行，尤其是对于刚加入的新人来说，在ramp up阶段光看代码可能就是一个噩梦了。\n因此，在这方面做得比较规范的公司，通常也会要求书写文档。项目的文档，主要是对相应的系统、产品或是功能模块做一个概述，有助于后人理解。以一个service为例，其对应的文档通常会包括下面几部分：\n第一点，系统的概述，包括各个组成部分以及工作流程的介绍； 第二点，每个组成部分的具体介绍，包括必要性、设计原理等等； 第三点，系统的performance，包括latency等等参数； 第四点主要说明如何对系统的各个部分进行修改，主要给出相应的code pointer及对应的测试方案。 这些内容，也希望屏幕前的你能够牢记。\n今天我主要回答这些问题，同时也欢迎你继续在留言区写下疑问和感想，我会持续不断地解答。希望每一次的留言和答疑，都能给你带来新的收获和价值。\n",
                content: "你好，我是景霄。\n不知不觉中，我们又一起完成了第三大章规范篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。\n大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很典型的问题，我专门摘录了出来，作为今天的答疑内容，集中回复。\n问题一：应该使用哪种异常处理方式？ link 第一个问题是code2同学的疑惑。下面这两种处理的风格，哪一种风格更有效、更优雅？\n第一种，在代码中对数据进行检测，并直接处理与抛出异常。 第二种，在异常处理代码中进行处理。 其实，第一种方法，可以翻译成下面的“if…elif…”语句：\nif [condition1]:\rraise Exception1('exception 1')\relif [condition2]:\rraise Exception2('exception 2')\r... 而第二种方法，则对应着下面异常处理的代码：\ntry:\r...\rexcept Exception as e:\r... 这两种方法很大的一个区别是，第一种方法一旦抛出异常，那么程序就会终止；而在第二种方法中，如果抛出异常，会被程序捕获（catch），程序还会继续运行。这也是我们选择这两种方法的重要依据。当然，在实际工作中，到底使用哪一种方法，还是取决于具体的场景。\n比方说，一个模块的功能是对输入进行检测，如果输入不合法，则弹出对话框进行提示，并终止程序。那么，这种情况下，使用第一种方法更加合理。\n但是，如果换成一个产品的服务器端，它需要应对各种可能发生的情况，以保证服务器不崩溃。比如在连接数据库时，如果网络异常，无法连接，那就需要捕获（catch）这个异常（exception），进行记录，并同时保证其他功能不受影响。这种情况下，我们通常会选择第二种方式。\n问题二：先写出能跑起来的代码，后期再优化可以吗？ link 第二个问题，夜路破晓同学提到了很多程序员传授的“经验之谈”，即先写出能跑起来的代码，后期再优化。很明显，这种认知是错误的。我们从一开始写代码时，就必须对功能和规范这两者双管齐下。\n代码功能完整和规范完整的优先级是不分先后的，应该是同时进行的。如果你一开始只注重代码的功能完整，而不关注其质量、规范，那么规范问题很容易越积越多。这样就会导致产品的bug越来越多，相应的代码库越发难以维护，到最后不得已只能推倒重来。\n我在Facebook工作时就遇到过这样的情况，参与过类似的项目。当时，某些功能模块因为赶时间，code review很宽松，代码写得很不规范，留下了隐患。时间一长，bug越来越多，legacy越来越多。到最后，万分无奈的情况下，我们几个工程师专门立项，花了三个多月时间，重写了这一模块的代码，才解决了这个问题。\n问题三：代码中写多少注释才合适？ link 第三个问题，小侠龙旋风同学留言说，自己的同事要求代码中有70%的注释，这显然有点过了。但是反过来说，如果你的代码中没有注释或者注释很少，仅凭规范的变量名肯定是远远不够的。\n通常来说，我们会在类的开头、函数的开头或者是某一个功能块的开头加上一段描述性的注释，来说明这段代码的功能，并指明所有的输入和输出。除此之外，我们也要求在一些比较tricky的代码上方加上注释，帮助阅读者理解代码的含义。\n总的来说，代码中到底需要有多少注释，其实并没有一个统一的要求，还是要根据代码量和代码的复杂度来决定。不过，我们平常书写时，只要满足这样的规范就可以了。\n另外，必须提醒一点，如果在写好之后修改了代码，那么代码对应的注释一定也要做出相应的修改，不然很容易造成“文不对题”的现象，给别人也给你自己带来困扰。\n问题四：项目的API文档重要吗？ link 第四个问题，是未来已来同学的留言。他提到了项目的API文档的问题，这一点说得非常好，在这里我也简单介绍一下。\n我在专栏中主要讲的是代码的规范问题，但很多情况下，光有规范的代码还是远远不够的。因为一个系统，一个产品，甚至一个功能模块的代码，都有可能非常复杂。少则几千行，动辄几十万行，尤其是对于刚加入的新人来说，在ramp up阶段光看代码可能就是一个噩梦了。\n因此，在这方面做得比较规范的公司，通常也会要求书写文档。项目的文档，主要是对相应的系统、产品或是功能模块做一个概述，有助于后人理解。以一个service为例，其对应的文档通常会包括下面几部分：\n第一点，系统的概述，包括各个组成部分以及工作流程的介绍； 第二点，每个组成部分的具体介绍，包括必要性、设计原理等等； 第三点，系统的performance，包括latency等等参数； 第四点主要说明如何对系统的各个部分进行修改，主要给出相应的code pointer及对应的测试方案。 这些内容，也希望屏幕前的你能够牢记。\n今天我主要回答这些问题，同时也欢迎你继续在留言区写下疑问和感想，我会持续不断地解答。希望每一次的留言和答疑，都能给你带来新的收获和价值。\n"
            }
        );
    index.add(
            {
                id:  15 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/33---%E5%B8%A6%E4%BD%A0%E5%88%9D%E6%8E%A2%E9%87%8F%E5%8C%96%E4%B8%96%E7%95%8C\/",
                title: "33 - 带你初探量化世界",
                description: "你好，我是景霄。\n在2000 年顶峰时期，高盛雇佣了 600 名交易员为机构客户买卖现金股票。可如今，这个数字只有 2 名（Ref. 经济学人）。到了2009 年，金融危机余音未散，专家面对股票和证券交易中越来越多的机器参与提出了警告，因为机器的崛起，逐渐导致了手操交易工作的消失。\n很久之前，瑞银集团（UBS）的交易大厅是下面这样的：\n8 年之后，交易大厅就已经只有这些人了：\n事实上，随着数据处理技术的飞速发展，和量化交易模型研究理论的逐渐成熟，现金股票交易、债券市场、期货市场以及投行的相当一部分业务，都在朝着自动化的方向迈进。\n而发展到2017 年，WannyCry 席卷全球，随之而来的比特币，在短短几个月内从小众玩家走入了公众视野，币价也是一飞冲天，很多炒币的人赚得盆满钵满。更有一部分人，将金融业的量化策略应用其中，无论是搬砖（套利），还是波段，在不成熟的市场初期都赚了个爽快。\n这节课开始，我们就来探索一下量化的世界。作为我们 Python 专栏的综合实践模块，希望你能在这一部分内容中，收获自己独特的东西。\n交易是什么？ link市场，是人类有史以来最伟大的发明之一。亚当·斯密在国富论中，用“看不见的手”这个概念，生动形象地阐释了市场和理性人之间是如何交互，最终让整个社会受益的。\n而市场的核心，是交换。人类发展最开始是物物交换，原始的“以物易物”的方式产生于货币诞生之前。不过，这种方式非常低效，不便于流通交换，经常会出现的情况是，要走很长的交换链条才能拿到自己想要的物品。于是，一般等价物出现了，社会分工也逐渐出现了。人们把自己生产的商品换成一般等价物，然后再换成自己需要的其他商品。\n而交换的核心，就是买和卖。当买卖双方对价格预期相等的时候，交易达成。随着金融和技术的发展，逐渐出现了股票、债券、期权、期货等越来越多的金融工具，金融衍生品也朝着复杂的方向发展。\n在我们经常听到的投资银行中，量化基金交易员这种角色，所做的事情，就是在这些复杂的衍生品基础上，分析投资标的的价值，然后以某种策略来管理持有仓位，进行买进和卖出。\n为什么交易能赚钱，是很多人疑惑不解的地方。市场究竟有没有规律可循呢？可以肯定是有的，但虽有迹可循却无法可依。交易的多样性和人性的复杂性，使得金融数据的噪音极大，我们无法简单地从某一两个因子来确定地推导行情变化。\n所以交易员这个行业本身，对自身素质要求是极高的。除了要具备扎实的专业素养（包括金融功底、数理逻辑、分析能力、决策能力），对心理素质的要求也非常高。这种直接和钱打交道、并直面人性深处欲望的行业，也因此吸引了无数高手的参与，很多人因此暴富，也有不少人破产，一无所有。\n那么，有什么办法可以规避这种，因为心理素质原因带来的风险呢？\n量化交易 link回答这个问题之前，我先插一句题外话。刚接触量化交易的朋友，都很容易被这几个词绕晕：量化交易（Quantitative Trading）、程序化交易（Program Trading）、算法交易（Algo-Trading）、高频交易（High Frequency Trading）和自动化交易平台（Automated Trading System）。\n虽然我遇到过不少行业内的人也混用这词，但是作为初学者来说，厘清这些术语还是很有帮助的。至少，在别人说出这些高大上的词时，我们心里不用犯怵了。\n先来看程序化交易，它通常用计算机程序代替交易员，来具体执行金融产品的买卖。比如，一个基金经理需要卖出大量股票。如果直接挂一个大的卖单，可能会影响市场，那就用计算机程序拆分成小单慢慢执行。所以，量化交易的下层通常是程序交易。\n而算法交易通常用于高频交易中。它指的是，通过算法快速判定买卖的时间点，快速买卖多个产品。\n量化交易则通常是指使用数学、统计甚至机器学习的方法，去找寻合适的买卖时机。所以，在这个维度的定义之下，算法交易、高频交易还有统计套利（Statistical Arbitrage）都可以算作量化交易。\n简单而言，我们可以认为量化交易的涵盖范围最大。因此，当你不确定用哪个词的时候，用量化交易就行了。\n回到我们刚刚的问题，规避心理素质原因带来的风险的方法，自然就是量化交易了。量化交易的好处显而易见。最直观来看，计算机不眠不休，不需要交易员实时操盘，满足了人们“躺着挣钱”的愿景。当然，这只是美好的想象，真要这么做的话，不久之后就要回工地搬砖了。现实场景中，成熟的量化交易也需要有人蹲守，适时干预，防止算法突然失效造成巨额的交易亏损。\n在数字货币领域的交易，这一点更加显著。数字货币的交易在全球许多交易所进行，和股票不同，一支股票可能只在少数几个交易所交易，而一种数字货币可以在所有的交易所同时进行交易。同时，因为没有股市的开盘、收盘限制，数字货币的交易通常是 7 x 24 小时不眠不休，比前世的 “996 福报”凶残多了。要是真有交易员能在这个市场活下来，我们尊称一声“神仙”也不为过了。\n多交易所交易，也意味着全球数字货币市场每时每刻都是紧密相连的。一个市场、一个局部的巨大变动，都会影响所有的市场。比如，2017年朝鲜氢弹炸了的当天，新闻还没出来，隔壁韩国、日本的比特币价格马上拉升了一波；再比如，当比特币的负面消息半夜里传出来的时候，其价格也马上跟着暴跌一波。\n2019年6月比特币在全球头部交易所的价格\n因此，我们经常看到比特币的价格波动巨大。很有可能今天还是财富自由状态，明天的财富就没那么自由了。显然，在这种市场中交易，人力很难持久支撑，而量化交易就很合适了。\n通常的电子盘交易（比如股票，数字货币），是通过券商或者软件，直接把买卖请求发送给交易所；而算法交易的底层，就是让程序来自动实现这类操作。券商或者交易所，通常也会提供API接口给投资者。比如，盈透证券（Interactive Broker）的接口，就可以支持股票、期权的行情数据获取和交易；而 Gemini、OKCoin等交易所，也提供了对应的接口进行数字货币行情获取和交易。\nGemini交易所的公开行情API，就可以通过下面这种简单的HTTP GET请求，来获取最近的比特币（BTC）对美元（USD）的价格和最近的成交量。\n",
                content: "你好，我是景霄。\n在2000 年顶峰时期，高盛雇佣了 600 名交易员为机构客户买卖现金股票。可如今，这个数字只有 2 名（Ref. 经济学人）。到了2009 年，金融危机余音未散，专家面对股票和证券交易中越来越多的机器参与提出了警告，因为机器的崛起，逐渐导致了手操交易工作的消失。\n很久之前，瑞银集团（UBS）的交易大厅是下面这样的：\n8 年之后，交易大厅就已经只有这些人了：\n事实上，随着数据处理技术的飞速发展，和量化交易模型研究理论的逐渐成熟，现金股票交易、债券市场、期货市场以及投行的相当一部分业务，都在朝着自动化的方向迈进。\n而发展到2017 年，WannyCry 席卷全球，随之而来的比特币，在短短几个月内从小众玩家走入了公众视野，币价也是一飞冲天，很多炒币的人赚得盆满钵满。更有一部分人，将金融业的量化策略应用其中，无论是搬砖（套利），还是波段，在不成熟的市场初期都赚了个爽快。\n这节课开始，我们就来探索一下量化的世界。作为我们 Python 专栏的综合实践模块，希望你能在这一部分内容中，收获自己独特的东西。\n交易是什么？ link市场，是人类有史以来最伟大的发明之一。亚当·斯密在国富论中，用“看不见的手”这个概念，生动形象地阐释了市场和理性人之间是如何交互，最终让整个社会受益的。\n而市场的核心，是交换。人类发展最开始是物物交换，原始的“以物易物”的方式产生于货币诞生之前。不过，这种方式非常低效，不便于流通交换，经常会出现的情况是，要走很长的交换链条才能拿到自己想要的物品。于是，一般等价物出现了，社会分工也逐渐出现了。人们把自己生产的商品换成一般等价物，然后再换成自己需要的其他商品。\n而交换的核心，就是买和卖。当买卖双方对价格预期相等的时候，交易达成。随着金融和技术的发展，逐渐出现了股票、债券、期权、期货等越来越多的金融工具，金融衍生品也朝着复杂的方向发展。\n在我们经常听到的投资银行中，量化基金交易员这种角色，所做的事情，就是在这些复杂的衍生品基础上，分析投资标的的价值，然后以某种策略来管理持有仓位，进行买进和卖出。\n为什么交易能赚钱，是很多人疑惑不解的地方。市场究竟有没有规律可循呢？可以肯定是有的，但虽有迹可循却无法可依。交易的多样性和人性的复杂性，使得金融数据的噪音极大，我们无法简单地从某一两个因子来确定地推导行情变化。\n所以交易员这个行业本身，对自身素质要求是极高的。除了要具备扎实的专业素养（包括金融功底、数理逻辑、分析能力、决策能力），对心理素质的要求也非常高。这种直接和钱打交道、并直面人性深处欲望的行业，也因此吸引了无数高手的参与，很多人因此暴富，也有不少人破产，一无所有。\n那么，有什么办法可以规避这种，因为心理素质原因带来的风险呢？\n量化交易 link回答这个问题之前，我先插一句题外话。刚接触量化交易的朋友，都很容易被这几个词绕晕：量化交易（Quantitative Trading）、程序化交易（Program Trading）、算法交易（Algo-Trading）、高频交易（High Frequency Trading）和自动化交易平台（Automated Trading System）。\n虽然我遇到过不少行业内的人也混用这词，但是作为初学者来说，厘清这些术语还是很有帮助的。至少，在别人说出这些高大上的词时，我们心里不用犯怵了。\n先来看程序化交易，它通常用计算机程序代替交易员，来具体执行金融产品的买卖。比如，一个基金经理需要卖出大量股票。如果直接挂一个大的卖单，可能会影响市场，那就用计算机程序拆分成小单慢慢执行。所以，量化交易的下层通常是程序交易。\n而算法交易通常用于高频交易中。它指的是，通过算法快速判定买卖的时间点，快速买卖多个产品。\n量化交易则通常是指使用数学、统计甚至机器学习的方法，去找寻合适的买卖时机。所以，在这个维度的定义之下，算法交易、高频交易还有统计套利（Statistical Arbitrage）都可以算作量化交易。\n简单而言，我们可以认为量化交易的涵盖范围最大。因此，当你不确定用哪个词的时候，用量化交易就行了。\n回到我们刚刚的问题，规避心理素质原因带来的风险的方法，自然就是量化交易了。量化交易的好处显而易见。最直观来看，计算机不眠不休，不需要交易员实时操盘，满足了人们“躺着挣钱”的愿景。当然，这只是美好的想象，真要这么做的话，不久之后就要回工地搬砖了。现实场景中，成熟的量化交易也需要有人蹲守，适时干预，防止算法突然失效造成巨额的交易亏损。\n在数字货币领域的交易，这一点更加显著。数字货币的交易在全球许多交易所进行，和股票不同，一支股票可能只在少数几个交易所交易，而一种数字货币可以在所有的交易所同时进行交易。同时，因为没有股市的开盘、收盘限制，数字货币的交易通常是 7 x 24 小时不眠不休，比前世的 “996 福报”凶残多了。要是真有交易员能在这个市场活下来，我们尊称一声“神仙”也不为过了。\n多交易所交易，也意味着全球数字货币市场每时每刻都是紧密相连的。一个市场、一个局部的巨大变动，都会影响所有的市场。比如，2017年朝鲜氢弹炸了的当天，新闻还没出来，隔壁韩国、日本的比特币价格马上拉升了一波；再比如，当比特币的负面消息半夜里传出来的时候，其价格也马上跟着暴跌一波。\n2019年6月比特币在全球头部交易所的价格\n因此，我们经常看到比特币的价格波动巨大。很有可能今天还是财富自由状态，明天的财富就没那么自由了。显然，在这种市场中交易，人力很难持久支撑，而量化交易就很合适了。\n通常的电子盘交易（比如股票，数字货币），是通过券商或者软件，直接把买卖请求发送给交易所；而算法交易的底层，就是让程序来自动实现这类操作。券商或者交易所，通常也会提供API接口给投资者。比如，盈透证券（Interactive Broker）的接口，就可以支持股票、期权的行情数据获取和交易；而 Gemini、OKCoin等交易所，也提供了对应的接口进行数字货币行情获取和交易。\nGemini交易所的公开行情API，就可以通过下面这种简单的HTTP GET请求，来获取最近的比特币（BTC）对美元（USD）的价格和最近的成交量。\n########## GEMINI行情接口 ##########\r## https://api.gemini.com/v1/pubticker/:symbol\rimport json\rimport requests\rgemini_ticker = 'https://api.gemini.com/v1/pubticker/{}'\rsymbol = 'btcusd'\rbtc_data = requests.get(gemini_ticker.format(symbol)).json()\rprint(json.dumps(btc_data, indent=4))\r########## 输出 ##########\r{\r\"bid\": \"8825.88\",\r\"ask\": \"8827.52\",\r\"volume\": {\r\"BTC\": \"910.0838782726\",\r\"USD\": \"7972904.560901317851\",\r\"timestamp\": 1560643800000\r},\r\"last\": \"8838.45\"\r} 对算法交易系统来说，API只是最下层的结构。通常而言，一个基本的交易系统应该包括：行情模块、策略模块和执行模块。为了辅助策略的开发，通常还有回测系统辅助。它们的分工示意图大致如下：\n其中，\n行情模块的主要功能是，尝试获取市场的行情数据，通常也负责获取交易账户的状态。 策略模块的主要功能是，订阅市场的数据，根据设定的算法发出买、卖指令给执行模块。 执行模块的主要功能是，接受并把策略模块发过来的买、卖指令封装并转发到交易所；同时，监督并确保策略买卖的完整执行。 Python算法交易 link了解了这么多关于量化交易的知识，接下来我们就来说说Python算法交易。Python 在金融行业的许多方面都有用到，在算法交易领域，更是发挥了日益重要的作用。 Python 之所以能在这个行业这么流行，主要是因为下面四个原因。\n数据分析能力 link第一个原因，是Python的数据分析能力。算法交易领域的一个基本需求，就是高效数据处理能力，而数据处理则是Python的强项。特别是NumPy+Pandas的组合，简直让算法交易开发者的生活质量直线上升。\n我们可以用一个简单的例子来展示一下，如何抓取、格式化和绘制，比特币过去一个小时在Gemini交易所的价格曲线。相关的代码我都附了详细注释，这里就不再多讲，你阅读了解一下即可。\nimport matplotlib.pyplot as plt\rimport pandas as pd\rimport requests\r# 选择要获取的数据时间段\rperiods = '3600'\r# 通过Http抓取btc历史价格数据\rresp = requests.get('https://api.cryptowat.ch/markets/gemini/btcusd/ohlc', params={\r'periods': periods\r})\rdata = resp.json()\r# 转换成pandas data frame\rdf = pd.DataFrame(\rdata['result'][periods], columns=[\r'CloseTime',\r'OpenPrice',\r'HighPrice',\r'LowPrice',\r'ClosePrice',\r'Volume',\r'NA'])\r# 输出DataFrame的头部几行\rprint(df.head())\r# 绘制btc价格曲线\rdf['ClosePrice'].plot(figsize=(14, 7))\rplt.show()\r########### 输出 ###############\rCloseTime OpenPrice HighPrice ... ClosePrice Volume NA\r0 1558843200 8030.55 8046.30 ... 8011.20 11.642968 93432.459964\r1 1558846800 8002.76 8050.33 ... 8034.48 8.575682 68870.145895\r2 1558850400 8031.61 8036.14 ... 8000.00 15.659680 125384.519063\r3 1558854000 8000.00 8016.29 ... 8001.46 38.171420 304342.048892\r4 1558857600 8002.69 8023.11 ... 8009.24 3.582830 28716.385009 通过执行这样的一段代码，我们便可以得到下面这张图所示的价格曲线。\n大量专有库 link除了强大的数据处理能力之外，Python 还有许许多多已经开发成熟的算法交易库可供使用。比如，你可以使用Zipline进行策略回测，或者用Pyfolio进行投资组合分析。而许多交易所也都提供了基于Python的API客户端。\n便利的交易平台 link第三个原因，是因为便利的交易平台。有一些算法交易平台可以执行自定义 Python 策略，无需搭建量化交易框架。算法交易平台，实际上等效于帮用户完成了行情模块和执行模块。用户只需要在其中定义策略模块，即可进行算法交易和回测。\n比如，Quantopian，就提供了基于Zipline的标准回测环境。用户可以选择Python作为开发语言，并且和社区的网友分享自己的策略。此外，国内也有诸如BigQuant、果仁网等类似平台，提供不同市场和金融产品的交易。\n广泛的行业应用 link最后一个原因，则是Python本身广泛的行业应用了。目前，越来越多投资机构的交易部门，都开始使用Python，因此也对优秀的Python开发者产生了更多的需求。自然，这也让学习Python，成为了更有意义的“投资”。\n总结 link这一节课，我们介绍了交易，以及算法交易中的基本概念，也简单介绍了为什么要学习 Python 来搭建量化交易系统。量化交易是交易行业的大趋势；同时， Python 作为最适合量化从业者的语言之一，对于初学者而言也有着非常重要的地位。\n接下来的几节课，我们将从细节深入量化交易的每一个模块，由浅入深地为你揭开量化交易神秘的面纱。\n思考题 link最后给你留一道思考题。高频交易和中低频交易，哪个更适合使用 Python？为什么？欢迎在留言区写下你的想法，也欢迎你把这篇文章分享给更多对量化交易感兴趣的人，我们一起交流和探讨。\n"
            }
        );
    index.add(
            {
                id:  16 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/34---restful--socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83\/",
                title: "34 - RESTful \u0026 Socket：搭建交易执行层核心",
                description: "你好，我是景霄。\n上一节，我们简单介绍了量化交易的历史、严谨的定义和它的基本组成结构。有了这些高层次的基本知识，接下来我们就分模块，开始讲解量化交易系统中具体的部分。\n从这节课开始，我们将实打实地从代码出发，一步步设计出一套清晰完整、易于理解的量化交易系统。\n一个量化交易系统，可以说是一个黑箱。这个黑箱连接交易所获取到的数据，通过策略运算，然后再连接交易所进行下单操作。正如我们在输入输出那节课说的那样，黑箱的特性是输入和输出。每一个设计网络交互的同学，都需要在大脑中形成清晰的交互状态图：\n知道包是怎样在网络间传递的； 知道每一个节点是如何处理不同的输入包，然后输出并分发给下一级的。 在你搞不明白的时候，可以先在草稿纸上画出交互拓扑图，标注清楚每个节点的输入和输出格式，然后想清楚网络是怎么流动的。这一点，对网络编程至关重要。\n现在，我假设你对网络编程只有很基本的了解。所以接下来，我将先从 REST 的定义讲起，然后过渡到具体的交互方式——如何通过 Python 和交易所进行交互，从而执行下单、撤单、查询订单等网络交互方式。\nREST 简介 link什么是 REST API？什么是 Socket？有过网络编程经验的同学，一定对这两个词汇不陌生。\nREST的全称是表征层状态转移（REpresentational State Transfer），本意是指一种操作资源方法。不过，你不用纠结于这个绕口的名字。换种方式来说，REST的实质可以理解为：通过URL定位资源，用GET、POST、PUT、DELETE等动词来描述操作。而满足REST要求的接口，就被称为RESTful的接口。\n为了方便你更容易理解这些概念，这里我举个例子来类比。小明同学不是很聪明但很懂事，每天会在他的妈妈下班回来后给妈妈泡茶。刚开始，他的妈妈会发出这样的要求：\n用红色杯子，去厨房泡一杯放了糖的37.5度的普洱茶。\n可是小明同学不够聪明，很难理解这个定语很多的句子。于是，他妈妈为了让他更简单明白需要做的事情，把这个指令设计成了更简洁的样子：\n泡厨房的茶，要求如下：\n类型=普洱； 杯子=红色； 放糖=True； 温度=37.5度。 这里的“茶”就是资源，“厨房的茶”就是资源的地址（URI）；“泡”是动词；后面的要求，都是接口参数。这样的一个接口，就是小明提供的一个REST接口。\n如果小明是一台机器，那么解析这个请求就会非常容易；而我们作为维护者，查看小明的代码也很简单。当小明把这个接口暴露到网上时，这就是一个RESTful的接口。\n总的来说，RESTful接口通常以HTTP GET和POST形式出现。但并非所有的GET、POST请求接口，都是RESTful的接口。\n这话可能有些拗口，我们举个例子来看。上节课中，我们获取了Gemini交易所中，BTC对USD价格的ticker接口：\nGET https://api.gemini.com/v1/pubticker/btcusd 这里的“GET”是动词，后边的URI是“Ticker”这个资源的地址。所以，这是一个RESTful的接口。\n但下面这样的接口，就不是一个严格的RESTful接口：\nPOST https://api.restful.cn/accounts/delete/:username 因为URI中包含动词“delete”（删除），所以这个URI并不是指向一个资源。如果要修改成严格的RESTful接口，我们可以把它改成下面这样：\nDELETE https://api.rest.cn/accounts/:username 然后，我们带着这个观念去看Gemini的取消订单接口：\nPOST https://api.gemini.com/v1/order/cancel 你会发现，这个接口不够“RESTful”的地方有：\n动词设计不准确，接口使用“POST”而不是重用HTTP动词“DELETE”； URI里包含动词cancel； ID代表的订单是资源，但订单ID是放在参数列表而不是URI里的，因此URI并没有指向资源。 所以严格来说，这不是一个RESTful的接口。\n此外，如果我们去检查Gemini的其他私有接口（Private，私有接口是指需要附加身份验证信息才能访问的接口），我们会发现，那些接口的设计都不是严格RESTful的。不仅如此，大部分的交易所，比如Bitmex、Bitfinex、OKCoin等等，它们提供的“REST接口”，也都不是严格RESTful的。这些接口之所以还能被称为“REST接口”，是因为他们大部分满足了REST接口的另一个重要要求：无状态。\n无状态的意思是，每个REST请求都是独立的，不需要服务器在会话（Session）中缓存中间状态来完成这个请求。简单来说，如果服务器A接收到请求的时候宕机了，而此时把这个请求发送给交易所的服务器B，也能继续完成，那么这个接口就是无状态的。\n这里，我再给你举一个简单的有状态的接口的例子。服务器要求，在客户端请求取消订单的时候，必须发送两次不一样的HTTP请求。并且，第一次发送让服务器“等待取消”；第二次发送“确认取消”。那么，就算这个接口满足了RESTful的动词、资源分离原则，也不是一个REST接口。\n当然，对于交易所的REST接口，你并不需要过于纠结“RESTful”这个概念，否则很容易就被这些名词给绕晕了。你只需要把握住最核心的一点：一个HTTP请求完成一次完整操作。\n交易所 API 简介 link现在，你对 REST 和 Web Socket 应该有一个大致了解了吧。接下来，我们就开始做点有意思的事情。\n",
                content: "你好，我是景霄。\n上一节，我们简单介绍了量化交易的历史、严谨的定义和它的基本组成结构。有了这些高层次的基本知识，接下来我们就分模块，开始讲解量化交易系统中具体的部分。\n从这节课开始，我们将实打实地从代码出发，一步步设计出一套清晰完整、易于理解的量化交易系统。\n一个量化交易系统，可以说是一个黑箱。这个黑箱连接交易所获取到的数据，通过策略运算，然后再连接交易所进行下单操作。正如我们在输入输出那节课说的那样，黑箱的特性是输入和输出。每一个设计网络交互的同学，都需要在大脑中形成清晰的交互状态图：\n知道包是怎样在网络间传递的； 知道每一个节点是如何处理不同的输入包，然后输出并分发给下一级的。 在你搞不明白的时候，可以先在草稿纸上画出交互拓扑图，标注清楚每个节点的输入和输出格式，然后想清楚网络是怎么流动的。这一点，对网络编程至关重要。\n现在，我假设你对网络编程只有很基本的了解。所以接下来，我将先从 REST 的定义讲起，然后过渡到具体的交互方式——如何通过 Python 和交易所进行交互，从而执行下单、撤单、查询订单等网络交互方式。\nREST 简介 link什么是 REST API？什么是 Socket？有过网络编程经验的同学，一定对这两个词汇不陌生。\nREST的全称是表征层状态转移（REpresentational State Transfer），本意是指一种操作资源方法。不过，你不用纠结于这个绕口的名字。换种方式来说，REST的实质可以理解为：通过URL定位资源，用GET、POST、PUT、DELETE等动词来描述操作。而满足REST要求的接口，就被称为RESTful的接口。\n为了方便你更容易理解这些概念，这里我举个例子来类比。小明同学不是很聪明但很懂事，每天会在他的妈妈下班回来后给妈妈泡茶。刚开始，他的妈妈会发出这样的要求：\n用红色杯子，去厨房泡一杯放了糖的37.5度的普洱茶。\n可是小明同学不够聪明，很难理解这个定语很多的句子。于是，他妈妈为了让他更简单明白需要做的事情，把这个指令设计成了更简洁的样子：\n泡厨房的茶，要求如下：\n类型=普洱； 杯子=红色； 放糖=True； 温度=37.5度。 这里的“茶”就是资源，“厨房的茶”就是资源的地址（URI）；“泡”是动词；后面的要求，都是接口参数。这样的一个接口，就是小明提供的一个REST接口。\n如果小明是一台机器，那么解析这个请求就会非常容易；而我们作为维护者，查看小明的代码也很简单。当小明把这个接口暴露到网上时，这就是一个RESTful的接口。\n总的来说，RESTful接口通常以HTTP GET和POST形式出现。但并非所有的GET、POST请求接口，都是RESTful的接口。\n这话可能有些拗口，我们举个例子来看。上节课中，我们获取了Gemini交易所中，BTC对USD价格的ticker接口：\nGET https://api.gemini.com/v1/pubticker/btcusd 这里的“GET”是动词，后边的URI是“Ticker”这个资源的地址。所以，这是一个RESTful的接口。\n但下面这样的接口，就不是一个严格的RESTful接口：\nPOST https://api.restful.cn/accounts/delete/:username 因为URI中包含动词“delete”（删除），所以这个URI并不是指向一个资源。如果要修改成严格的RESTful接口，我们可以把它改成下面这样：\nDELETE https://api.rest.cn/accounts/:username 然后，我们带着这个观念去看Gemini的取消订单接口：\nPOST https://api.gemini.com/v1/order/cancel 你会发现，这个接口不够“RESTful”的地方有：\n动词设计不准确，接口使用“POST”而不是重用HTTP动词“DELETE”； URI里包含动词cancel； ID代表的订单是资源，但订单ID是放在参数列表而不是URI里的，因此URI并没有指向资源。 所以严格来说，这不是一个RESTful的接口。\n此外，如果我们去检查Gemini的其他私有接口（Private，私有接口是指需要附加身份验证信息才能访问的接口），我们会发现，那些接口的设计都不是严格RESTful的。不仅如此，大部分的交易所，比如Bitmex、Bitfinex、OKCoin等等，它们提供的“REST接口”，也都不是严格RESTful的。这些接口之所以还能被称为“REST接口”，是因为他们大部分满足了REST接口的另一个重要要求：无状态。\n无状态的意思是，每个REST请求都是独立的，不需要服务器在会话（Session）中缓存中间状态来完成这个请求。简单来说，如果服务器A接收到请求的时候宕机了，而此时把这个请求发送给交易所的服务器B，也能继续完成，那么这个接口就是无状态的。\n这里，我再给你举一个简单的有状态的接口的例子。服务器要求，在客户端请求取消订单的时候，必须发送两次不一样的HTTP请求。并且，第一次发送让服务器“等待取消”；第二次发送“确认取消”。那么，就算这个接口满足了RESTful的动词、资源分离原则，也不是一个REST接口。\n当然，对于交易所的REST接口，你并不需要过于纠结“RESTful”这个概念，否则很容易就被这些名词给绕晕了。你只需要把握住最核心的一点：一个HTTP请求完成一次完整操作。\n交易所 API 简介 link现在，你对 REST 和 Web Socket 应该有一个大致了解了吧。接下来，我们就开始做点有意思的事情。\n首先，我来介绍一下交易所是什么。区块链交易所是个撮合交易平台： 它兼容了传统撮合规则撮合引擎，将资金托管和交割方式替换为区块链。数字资产交易所，则是一个中心化的平台，通过 Web 页面或 PC、手机客户端的形式，让用户将数字资产充值到指定钱包地址（交易所创建的钱包），然后在平台挂买单、卖单以实现数字资产之间的兑换。\n通俗来说，交易所就是一个买和卖的菜市场。有人在摊位上大声喊着：“二斤羊肉啊，二斤羊肉，四斤牛肉来换！”这种人被称为 maker（挂单者）。有的人则游走于不同摊位，不动声色地掏出两斤牛肉，顺手拿走一斤羊肉。这种人被称为 taker（吃单者）。\n交易所存在的意义，一方面是为 maker 和 taker 提供足够的空间活动；另一方面，让一个名叫撮合引擎的玩意儿，尽可能地把单子撮合在一起，然后收取一定比例的保护费…啊不对，是手续费，从而保障游戏继续进行下去。\n市场显然是个很伟大的发明，这里我们就不进行更深入的哲学讨论了。\n然后，我再来介绍一个叫作 Gemini 的交易所。Gemini，双子星交易所，全球首个获得合法经营许可的、首个推出期货合约的、专注于撮合大宗交易的数字货币交易所。Gemini 位于纽约，是一家数字货币交易所和托管机构，允许客户交易和存储数字资产，并直接受纽约州金融服务部门（NYDFS）的监管。\nGemini 的界面清晰，API 完整而易用，更重要的是，还提供了完整的测试网络，也就是说，功能和正常的 Gemini 完全一样。但是他家的交易采用虚拟币，非常方便从业者在平台上进行对接测试。\n另一个做得很好的交易所，是 Bitmex，他家的 API UI 界面和测试网络也是币圈一流。不过，鉴于这家是期货交易所，对于量化初学者来说有一定的门槛，我们还是选择 Gemini 更方便一些。\n在进入正题之前，我们最后再以比特币和美元之间的交易为例，介绍四个基本概念（orderbook 的概念这里就不介绍了，你也不用深究，你只需要知道比特币的价格是什么就行了）。\n买（buy）：用美元买入比特币的行为。 卖（sell）：用比特币换取美元的行为。 市价单（market order）：给交易所一个方向（买或者卖）和一个数量，交易所把给定数量的美元（或者比特币）换成比特币（或者美元）的单子。 限价单（limit order）：给交易所一个价格、一个方向（买或者卖）和一个数量，交易所在价格达到给定价格的时候，把给定数量的美元（或者比特币）换成比特币（或者美元）的单子。 这几个概念都不难懂。其中，市价单和限价单，最大的区别在于，限价单多了一个给定价格。如何理解这一点呢？我们可以来看下面这个例子。\n小明在某一天中午12:00:00，告诉交易所，我要用1000美元买比特币。交易所收到消息，在 12:00:01 回复小明，现在你的账户多了 0.099 个比特币，少了 1000 美元，交易成功。这是一个市价买单。\n而小强在某一天中午 11:59:00，告诉交易所，我要挂一个单子，数量为 0.1 比特币，1个比特币的价格为 10000 美元，低于这个价格不卖。交易所收到消息，在11:59:01 告诉小强，挂单成功，你的账户余额中 0.1 比特币的资金被冻结。又过了一分钟，交易所告诉小强，你的单子被完全执行了（fully executed），现在你的账户多了 1000 美元，少了 0.1 个比特币。这就是一个限价卖单。\n（这里肯定有人发现不对了：貌似少了一部分比特币，到底去哪儿了呢？嘿嘿，你不妨自己猜猜看。）\n显然，市价单，在交给交易所后，会立刻得到执行，当然执行价格也并不受你的控制。它很快，但是也非常不安全。而限价单，则限定了交易价格和数量，安全性相对高很多。缺点呢，自然就是如果市场朝相反方向走，你挂的单子可能没有任何人去接，也就变成了干吆喝却没人买。因为我没有讲解 orderbook，所以这里的说辞不完全严谨，但是对于初学者理解今天的内容，已经够用了。\n储备了这么久的基础知识，想必你已经跃跃欲试了吧？下面，我们正式进入正题，手把手教你使用API下单。\n手把手教你使用 API 下单 link手动挂单显然太慢，也不符合量化交易的初衷。我们就来看看如何用代码实现自动化下单吧。\n第一步，你需要做的是，注册一个 Gemini Sandbox 账号。请放心，这个测试账号不需要你充值任何金额，注册后即送大量虚拟现金。这口吻是不是听着特像网游宣传语，接下来就是“快来贪玩蓝月里找我吧”？哈哈，不过这个设定确实如此，所以赶紧来注册一个吧。\n注册后，为了满足好奇，你可以先尝试着使用 Web 界面自行下单。不过，事实上，未解锁的情况下是无法正常下单的，因此这样尝试并没啥太大意义。\n所以第二步，我们需要来配置 API Key。菜单栏User Settings-\u003eAPI Settings，然后点 GENERATE A NEW ACCOUNT API KEY，记下 Key 和 Secret 这两串字符。因为窗口一旦消失，这两个信息就再也找不到了，需要你重新生成。\n配置到此结束。接下来，我们来看具体实现。\n先强调一点，在量化系统开发的时候，你的心中一定要有清晰的数据流图。下单逻辑是一个很简单的 RESTful 的过程，和你在网页操作的一样，构造你的请求订单、加密请求，然后 POST 给 gemini 交易所即可。\n不过，因为涉及到的知识点较多，带你一步一步从零来写代码显然不太现实。所以，我们采用“先读懂后记忆并使用”的方法来学，下面即为这段代码：\nimport requests\rimport json\rimport base64\rimport hmac\rimport hashlib\rimport datetime\rimport time\rbase_url = \"https://api.sandbox.gemini.com\"\rendpoint = \"/v1/order/new\"\rurl = base_url + endpoint\rgemini_api_key = \"account-zmidXEwP72yLSSybXVvn\"\rgemini_api_secret = \"375b97HfE7E4tL8YaP3SJ239Pky9\".encode()\rt = datetime.datetime.now()\rpayload_nonce = str(int(time.mktime(t.timetuple())*1000))\rpayload = {\r\"request\": \"/v1/order/new\",\r\"nonce\": payload_nonce,\r\"symbol\": \"btcusd\",\r\"amount\": \"5\",\r\"price\": \"3633.00\",\r\"side\": \"buy\",\r\"type\": \"exchange limit\",\r\"options\": [\"maker-or-cancel\"]\r}\rencoded_payload = json.dumps(payload).encode()\rb64 = base64.b64encode(encoded_payload)\rsignature = hmac.new(gemini_api_secret, b64, hashlib.sha384).hexdigest()\rrequest_headers = {\r'Content-Type': \"text/plain\",\r'Content-Length': \"0\",\r'X-GEMINI-APIKEY': gemini_api_key,\r'X-GEMINI-PAYLOAD': b64,\r'X-GEMINI-SIGNATURE': signature,\r'Cache-Control': \"no-cache\"\r}\rresponse = requests.post(url,\rdata=None,\rheaders=request_headers)\rnew_order = response.json()\rprint(new_order)\r########## 输出 ##########\r{'order_id': '239088767', 'id': '239088767', 'symbol': 'btcusd', 'exchange': 'gemini', 'avg_execution_price': '0.00', 'side': 'buy', 'type': 'exchange limit', 'timestamp': '1561956976', 'timestampms': 1561956976535, 'is_live': True, 'is_cancelled': False, 'is_hidden': False, 'was_forced': False, 'executed_amount': '0', 'remaining_amount': '5', 'options': ['maker-or-cancel'], 'price': '3633.00', 'original_amount': '5'} 我们来深入看一下这段代码。\nRESTful 的 POST 请求，通过 requests.post 来实现。post 接受三个参数，url、data 和 headers。\n这里的 url 等价于 https://api.sandbox.gemini.com/v1/order/new，但是在代码中分两部分写。第一部分是交易所 API 地址；第二部分，以斜杠开头，用来表示统一的 API endpoint。我们也可以在其他交易所的 API 中看到类似的写法，两者连接在一起，就构成了最终的 url。\n而接下来大段命令的目的，是为了构造 request_headers。\n这里我简单说一下 HTTP request，这是互联网中基于 TCP 的基础协议。HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。而 TCP（Transmission Control Protocol）则是面向连接的、可靠的、基于字节流的传输层通信协议。\n多提一句，如果你开发网络程序，建议利用闲暇时间认真读一读《计算机网络：自顶向下方法》这本书，它也是国内外计算机专业必修课中广泛采用的课本之一。一边学习，一边应用，对于初学者的能力提升是全面而充分的。\n回到 HTTP，它的主要特点是，连接简单、灵活，可以使用“简单请求，收到回复，然后断开连接”的方式，也是一种无状态的协议，因此充分符合 RESTful 的思想。\nHTTP 发送需要一个请求头（request header），也就是代码中的 request_headers，用 Python 的语言表示，就是一个 str 对 str 的字典。\n这个字典里，有一些字段有特殊用途， 'Content-Type': \"text/plain\" 和 'Content-Length': \"0\" 描述 Content 的类型和长度，这里的 Content 对应于参数 data。但是 Gemini 这里的 request 的 data 没有任何用处，因此长度为 0。\n还有一些其他字段，例如 'keep-alive' 来表示连接是否可持续化等，你也可以适当注意一下。要知道，网络编程很多 bug 都会出现在不起眼的细节之处。\n继续往下走看代码。payload 是一个很重要的字典，它用来存储下单操作需要的所有的信息，也就是业务逻辑信息。这里我们可以下一个 limit buy，限价买单，价格为 3633 刀。\n另外，请注意 nonce，这是个很关键并且在网络通信中很常见的字段。\n因为网络通信是不可靠的，一个信息包有可能会丢失，也有可能重复发送，在金融操作中，这两者都会造成很严重的后果。丢包的话，我们重新发送就行了；但是重复的包，我们需要去重。虽然 TCP 在某种程度上可以保证，但为了在应用层面进一步减少错误发生的机会，Gemini 交易所要求所有的通信 payload 必须带有 nonce。\nnonce 是个单调递增的整数。当某个后来的请求的 nonce，比上一个成功收到的请求的 nouce 小或者相等的时候，Gemini 便会拒绝这次请求。这样一来，重复的包就不会被执行两次了。另一方面，这样也可以在一定程度上防止中间人攻击：\n一则是因为 nonce 的加入，使得加密后的同样订单的加密文本完全混乱； 二则是因为，这会使得中间人无法通过“发送同样的包来构造重复订单”进行攻击。 这样的设计思路是不是很巧妙呢？这就相当于每个包都增加了一个身份识别，可以极大地提高安全性。希望你也可以多注意，多思考一下这些巧妙的用法。\n接下来的代码就很清晰了。我们要对 payload 进行 base64 和 sha384 算法非对称加密，其中 gemini_api_secret 为私钥；而交易所存储着公钥，可以对你发送的请求进行解密。最后，代码再将加密后的请求封装到 request_headers 中，发送给交易所，并收到 response，这个订单就完成了。\n总结 link这节课我们介绍了什么是 RESTful API，带你了解了交易所的 RESTful API 是如何工作的，以及如何通过 RESTful API 来下单。同时，我简单讲述了网络编程中的一些技巧操作，希望你在网络编程中要注意思考每一个细节，尽可能在写代码之前，对业务逻辑和具体的技术细节有足够清晰的认识。\n下一节，我们同样将从 Web Socket 的定义开始，讲解量化交易中数据模块的具体实现。\n思考题 link最后留一个思考题。今天的内容里，能不能使用 timestamp 代替 nonce？为什么？欢迎留言写下你的思考，也欢迎你把这篇文章分享出去。\n思考题： 测试了一下timestamp效果，代码如下： import time import datetime current_time = datetime.datetime.now() print(int(datetime.datetime.timestamp(current_time)*1000)) print(int(time.mktime(current_time.timetuple())*1000))\n同样都是时间戳，timestamp是带毫秒的，具备单调递增、加密混乱的特质。 文中有句话是这么说的：\"当某个后来请求的nonce比上一个成功收到的请求的nonce小或者相等的时候，Gemini便会拒绝这次请求\"。 说明Gemini不希望http请求在一秒内发生多次。应该是反爬用的吧~ 用timestamp是可以精确到毫秒的，意味着每毫秒可以请求发送的nonce都不一样。\n另外，作为taker第二次运行该代码就报出下面的错： { \"result\": \"error\", \"reason\": \"InsufficientFunds\", \"message\": \"Failed to place buy order on symbol 'BTCUSD' for price $3,633.00 and quantity 5 BTC due to insufficient funds\" }2019-07-27瞳梦 👍（3） 💬（4）请问gemini sandbox账号怎么注册呢？我在官网只找到了Open a Personal Account和I Represent an Institution2019-07-26Xg huang 👍（1） 💬（1）哈哈，深入浅出，赞一个\n不过有个地方是否写错？\"而小宝在某一天中午 11:59:00，告诉交易所，我要挂一个单子，数量为 0.1 比特币，价格为 10000 美元，低于这个价格不卖。\"\n是不是1000才对？2019-07-26王帅帅 👍（0） 💬（1）我跑了一遍，提示gemini 交易所正在维护，怎么回事。2020-01-13SCAR 👍（13） 💬（0）思考题：\n纯粹使用timestamp应该不行，虽然timestamp也是递增的，但是在python里timestamp是float而不是int。 2.但如果基于timestamp抽取出部分应该是可以，比如老师例子中的： payload_nonce = str(int(time.mktime(t.timetuple())*1000)) 改成： payload_nonce = str(int(t.timestamp())*1000) 结果应该是一致的。2019-07-26Monroe He 👍（7） 💬（2）我想问一下老师，有针对国内股票的虚拟交易平台吗 可以提供一下相关方面的书籍资料吗2019-07-26devna 👍（6） 💬（0）前段时间刚看完《计算机网络：自顶自下方法》，确实不错，能很快提升对网络的认识，强烈推荐2020-01-19karofsky 👍（4） 💬（0）今天再看这篇文章的感受就是，BTC真的涨了好多啊…2021-01-12kang 👍（3） 💬（6）請問大家都是怎麼註冊Genimi 的? 我的註冊國家都被阻擋2019-08-23马建华 👍（2） 💬（3）我是报错： {'result': 'error', 'reason': 'MissingAccounts', 'message': 'Expected a JSON payload with accounts'} 有谁碰到吗？2020-07-20及時行樂 👍（2） 💬（0）现在程序跑起来都报错了，这是交易所把API地址改了吗？ {'result': 'error', 'reason': 'EndpointMismatch', 'message': 'EndpointMismatch'}2020-05-13知止。 👍（1） 💬（2）老师，是不是该针对运行可能出现的一些问题给出解答呢？如果网站变更过信息，那么课件相应也得更新一下吧，不然后来订阅学习的人没办法完整学习啊。比如我按照课件内容运行，提示{'result': 'error', 'reason': 'InvalidSignature', 'message': 'InvalidSignature'}，网上都找不到原因，想自己排查错误都不懂如何着手 "
            }
        );
    index.add(
            {
                id:  17 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/35---restful--socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96\/",
                title: "35 - RESTful \u0026 Socket：行情数据对接和抓取",
                description: "你好，我是景霄。\n上一节课，我们介绍了交易所的交易模式，数字货币交易所RESTful接口的常见概念，以及如何调用RESTful接口进行订单操作。众所周知，买卖操作的前提，是你需要已知市场的最新情况。这节课里，我将介绍交易系统底层另一个最重要的部分，行情数据的对接和抓取。\n行情数据，最重要的是实时性和有效性。市场的情况瞬息万变，合适的买卖时间窗口可能只有几秒。在高频交易里，合适的买卖机会甚至在毫秒级别。要知道，一次从北京发往美国的网络请求，即使是光速传播，都需要几百毫秒的延迟。更别提用Python这种解释型语言，建立HTTP连接导致的时间消耗。\n经过上节课的学习，你对交易应该有了基本的了解，这也是我们今天学习的基础。接下来，我们先从交易所撮合模式讲起，然后介绍行情数据有哪些；之后，我将带你基于Websocket的行情数据来抓取模块。\n行情数据 link回顾上一节我们提到的，交易所是一个买方、卖方之间的公开撮合平台。买卖方把需要/可提供的商品数量和愿意出/接受的价格提交给交易所，交易所按照公平原则进行撮合交易。\n那么撮合交易是怎么进行的呢？假设你是一个人肉比特币交易所，大量的交易订单往你这里汇总，你应该如何选择才能让交易公平呢？\n显然，最直观的操作就是，把买卖订单分成两个表，按照价格由高到低排列。下面的图，就是买入和卖出的委托表。\n如果最高的买入价格小于最低的卖出价格，那就不会有任何交易发生。这通常是你看到的委托列表的常态。\n如果最高的买入价格和最低的卖出价格相同，那么就尝试进行撮合。比如BTC在9002.01就会发生撮合，最后按照9002.01的价格，成交0.0330个BTC。当然，交易完成后，小林未完成部分的订单（余下0.1126 - 0.0330 = 0.0796 个 BTC 未卖出），还会继续在委托表里。\n不过你可能会想，如果买入和卖出的价格有交叉，那么成交价格又是什么呢？事实上，这种情况并不会发生。我们来试想一下下面这样的场景。\n如果你尝试给一个委托列表里加入一个新买入订单，它的价格比所有已有的最高买入价格高，也比所有的卖出价格高。那么此时，它会直接从最低的卖出价格撮合。等到最低价格的卖出订单吃完了，它便开始吃价格第二低的卖出订单，直到这个买入订单完全成交。反之亦然。所以，委托列表价格不会出现交叉。\n当然，请注意，这里我说的只是限价订单的交易方式。而对于市价订单，交易规则会有一些轻微的区别，这里我就不详细解释了，主要是让你有个概念。\n其实说到这里，所谓的“交易所行情”概念就呼之欲出了。交易所主要有两种行情数据：委托账本（Order Book）和活动行情（Tick data）。\n我们把委托表里的具体用户隐去，相同价格的订单合并，就得到了下面这种委托账本。我们主要观察右边的数字部分，其中：\n上半部分里，第一列红色数字代表BTC的卖出价格，中间一列数字是这个价格区间的订单BTC总量，最右边一栏是从最低卖出价格到当前价格区间的积累订单量。 中间的大字部分，9994.10 USD是当前的市场价格，也就是上一次成交交易的价格。 下面绿色部分的含义与上半部分类似，不过指的是买入委托和对应的数量。 Gemini的委托账本，来自https://cryptowat.ch\n",
                content: "你好，我是景霄。\n上一节课，我们介绍了交易所的交易模式，数字货币交易所RESTful接口的常见概念，以及如何调用RESTful接口进行订单操作。众所周知，买卖操作的前提，是你需要已知市场的最新情况。这节课里，我将介绍交易系统底层另一个最重要的部分，行情数据的对接和抓取。\n行情数据，最重要的是实时性和有效性。市场的情况瞬息万变，合适的买卖时间窗口可能只有几秒。在高频交易里，合适的买卖机会甚至在毫秒级别。要知道，一次从北京发往美国的网络请求，即使是光速传播，都需要几百毫秒的延迟。更别提用Python这种解释型语言，建立HTTP连接导致的时间消耗。\n经过上节课的学习，你对交易应该有了基本的了解，这也是我们今天学习的基础。接下来，我们先从交易所撮合模式讲起，然后介绍行情数据有哪些；之后，我将带你基于Websocket的行情数据来抓取模块。\n行情数据 link回顾上一节我们提到的，交易所是一个买方、卖方之间的公开撮合平台。买卖方把需要/可提供的商品数量和愿意出/接受的价格提交给交易所，交易所按照公平原则进行撮合交易。\n那么撮合交易是怎么进行的呢？假设你是一个人肉比特币交易所，大量的交易订单往你这里汇总，你应该如何选择才能让交易公平呢？\n显然，最直观的操作就是，把买卖订单分成两个表，按照价格由高到低排列。下面的图，就是买入和卖出的委托表。\n如果最高的买入价格小于最低的卖出价格，那就不会有任何交易发生。这通常是你看到的委托列表的常态。\n如果最高的买入价格和最低的卖出价格相同，那么就尝试进行撮合。比如BTC在9002.01就会发生撮合，最后按照9002.01的价格，成交0.0330个BTC。当然，交易完成后，小林未完成部分的订单（余下0.1126 - 0.0330 = 0.0796 个 BTC 未卖出），还会继续在委托表里。\n不过你可能会想，如果买入和卖出的价格有交叉，那么成交价格又是什么呢？事实上，这种情况并不会发生。我们来试想一下下面这样的场景。\n如果你尝试给一个委托列表里加入一个新买入订单，它的价格比所有已有的最高买入价格高，也比所有的卖出价格高。那么此时，它会直接从最低的卖出价格撮合。等到最低价格的卖出订单吃完了，它便开始吃价格第二低的卖出订单，直到这个买入订单完全成交。反之亦然。所以，委托列表价格不会出现交叉。\n当然，请注意，这里我说的只是限价订单的交易方式。而对于市价订单，交易规则会有一些轻微的区别，这里我就不详细解释了，主要是让你有个概念。\n其实说到这里，所谓的“交易所行情”概念就呼之欲出了。交易所主要有两种行情数据：委托账本（Order Book）和活动行情（Tick data）。\n我们把委托表里的具体用户隐去，相同价格的订单合并，就得到了下面这种委托账本。我们主要观察右边的数字部分，其中：\n上半部分里，第一列红色数字代表BTC的卖出价格，中间一列数字是这个价格区间的订单BTC总量，最右边一栏是从最低卖出价格到当前价格区间的积累订单量。 中间的大字部分，9994.10 USD是当前的市场价格，也就是上一次成交交易的价格。 下面绿色部分的含义与上半部分类似，不过指的是买入委托和对应的数量。 Gemini的委托账本，来自https://cryptowat.ch\n这张图中，最低的卖出价格比最高的买入价格要高 6.51 USD，这个价差通常被称为Spread。这里验证了我们前面提到的，委托账本的价格永不交叉； 同时，Spread很小也能说明这是一个非常活跃的交易所。\n每一次撮合发生，意味着一笔交易（Trade）的发生。卖方买方都很开心，于是交易所也很开心地通知行情数据的订阅者：刚才发生了一笔交易，交易的价格是多少，成交数量是多少。这个数据就是活动行情Tick。\n有了这些数据，我们也就掌握了这个交易所的当前状态，可以开始搞事情了。\nWebsocket介绍 link在本文的开头我们提到过：行情数据很讲究时效性。所以，行情从交易所产生到传播给我们的程序之间的延迟，应该越低越好。通常，交易所也提供了REST的行情数据抓取接口。比如下面这段代码：\nimport requests\rimport timeit\rdef get_orderbook():\rorderbook = requests.get(\"https://api.gemini.com/v1/book/btcusd\").json()\rn = 10\rlatency = timeit.timeit('get_orderbook()', setup='from __main__ import get_orderbook', number=n) * 1.0 / n\rprint('Latency is {} ms'.format(latency * 1000))\r###### 输出 #######\rLatency is 196.67642089999663 ms 我在美国纽约附近城市的一个服务器上测试了这段代码，你可以看到，平均每次访问orderbook的延迟有0.25秒左右。显然，如果在国内，这个延迟只会更大。按理说，这两个美国城市的距离很短，为什么延迟会这么大呢？\n这是因为，REST接口本质上是一个HTTP接口，在这之下是TCP/TLS套接字（Socket）连接。每一次REST请求，通常都会重新建立一次TCP/TLS握手；然后，在请求结束之后，断开这个链接。这个过程，比我们想象的要慢很多。\n举个例子来验证这一点，在同一个城市我们试验一下。我从纽约附近的服务器和Gemini在纽约的服务器进行连接，TCP/SSL握手花了多少时间呢？\ncurl -w \"TCP handshake: %{time_connect}s, SSL handshake: %{time_appconnect}s\\n\" -so /dev/null https://www.gemini.com\rTCP handshake: 0.072758s, SSL handshake: 0.119409s 结果显示，HTTP连接构建的过程，就占了一大半时间！也就是说，我们每次用REST请求，都要浪费一大半的时间在和服务器建立连接上，这显然是非常低效的。很自然的你会想到，我们能否实现一次连接、多次通信呢？\n事实上，Python的某些HTTP请求库，也可以支持重用底层的TCP/SSL连接。但那种方法，一来比较复杂，二来也需要服务器的支持。该怎么办呢？其实，在有WebSocket的情况下，我们完全不需要舍近求远。\n我先来介绍一下WebSocket。WebSocket是一种在单个TCP/TLS连接上，进行全双工、双向通信的协议。WebSocket可以让客户端与服务器之间的数据交换变得更加简单高效，服务端也可以主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以直接创建持久性的连接，并进行双向数据传输。\n概念听着很痛快，不过还是有些抽象。为了让你快速理解刚刚的这段话，我们还是来看两个简单的例子。二话不说，先看一段代码：\nimport websocket\rimport thread\r# 在接收到服务器发送消息时调用\rdef on_message(ws, message):\rprint('Received: ' + message)\r# 在和服务器建立完成连接时调用 def on_open(ws):\r# 线程运行函数\rdef gao():\r# 往服务器依次发送0-4，每次发送完休息0.01秒\rfor i in range(5):\rtime.sleep(0.01)\rmsg=\"{0}\".format(i)\rws.send(msg)\rprint('Sent: ' + msg)\r# 休息1秒用于接收服务器回复的消息\rtime.sleep(1)\r# 关闭Websocket的连接\rws.close()\rprint(\"Websocket closed\")\r# 在另一个线程运行gao()函数\rthread.start_new_thread(gao, ())\rif __name__ == \"__main__\":\rws = websocket.WebSocketApp(\"ws://echo.websocket.org/\",\ron_message = on_message,\ron_open = on_open)\rws.run_forever()\r#### 输出 #####\rSent: 0\rSent: 1\rReceived: 0\rSent: 2\rReceived: 1\rSent: 3\rReceived: 2\rSent: 4\rReceived: 3\rReceived: 4\rWebsocket closed 这段代码尝试和wss://echo.websocket.org建立连接。当连接建立的时候，就会启动一条线程，连续向服务器发送5条消息。\n通过输出可以看出，我们在连续发送的同时，也在不断地接受消息。这并没有像REST一样，每发送一个请求，要等待服务器完成请求、完全回复之后，再进行下一个请求。换句话说，我们在请求的同时也在接受消息，这也就是前面所说的”全双工“。\nREST（HTTP）单工请求响应的示意图\nWebsocket全双工请求响应的示意图\n再来看第二段代码。为了解释”双向“，我们来看看获取Gemini的委托账单的例子。\nimport ssl\rimport websocket\rimport json\r# 全局计数器\rcount = 5\rdef on_message(ws, message):\rglobal count\rprint(message)\rcount -= 1\r# 接收了5次消息之后关闭websocket连接\rif count == 0:\rws.close()\rif __name__ == \"__main__\":\rws = websocket.WebSocketApp(\r\"wss://api.gemini.com/v1/marketdata/btcusd?top_of_book=true\u0026offers=true\",\ron_message=on_message)\rws.run_forever(sslopt={\"cert_reqs\": ssl.CERT_NONE})\r###### 输出 #######\r{\"type\":\"update\",\"eventId\":7275473603,\"socket_sequence\":0,\"events\":[{\"type\":\"change\",\"reason\":\"initial\",\"price\":\"11386.12\",\"delta\":\"1.307\",\"remaining\":\"1.307\",\"side\":\"ask\"}]}\r{\"type\":\"update\",\"eventId\":7275475120,\"timestamp\":1562380981,\"timestampms\":1562380981991,\"socket_sequence\":1,\"events\":[{\"type\":\"change\",\"side\":\"ask\",\"price\":\"11386.62\",\"remaining\":\"1\",\"reason\":\"top-of-book\"}]}\r{\"type\":\"update\",\"eventId\":7275475271,\"timestamp\":1562380982,\"timestampms\":1562380982387,\"socket_sequence\":2,\"events\":[{\"type\":\"change\",\"side\":\"ask\",\"price\":\"11386.12\",\"remaining\":\"1.3148\",\"reason\":\"top-of-book\"}]}\r{\"type\":\"update\",\"eventId\":7275475838,\"timestamp\":1562380986,\"timestampms\":1562380986270,\"socket_sequence\":3,\"events\":[{\"type\":\"change\",\"side\":\"ask\",\"price\":\"11387.16\",\"remaining\":\"0.072949\",\"reason\":\"top-of-book\"}]}\r{\"type\":\"update\",\"eventId\":7275475935,\"timestamp\":1562380986,\"timestampms\":1562380986767,\"socket_sequence\":4,\"events\":[{\"type\":\"change\",\"side\":\"ask\",\"price\":\"11389.22\",\"remaining\":\"0.06204196\",\"reason\":\"top-of-book\"}]} 可以看到，在和Gemini建立连接后，我们并没有向服务器发送任何消息，没有任何请求，但是服务器却源源不断地向我们推送数据。这可比REST接口“每请求一次获得一次回复”的沟通方式高效多了！\n因此，相对于REST来说，Websocket是一种更加实时、高效的数据交换方式。当然缺点也很明显：因为请求和回复是异步的，这让我们程序的状态控制逻辑更加复杂。这一点，后面的内容里我们会有更深刻的体会。\n行情抓取模块 link有了 Websocket 的基本概念，我们就掌握了和交易所连接的第二种方式。\n事实上，Gemini 提供了两种 Websocket 接口，一种是 Public 接口，一种为 Private 接口。\nPublic 接口，即公开接口，提供 orderbook 服务，即每个人都能看到的当前挂单价和深度，也就是我们这节课刚刚详细讲过的 orderbook。\n而 Private 接口，和我们上节课讲的挂单操作有关，订单被完全执行、被部分执行等等其他变动，你都会得到通知。\n我们以 orderbook 爬虫为例，先来看下如何抓取 orderbook 信息。下面的代码详细写了一个典型的爬虫，同时使用了类进行封装，希望你不要忘记我们这门课的目的，了解 Python 是如何应用于工程实践中的：\nimport copy\rimport json\rimport ssl\rimport time\rimport websocket\rclass OrderBook(object):\rBIDS = 'bid'\rASKS = 'ask'\rdef __init__(self, limit=20):\rself.limit = limit\r# (price, amount)\rself.bids = {}\rself.asks = {}\rself.bids_sorted = []\rself.asks_sorted = []\rdef insert(self, price, amount, direction):\rif direction == self.BIDS:\rif amount == 0:\rif price in self.bids:\rdel self.bids[price]\relse:\rself.bids[price] = amount\relif direction == self.ASKS:\rif amount == 0:\rif price in self.asks:\rdel self.asks[price]\relse:\rself.asks[price] = amount\relse:\rprint('WARNING: unknown direction {}'.format(direction))\rdef sort_and_truncate(self):\r# sort\rself.bids_sorted = sorted([(price, amount) for price, amount in self.bids.items()], reverse=True)\rself.asks_sorted = sorted([(price, amount) for price, amount in self.asks.items()])\r# truncate\rself.bids_sorted = self.bids_sorted[:self.limit]\rself.asks_sorted = self.asks_sorted[:self.limit]\r# copy back to bids and asks\rself.bids = dict(self.bids_sorted)\rself.asks = dict(self.asks_sorted)\rdef get_copy_of_bids_and_asks(self):\rreturn copy.deepcopy(self.bids_sorted), copy.deepcopy(self.asks_sorted)\rclass Crawler:\rdef __init__(self, symbol, output_file):\rself.orderbook = OrderBook(limit=10)\rself.output_file = output_file\rself.ws = websocket.WebSocketApp('wss://api.gemini.com/v1/marketdata/{}'.format(symbol),\ron_message = lambda ws, message: self.on_message(message))\rself.ws.run_forever(sslopt={'cert_reqs': ssl.CERT_NONE})\rdef on_message(self, message):\r# 对收到的信息进行处理，然后送给 orderbook\rdata = json.loads(message)\rfor event in data['events']:\rprice, amount, direction = float(event['price']), float(event['remaining']), event['side']\rself.orderbook.insert(price, amount, direction)\r# 整理 orderbook，排序，只选取我们需要的前几个\rself.orderbook.sort_and_truncate()\r# 输出到文件\rwith open(self.output_file, 'a+') as f:\rbids, asks = self.orderbook.get_copy_of_bids_and_asks()\routput = {\r'bids': bids,\r'asks': asks,\r'ts': int(time.time() * 1000)\r}\rf.write(json.dumps(output) + '\\n')\rif __name__ == '__main__':\rcrawler = Crawler(symbol='BTCUSD', output_file='BTCUSD.txt')\r###### 输出 #######\r{\"bids\": [[11398.73, 0.96304843], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], \"asks\": [[11407.42, 1.30814001], [11407.92, 1.0], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11412.42, 1.0], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], \"ts\": 1562558996535}\r{\"bids\": [[11398.73, 0.96304843], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], \"asks\": [[11407.42, 1.30814001], [11407.92, 1.0], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11412.42, 1.0], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], \"ts\": 1562558997377}\r{\"bids\": [[11398.73, 0.96304843], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], \"asks\": [[11407.42, 1.30814001], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11412.42, 1.0], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], \"ts\": 1562558997765}\r{\"bids\": [[11398.73, 0.96304843], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], \"asks\": [[11407.42, 1.30814001], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], \"ts\": 1562558998638}\r{\"bids\": [[11398.73, 0.97131753], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.95, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], \"asks\": [[11407.42, 1.30814001], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], \"ts\": 1562558998645}\r{\"bids\": [[11398.73, 0.97131753], [11398.72, 0.98914437], [11397.32, 1.0], [11396.13, 2.0], [11395.87, 1.0], [11394.09, 0.11803397], [11394.08, 1.0], [11393.59, 0.1612581], [11392.96, 1.0]], \"asks\": [[11407.42, 1.30814001], [11409.48, 2.0], [11409.66, 2.0], [11412.15, 0.525], [11413.77, 0.11803397], [11413.99, 0.5], [11414.28, 1.0], [11414.72, 1.0]], \"ts\": 1562558998748} 代码比较长，接下来我们具体解释一下。\n这段代码的最开始，封装了一个叫做 orderbook 的 class，专门用来存放与之相关的数据结构。其中的 bids 和 asks 两个字典，用来存储当前时刻下的买方挂单和卖方挂单。\n此外，我们还专门维护了一个排过序的 bids_sorted 和 asks_sorted。构造函数有一个参数 limit，用来指示 orderbook 的 bids 和 asks 保留多少条数据。对于很多策略，top 5 的数据往往足够，这里我们选择的是前 10 个。\n再往下看，insert() 函数用于向 orderbook 插入一条数据。需要注意，这里的逻辑是，如果某个 price 对应的 amount 是 0，那么意味着这一条数据已经不存在了，删除即可。insert 的数据可能是乱序的，因此在需要的时候，我们要对 bids 和 asks 进行排序，然后选取前面指定数量的数据。这其实就是 sort_and_truncate() 函数的作用，调用它来对 bids 和 asks 排序后截取，最后保存回 bids 和 asks。\n接下来的 get_copy_of_bids_and_asks()函数，用来返回排过序的 bids 和 asks 数组。这里使用深拷贝，是因为如果直接返回，将会返回 bids_sorted 和 asks_sorted 的指针；那么，在下一次调用 sort_and_truncate() 函数的时候，两个数组的内容将会被改变，这就造成了潜在的 bug。\n最后来看一下 Crawler 类。构造函数声明 orderbook，然后定义 Websocket 用来接收交易所数据。这里需要注意的一点是，回调函数 on_message() 是一个类成员函数。因此，应该你注意到了，它的第一个参数是 self，这里如果直接写成 on_message = self.on_message 将会出错。\n为了避免这个问题，我们需要将函数再次包装一下。这里我使用了前面学过的匿名函数，来传递中间状态，注意我们只需要 message，因此传入 message 即可。\n剩下的部分就很清晰了，on_message 回调函数在收到一个新的 tick 时，先将信息解码，枚举收到的所有改变；然后插入 orderbook，排序；最后连同 timestamp 一并输出即可。\n虽然这段代码看起来挺长，但是经过我这么一分解，是不是发现都是学过的知识点呢？这也是我一再强调基础的原因，如果对你来说哪部分内容变得陌生了（比如面向对象编程的知识点），一定要记得及时往前复习，这样你学起新的更复杂的东西，才能轻松很多。\n回到正题。刚刚的代码，主要是为了抓取 orderbook 的信息。事实上，Gemini 交易所在建立数据流 Websocket 的时候，第一条信息往往非常大，因为里面包含了那个时刻所有的 orderbook 信息。这就叫做初始数据。之后的消息，都是基于初始数据进行修改的，直接处理即可。\n总结 link这节课我们继承上一节，从委托账本讲起，然后讲述了 WebSocket 的定义、工作机制和使用方法，最后以一个例子收尾，带你学会如何爬取 Orderbook 的信息。希望你在学习这节课的内容时，能够和上节课的内容联系起来，仔细思考 Websocket 和 RESTFul 的区别，并试着总结网络编程中不同模型的适用范围。\n思考题 link最后给你留一道思考题。WebSocket 会丢包吗？如果丢包的话， Orderbook 爬虫又会发生什么？这一点应该如何避免呢？欢迎留言和我讨论，也欢迎你把这篇文章分享出去。\npip -m install websocket_client安装。\npip -m install websocket会安装另外一个完全不同的包2019-07-29tux 👍（16） 💬（0）干布球和tt 的提示，解决了报错。 import websocket #pip install websocket-client import _thread as thread\n在查找资料时，看到了： import websocket try: import thread except ImportError: import _thread as thread\n"
            }
        );
    index.add(
            {
                id:  18 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/36---pandas--numpy%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F\/",
                title: "36 - Pandas \u0026 Numpy：策略与回测系统",
                description: "大家好，我是景霄。\n上节课，我们介绍了交易所的数据抓取，特别是orderbook和tick数据的抓取。今天这节课，我们考虑的是，怎么在这些历史数据上测试一个交易策略。\n首先我们要明确，对于很多策略来说，我们上节课抓取的密集的orderbook和tick数据，并不能简单地直接使用。因为数据量太密集，包含了太多细节；而且长时间连接时，网络随机出现的不稳定，会导致丢失部分tick数据。因此，我们还需要进行合适的清洗、聚合等操作。\n此外，为了进行回测，我们需要一个交易策略，还需要一个测试框架。目前已存在很多成熟的回测框架，但是为了Python学习，我决定带你搭建一个简单的回测框架，并且从中简单一窥Pandas的优势。\nOHLCV数据 link了解过一些股票交易的同学，可能知道K线这种东西。K线又称“蜡烛线”，是一种反映价格走势的图线。它的特色在于，一个线段内记录了多项讯息，相当易读易懂且实用有效，因此被广泛用于股票、期货、贵金属、数字货币等行情的技术分析。下面便是一个K线示意图。\nK线示意图\n其中，每一个小蜡烛，都代表着当天的开盘价（Open）、最高价（High）、最低价（Low）和收盘价（Close），也就是我画的第二张图表示的这样。\nK线的“小蜡烛” – OHLC\n类似的，除了日K线之外，还有周K线、小时K线、分钟K线等等。那么这个K线是怎么计算来的呢？\n我们以小时K线图为例，还记得我们当时抓取的tick数据吗？也就是每一笔交易的价格和数量。那么，如果从上午10:00开始，我们开始积累tick的交易数据，以10:00开始的第一个交易作为Open数据，11:00前的最后一笔交易作为Close值，并把这一个小时最低和最高的成交价格分别作为High和Low的值，我们就可以绘制出这一个小时对应的“小蜡烛”形状了。\n如果再加上这一个小时总的成交量（Volumn），就得到了OHLCV数据。\n所以，如果我们一直抓取着tick底层原始数据，我们就能在上层聚合出1分钟K线、小时K线以及日、周k线等等。如果你对这一部分操作有兴趣，可以把此作为今天的课后作业来实践。\n接下来，我们将使用Gemini从2015年到2019年7月这个时间内，BTC对USD每个小时的OHLCV数据，作为策略和回测的输入。你可以在这里下载数据。\n数据下载完成后，我们可以利用Pandas读取，比如下面这段代码。\ndef assert_msg(condition, msg):\rif not condition:\rraise Exception(msg)\rdef read_file(filename):\r# 获得文件绝对路径\rfilepath = path.join(path.dirname(__file__), filename)\r# 判定文件是否存在\rassert_msg(path.exists(filepath), \"文件不存在\")\r# 读取CSV文件并返回\rreturn pd.read_csv(filepath,\rindex_col=0, parse_dates=True,\rinfer_datetime_format=True)\rBTCUSD = read_file('BTCUSD_GEMINI.csv')\rassert_msg(BTCUSD.__len__() \u003e 0, '读取失败')\rprint(BTCUSD.head())\r########## 输出 ##########\rTime Symbol Open High Low Close Volume\rDate 2019-07-08 00:00:00 BTCUSD 11475.07 11540.33 11469.53 11506.43 10.770731\r2019-07-07 23:00:00 BTCUSD 11423.00 11482.72 11423.00 11475.07 32.996559\r2019-07-07 22:00:00 BTCUSD 11526.25 11572.74 11333.59 11423.00 48.937730\r2019-07-07 21:00:00 BTCUSD 11515.80 11562.65 11478.20 11526.25 25.323908\r2019-07-07 20:00:00 BTCUSD 11547.98 11624.88 11423.94 11515.80 63.211972 这段代码提供了两个工具函数。\n",
                content: "大家好，我是景霄。\n上节课，我们介绍了交易所的数据抓取，特别是orderbook和tick数据的抓取。今天这节课，我们考虑的是，怎么在这些历史数据上测试一个交易策略。\n首先我们要明确，对于很多策略来说，我们上节课抓取的密集的orderbook和tick数据，并不能简单地直接使用。因为数据量太密集，包含了太多细节；而且长时间连接时，网络随机出现的不稳定，会导致丢失部分tick数据。因此，我们还需要进行合适的清洗、聚合等操作。\n此外，为了进行回测，我们需要一个交易策略，还需要一个测试框架。目前已存在很多成熟的回测框架，但是为了Python学习，我决定带你搭建一个简单的回测框架，并且从中简单一窥Pandas的优势。\nOHLCV数据 link了解过一些股票交易的同学，可能知道K线这种东西。K线又称“蜡烛线”，是一种反映价格走势的图线。它的特色在于，一个线段内记录了多项讯息，相当易读易懂且实用有效，因此被广泛用于股票、期货、贵金属、数字货币等行情的技术分析。下面便是一个K线示意图。\nK线示意图\n其中，每一个小蜡烛，都代表着当天的开盘价（Open）、最高价（High）、最低价（Low）和收盘价（Close），也就是我画的第二张图表示的这样。\nK线的“小蜡烛” – OHLC\n类似的，除了日K线之外，还有周K线、小时K线、分钟K线等等。那么这个K线是怎么计算来的呢？\n我们以小时K线图为例，还记得我们当时抓取的tick数据吗？也就是每一笔交易的价格和数量。那么，如果从上午10:00开始，我们开始积累tick的交易数据，以10:00开始的第一个交易作为Open数据，11:00前的最后一笔交易作为Close值，并把这一个小时最低和最高的成交价格分别作为High和Low的值，我们就可以绘制出这一个小时对应的“小蜡烛”形状了。\n如果再加上这一个小时总的成交量（Volumn），就得到了OHLCV数据。\n所以，如果我们一直抓取着tick底层原始数据，我们就能在上层聚合出1分钟K线、小时K线以及日、周k线等等。如果你对这一部分操作有兴趣，可以把此作为今天的课后作业来实践。\n接下来，我们将使用Gemini从2015年到2019年7月这个时间内，BTC对USD每个小时的OHLCV数据，作为策略和回测的输入。你可以在这里下载数据。\n数据下载完成后，我们可以利用Pandas读取，比如下面这段代码。\ndef assert_msg(condition, msg):\rif not condition:\rraise Exception(msg)\rdef read_file(filename):\r# 获得文件绝对路径\rfilepath = path.join(path.dirname(__file__), filename)\r# 判定文件是否存在\rassert_msg(path.exists(filepath), \"文件不存在\")\r# 读取CSV文件并返回\rreturn pd.read_csv(filepath,\rindex_col=0, parse_dates=True,\rinfer_datetime_format=True)\rBTCUSD = read_file('BTCUSD_GEMINI.csv')\rassert_msg(BTCUSD.__len__() \u003e 0, '读取失败')\rprint(BTCUSD.head())\r########## 输出 ##########\rTime Symbol Open High Low Close Volume\rDate 2019-07-08 00:00:00 BTCUSD 11475.07 11540.33 11469.53 11506.43 10.770731\r2019-07-07 23:00:00 BTCUSD 11423.00 11482.72 11423.00 11475.07 32.996559\r2019-07-07 22:00:00 BTCUSD 11526.25 11572.74 11333.59 11423.00 48.937730\r2019-07-07 21:00:00 BTCUSD 11515.80 11562.65 11478.20 11526.25 25.323908\r2019-07-07 20:00:00 BTCUSD 11547.98 11624.88 11423.94 11515.80 63.211972 这段代码提供了两个工具函数。\n一个是read_file，它的作用是，用pandas读取csv文件。 另一个是assert_msg，它的作用类似于assert，如果传入的条件（contidtion）为否，就会抛出异常。不过，你需要提供一个参数，用于指定要抛出的异常信息。 回测框架 link说完了数据，我们接着来看回测数据。常见的回测框架有两类。一类是向量化回测框架，它通常基于Pandas+Numpy来自己搭建计算核心；后端则是用MySQL或者MongoDB作为源。这种框架通过Pandas+Numpy对OHLC数组进行向量运算，可以在较长的历史数据上进行回测。不过，因为这类框架一般只用OHLC，所以模拟会比较粗糙。\n另一类则是事件驱动型回测框架。这类框架，本质上是针对每一个tick的变动或者orderbook的变动生成事件；然后，再把一个个事件交给策略进行执行。因此，虽然它的拓展性很强，可以允许更加灵活的策略，但回测速度是很慢的。\n我们想要学习量化交易，使用大型成熟的回测框架，自然是第一选择。\n比如Zipline，就是一个热门的事件驱动型回测框架，背后有大型社区和文档的支持。 PyAlgoTrade也是事件驱动的回测框架，文档相对完整，整合了知名的技术分析（Techique Analysis）库TA-Lib。在速度和灵活方面，它比Zipline 强。不过，它的一大硬伤是不支持 Pandas 的模块和对象。 显然，对于我们Python学习者来说，第一类也就是向量型回测框架，才是最适合我们练手的项目了。那么，我们就开始吧。\n首先，我先为你梳理下回测流程，也就是下面五步：\n读取OHLC数据； 对OHLC进行指标运算； 策略根据指标向量决定买卖； 发给模拟的”交易所“进行交易； 最后，统计结果。 对此，使用之前学到的面向对象思维方式，我们可以大致抽取三个类：\n交易所类（ ExchangeAPI）：负责维护账户的资金和仓位，以及进行模拟的买卖； 策略类（Strategy）：负责根据市场信息生成指标，根据指标决定买卖； 回测类框架（Backtest）：包含一个策略类和一个交易所类，负责迭代地对每个数据点调用策略执行。 接下来，我们先从最外层的大框架开始。这样的好处在于，我们是从上到下、从外往内地思考，虽然还没有开始设计依赖项（Backtest的依赖项是ExchangeAPI和Strategy），但我们可以推测出它们应有的接口形式。推测接口的本质，其实就是推测程序的输入。\n这也是我在一开始提到过的，对于程序这个“黑箱”，你在一开始设计的时候，就要想好输入和输出。\n回到最外层Backtest类。我们需要知道，输出是最后的收益，那么显然，输入应该是初始输入的资金数量（cash）。\n此外，为了模拟得更加真实，我们还要考虑交易所的手续费（commission）。手续费的多少取决于券商（broker）或者交易所，比如我们买卖股票的券商手续费可能是万七，那么就是0.0007。但是在比特币交易领域，手续费通常会稍微高一点，可能是千分之二左右。当然，无论怎么多，一般也不会超过5 %。否则我们大家交易几次就破产了，也就不会有人去交易了。\n这里说一句题外话，不知道你有没有发现，无论数字货币的价格是涨还是跌，总有一方永远不亏，那就是交易所。因为只要有人交易，他们就有白花花的银子进账。\n回到正题，至此，我们就确定了Backtest的输入和输出。\n它的输入是：\nOHLC数据； 初始资金； 手续费率； 交易所类； 策略类。 输出则是：\n最后剩余市值。 对此，你可以参考下面这段代码：\nclass Backtest:\r\"\"\"\rBacktest回测类，用于读取历史行情数据、执行策略、模拟交易并估计\r收益。\r初始化的时候调用Backtest.run来时回测\rinstance, or `backtesting.backtesting.Backtest.optimize` to\roptimize it.\r\"\"\"\rdef __init__(self,\rdata: pd.DataFrame,\rstrategy_type: type(Strategy),\rbroker_type: type(ExchangeAPI),\rcash: float = 10000,\rcommission: float = .0):\r\"\"\"\r构造回测对象。需要的参数包括：历史数据，策略对象，初始资金数量，手续费率等。\r初始化过程包括检测输入类型，填充数据空值等。\r参数：\r:param data: pd.DataFrame pandas Dataframe格式的历史OHLCV数据\r:param broker_type: type(ExchangeAPI) 交易所API类型，负责执行买卖操作以及账户状态的维护\r:param strategy_type: type(Strategy) 策略类型\r:param cash: float 初始资金数量\r:param commission: float 每次交易手续费率。如2%的手续费此处为0.02\r\"\"\"\rassert_msg(issubclass(strategy_type, Strategy), 'strategy_type不是一个Strategy类型')\rassert_msg(issubclass(broker_type, ExchangeAPI), 'strategy_type不是一个Strategy类型')\rassert_msg(isinstance(commission, Number), 'commission不是浮点数值类型')\rdata = data.copy(False)\r# 如果没有Volumn列，填充NaN\rif 'Volume' not in data:\rdata['Volume'] = np.nan\r# 验证OHLC数据格式\rassert_msg(len(data.columns \u0026 {'Open', 'High', 'Low', 'Close', 'Volume'}) == 5,\r(\"输入的`data`格式不正确，至少需要包含这些列：\"\r\"'Open', 'High', 'Low', 'Close'\"))\r# 检查缺失值\rassert_msg(not data[['Open', 'High', 'Low', 'Close']].max().isnull().any(),\r('部分OHLC包含缺失值，请去掉那些行或者通过差值填充. '))\r# 如果行情数据没有按照时间排序，重新排序一下\rif not data.index.is_monotonic_increasing:\rdata = data.sort_index()\r# 利用数据，初始化交易所对象和策略对象。\rself._data = data # type: pd.DataFrame\rself._broker = broker_type(data, cash, commission)\rself._strategy = strategy_type(self._broker, self._data)\rself._results = None\rdef run(self):\r\"\"\"\r运行回测，迭代历史数据，执行模拟交易并返回回测结果。\rRun the backtest. Returns `pd.Series` with results and statistics.\rKeyword arguments are interpreted as strategy parameters.\r\"\"\"\rstrategy = self._strategy\rbroker = self._broker\r# 策略初始化\rstrategy.init()\r# 设定回测开始和结束位置\rstart = 100\rend = len(self._data)\r# 回测主循环，更新市场状态，然后执行策略\rfor i in range(start, end):\r# 注意要先把市场状态移动到第i时刻，然后再执行策略。\rbroker.next(i)\rstrategy.next(i)\r# 完成策略执行之后，计算结果并返回\rself._results = self._compute_result(broker)\rreturn self._results\rdef _compute_result(self, broker):\rs = pd.Series()\rs['初始市值'] = broker.initial_cash\rs['结束市值'] = broker.market_value\rs['收益'] = broker.market_value - broker.initial_cash\rreturn s 这段代码有点长，但是核心其实就两部分。\n初始化函数（init）：传入必要参数，对OHLC数据进行简单清洗、排序和验证。我们从不同地方下载的数据，可能格式不一样；而排序的方式也可能是从前往后。所以，这里我们把数据统一设置为按照时间从之前往现在的排序。 执行函数（run）：这是回测框架的主要循环部分，核心是更新市场还有更新策略的时间。迭代完成所有的历史数据后，它会计算收益并返回。 你应该注意到了，此时，我们还没有定义策略和交易所API的结构。不过，通过回测的执行函数，我们可以确定这两个类的接口形式。\n策略类（Strategy）的接口形式为：\n初始化函数init()，根据历史数据进行指标（Indicator）计算。 步进函数next()，根据当前时间和指标，决定买卖操作，并发给交易所类执行。 交易所类（ExchangeAPI）的接口形式为：\n步进函数next()，根据当前时间，更新最新的价格； 买入操作buy()，买入资产； 卖出操作sell()，卖出资产。 交易策略 link接下来我们来看交易策略。交易策略的开发是一个非常复杂的学问。为了达到学习的目的，我们来想一个简单的策略——移动均值交叉策略。\n为了了解这个策略，我们先了解一下，什么叫做简单移动均值（Simple Moving Average，简称为SMA，以下皆用SMA表示简单移动均值）。我们知道，N个数的序列 x[0]、x[1] .…… x[N] 的均值，就是这N个数的和除以N。\n现在，我假设一个比较小的数K，比N小很多。我们用一个K大小的滑动窗口，在原始的数组上滑动。通过对每次框住的K个元素求均值，我们就可以得到，原始数组的窗口大小为K的SMA了。\nSMA，实质上就是对原始数组进行了一个简单平滑处理。比如，某支股票的价格波动很大，那么，我们用SMA平滑之后，就会得到下面这张图的效果。\n某个投资品价格的SMA，窗口大小为50\n你可以看出，如果窗口大小越大，那么SMA应该越平滑，变化越慢；反之，如果SMA比较小，那么短期的变化也会越快地反映在SMA上。\n于是，我们想到，能不能对投资品的价格设置两个指标呢？这俩指标，一个是小窗口的SMA，一个是大窗口的SMA。\n如果小窗口的SMA曲线从下面刺破或者穿过大窗口SMA，那么说明，这个投资品的价格在短期内快速上涨，同时这个趋势很强烈，可能是一个买入的信号； 反之，如果大窗口的SMA从下方突破小窗口SMA，那么说明，投资品的价格在短期内快速下跌，我们应该考虑卖出。 下面这幅图，就展示了这两种情况。\n明白了这里的概念和原理后，接下来的操作就不难了。利用Pandas，我们可以非常简单地计算SMA和SMA交叉。比如，你可以引入下面两个工具函数：\ndef SMA(values, n):\r\"\"\"\r返回简单滑动平均\r\"\"\"\rreturn pd.Series(values).rolling(n).mean()\rdef crossover(series1, series2) -\u003e bool:\r\"\"\"\r检查两个序列是否在结尾交叉\r:param series1: 序列1\r:param series2: 序列2\r:return: 如果交叉返回True，反之False\r\"\"\"\rreturn series1[-2] \u003c series2[-2] and series1[-1] \u003e series2[-1] 如代码所示，对于输入的一个数组，Pandas的rolling(k)函数，可以方便地计算窗内口大小为K的SMA数组；而想要检查某个时刻两个SMA是否交叉，你只需要查看两个数组末尾的两个元素即可。\n那么，基于此，我们就可以开发出一个简单的策略了。下面这段代码表示策略的核心思想，我做了详细的注释，你理解起来应该没有问题：\ndef next(self, tick):\r# 如果此时快线刚好越过慢线，买入全部\rif crossover(self.sma1[:tick], self.sma2[:tick]):\rself.buy()\r# 如果是慢线刚好越过快线，卖出全部\relif crossover(self.sma2[:tick], self.sma1[:tick]):\rself.sell()\r# 否则，这个时刻不执行任何操作。\relse:\rpass 说完策略的核心思想，我们开始搭建策略类的框子。\n首先，我们要考虑到，策略类Strategy应该是一个可以被继承的类，同时应该包含一些固定的接口。这样，回测器才能方便地调用。\n于是，我们可以定义一个Strategy抽象类，包含两个接口方法init和next，分别对应我们前面说的指标计算和步进函数。不过注意，抽象类是不能被实例化的。所以，我们必须定义一个具体的子类，同时实现了init和next方法才可以。\n这个类的定义，你可以参考下面代码的实现：\nimport abc\rimport numpy as np\rfrom typing import Callable\rclass Strategy(metaclass=abc.ABCMeta):\r\"\"\"\r抽象策略类，用于定义交易策略。\r如果要定义自己的策略类，需要继承这个基类，并实现两个抽象方法：\rStrategy.init\rStrategy.next\r\"\"\"\rdef __init__(self, broker, data):\r\"\"\"\r构造策略对象。\r@params broker: ExchangeAPI 交易API接口，用于模拟交易\r@params data: list 行情数据数据\r\"\"\"\rself._indicators = []\rself._broker = broker # type: _Broker\rself._data = data # type: _Data\rself._tick = 0\rdef I(self, func: Callable, *args) -\u003e np.ndarray:\r\"\"\"\r计算买卖指标向量。买卖指标向量是一个数组，长度和历史数据对应；\r用于判定这个时间点上需要进行\"买\"还是\"卖\"。\r例如计算滑动平均：\rdef init():\rself.sma = self.I(utils.SMA, self.data.Close, N)\r\"\"\"\rvalue = func(*args)\rvalue = np.asarray(value)\rassert_msg(value.shape[-1] == len(self._data.Close), '指示器长度必须和data长度相同')\rself._indicators.append(value)\rreturn value\r@property\rdef tick(self):\rreturn self._tick\r@abc.abstractmethod\rdef init(self):\r\"\"\"\r初始化策略。在策略回测/执行过程中调用一次，用于初始化策略内部状态。\r这里也可以预计算策略的辅助参数。比如根据历史行情数据：\r计算买卖的指示器向量；\r训练模型/初始化模型参数\r\"\"\"\rpass\r@abc.abstractmethod\rdef next(self, tick):\r\"\"\"\r步进函数，执行第tick步的策略。tick代表当前的\"时间\"。比如data[tick]用于访问当前的市场价格。\r\"\"\"\rpass\rdef buy(self):\rself._broker.buy()\rdef sell(self):\rself._broker.sell()\r@property\rdef data(self):\rreturn self._data 为了方便访问成员，我们还定义了一些Python property。同时，我们的买卖请求是由策略类发出、由交易所API来执行的，所以我们的策略类里依赖于ExchangeAPI类。\n现在，有了这个框架，我们实现移动均线交叉策略就很简单了。你只需要在init函数中，定义计算大小窗口SMA的逻辑；同时，在next函数中完成交叉检测和买卖调用就行了。具体实现，你可以参考下面这段代码：\nfrom utils import assert_msg, crossover, SMA\rclass SmaCross(Strategy):\r# 小窗口SMA的窗口大小，用于计算SMA快线\rfast = 10\r# 大窗口SMA的窗口大小，用于计算SMA慢线\rslow = 20\rdef init(self):\r# 计算历史上每个时刻的快线和慢线\rself.sma1 = self.I(SMA, self.data.Close, self.fast)\rself.sma2 = self.I(SMA, self.data.Close, self.slow)\rdef next(self, tick):\r# 如果此时快线刚好越过慢线，买入全部\rif crossover(self.sma1[:tick], self.sma2[:tick]):\rself.buy()\r# 如果是慢线刚好越过快线，卖出全部\relif crossover(self.sma2[:tick], self.sma1[:tick]):\rself.sell()\r# 否则，这个时刻不执行任何操作。\relse:\rpass 模拟交易 link到这里，我们的回测就只差最后一块儿了。胜利就在眼前，我们继续加油。\n我们前面提到过，交易所类负责模拟交易，而模拟的基础，就是需要当前市场的价格。这里，我们可以用OHLC中的Close，作为那个时刻的价格。\n此外，为了简化设计，我们假设买卖操作都利用的是当前账户的所有资金、仓位，且市场容量足够大。这样，我们的下单请求就能够马上完全执行。\n也别忘了手续费这个大头。考虑到有手续费的情况，此时，我们最核心的买卖函数应该怎么来写呢？\n我们一起来想这个问题。假设，我们现在有1000.0元，此时BTC的价格是100.00元（当然没有这么好的事情啊，这里只是假设），并且交易手续费为1%。那么，我们能买到多少BTC呢？\n我们可以采用这种算法：\n买到的数量 = 投入的资金 * (1.0 - 手续费) / 价格 那么此时，你就能收到9.9个BTC。\n类似的，卖出的时候结算方式如下，也不难理解：\n卖出的收益 = 持有的数量 * 价格 * (1.0 - 手续费) 所以，最终模拟交易所类的实现，你可以参考下面这段代码：\nfrom utils import read_file, assert_msg, crossover, SMA\rclass ExchangeAPI:\rdef __init__(self, data, cash, commission):\rassert_msg(0 \u003c cash, \"初始现金数量大于0，输入的现金数量：{}\".format(cash))\rassert_msg(0 \u003c= commission \u003c= 0.05, \"合理的手续费率一般不会超过5%，输入的费率：{}\".format(commission))\rself._inital_cash = cash\rself._data = data\rself._commission = commission\rself._position = 0\rself._cash = cash\rself._i = 0\r@property\rdef cash(self):\r\"\"\"\r:return: 返回当前账户现金数量\r\"\"\"\rreturn self._cash\r@property\rdef position(self):\r\"\"\"\r:return: 返回当前账户仓位\r\"\"\"\rreturn self._position\r@property\rdef initial_cash(self):\r\"\"\"\r:return: 返回初始现金数量\r\"\"\"\rreturn self._inital_cash\r@property\rdef market_value(self):\r\"\"\"\r:return: 返回当前市值\r\"\"\"\rreturn self._cash + self._position * self.current_price\r@property\rdef current_price(self):\r\"\"\"\r:return: 返回当前市场价格\r\"\"\"\rreturn self._data.Close[self._i]\rdef buy(self):\r\"\"\"\r用当前账户剩余资金，按照市场价格全部买入\r\"\"\"\rself._position = float(self._cash / (self.current_price * (1 + self._commission)))\rself._cash = 0.0\rdef sell(self):\r\"\"\"\r卖出当前账户剩余持仓\r\"\"\"\rself._cash += float(self._position * self.current_price * (1 - self._commission))\rself._position = 0.0\rdef next(self, tick):\rself._i = tick 其中的current_price（当前价格），可以方便地获得模拟交易所当前时刻的商品价格；而market_value，则可以获得当前总市值。在初始化函数的时候，我们检查手续费率和输入的现金数量，是不是在一个合理的范围。\n有了所有的这些部分，我们就可以来模拟回测啦！\n首先，我们设置初始资金量为10000.00美元，交易所手续费率为0。这里你可以猜一下，如果我们从2015年到现在，都按照SMA来买卖，现在应该有多少钱呢？\ndef main():\rBTCUSD = read_file('BTCUSD_GEMINI.csv')\rret = Backtest(BTCUSD, SmaCross, ExchangeAPI, 10000.0, 0.00).run()\rprint(ret)\rif __name__ == '__main__':\rmain() 铛铛铛，答案揭晓，程序将输出：\n初始市值 10000.000000\r结束市值 576361.772884\r收益 566361.772884 哇，结束时，我们将有57万美元，翻了整整57倍啊！简直不要太爽。不过，等等，这个手续费率为0，实在是有点碍眼，因为根本不可能啊。我们现在来设一个比较真实的值吧，大概千分之三，然后再来试试：\n初始市值 10000.000000\r结束市值 2036.562001\r收益 -7963.437999 什么鬼？我们变成赔钱了，只剩下2000美元了！这是真的吗？\n这是真的，也是假的。\n我说的“真”是指，如果你真的用SMA交叉这种简单的方法去交易，那么手续费摩擦和滑点等因素，确实可能让你的高频策略赔钱。\n而我说是“假”是指，这种模拟交易的方式非常粗糙。真实的市场情况，并非这么理想——比如买卖请求永远马上执行；再比如，我们在市场中进行交易的同时不会影响市场价格等，这些理想情况都是不可能的。所以，很多时候，回测永远赚钱，但实盘马上赔钱。\n总结 link这节课，我们继承上一节，介绍了回测框架的分类、数据的格式，并且带你从头开始写了一个简单的回测系统。你可以把今天的代码片段“拼”起来，这样就会得到一个简化的回测系统样例。同时，我们实现了一个简单的交易策略，并且在真实的历史数据上运行了回测结果。我们观察到，在加入手续费后，策略的收益情况发生了显著的变化。\n思考题 link最后，给你留一个思考题。之前我们介绍了如何抓取tick数据，你可以根据抓取的tick数据，生成5分钟、每小时和每天的OHLCV数据吗？欢迎在留言区写下你的答案和问题，也欢迎你把这篇文章分享出去。\n老师，这里应该是：self._position = float(self._cash * (1-self._commission) / (self.current_price))吧？2020-08-11马建华 👍（3） 💬（0）assert_msg(isinstance(commission, Number), 'commission不是浮点数值类型')为何不是用float而是number2020-08-10宋强 👍（2） 💬（1）按照代码逻辑实现了一遍，发现即便是交易经手费是0，最后的收益也很大取决于数据本身。策略并不一定能盈利2020-02-11小侠龙旋风 👍（1） 💬（0）SMA函数只做了一件事：pd.Series(values).rolling(n).mean() 将传入的values转成一位数组以n个数据为单位滚动切分取平均值，返回一个均值数组 SMA的调用位置： SmaCross在继承Strategy后必须要重写的抽象方法init中： self.sma1 = self.I(SMA, self.data.Close, self.fast) # 用收盘价计算的10日均线 self.sma2 = self.I(SMA, self.data.Close, self.slow) # 用收盘价计算的20日均线\n提议：数据可视化更能直观表达实现策略的方案。2019-09-01小侠龙旋风 👍（1） 💬（0）30日均线、10日均线、5日均线、小时、分钟… 大窗口SMA -\u003e 小窗口SMA 策略：小窗口SMA从下穿过大窗口SMA，买入。大窗口SMA从下方突破小窗口 SMA，卖出。 这要先看看股市的简单策略分析才能明白。刚开始看，完全不懂。。。2019-09-01长青 👍（1） 💬（1）老师iself._indicators.append(value)这一步有有什么意义呢 没大看明白。还有 buy和sell是不是应该在下一根K线执行才对？比如我指标计算时用的15分钟K线 在10:15分出现买卖信号后，应该在10:30执行操作 ，因为指标时根据收盘价计算的\n"
            }
        );
    index.add(
            {
                id:  19 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/37---kafka--zmq%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E6%98%93%E6%B5%81%E6%B0%B4%E7%BA%BF\/",
                title: "37 - Kafka \u0026 ZMQ：自动化交易流水线",
                description: "你好，我是景霄。\n在进行这节课的学习前，我们先来回顾一下，前面三节课，我们学了些什么。\n第 34 讲，我们介绍了如何通过 RESTful API 在交易所下单；第 35 讲，我们讲解了如何通过 Websocket ，来获取交易所的 orderbook 数据；第 36 讲，我们介绍了如何实现一个策略，以及如何对策略进行历史回测。\n事实上，到这里，一个简单的、可以运作的量化交易系统已经成型了。你可以对策略进行反复修改，期待能得到不错的 PnL。但是，对于一个完善的量化交易系统来说，只有基本骨架还是不够的。\n在大型量化交易公司，系统一般是分布式运行的，各个模块独立在不同的机器上，然后互相连接来实现。即使是个人的交易系统，在进行诸如高频套利等算法时，也需要将执行层布置在靠近交易所的机器节点上。\n所以，从今天这节课开始，我们继续回到 Python 的技术栈，从量化交易系统这个角度切入，为你讲解如何实现分布式系统之间的复杂协作。\n中间件 link我们先来介绍一下中间件这个概念。中间件，是将技术底层工具和应用层进行连接的组件。它要实现的效果则是，让我们这些需要利用服务的工程师，不必去关心底层的具体实现。我们只需要拿着中间件的接口来用就好了。\n这个概念听起来并不难理解，我们再举个例子让你彻底明白。比如拿数据库来说，底层数据库有很多很多种，从关系型数据库 MySQL 到非关系型数据库 NoSQL，从分布式数据库 Spanner 到内存数据库 Redis，不同的数据库有不同的使用场景，也有着不同的优缺点，更有着不同的调用方式。那么中间件起什么作用呢？\n中间件，等于在这些不同的数据库上加了一层逻辑，这一层逻辑专门用来和数据库打交道，而对外只需要暴露同一个接口即可。这样一来，上层的程序员调用中间件接口时，只需要让中间件指定好数据库即可，其他参数完全一致，极大地方便了上层的开发；同时，下层技术栈在更新换代的时候，也可以做到和上层完全分离，不影响程序员的使用。\n它们之间的逻辑关系，你可以参照下面我画的这张图。我习惯性把中间件的作用调侃为：没有什么事情是加一层解决不了的；如果有，那就加两层。\n当然，这只是其中一个例子，也只是中间件的一种形式。事实上，比如在阿里，中间件主要有分布式关系型数据库 DRDS、消息队列和分布式服务这么三种形式。而我们今天，主要会用到消息队列，因为它非常符合量化交易系统的应用场景，即事件驱动模型。\n消息队列 link那么，什么是消息队列呢？一如其名，消息，即互联网信息传递的个体；而队列，学过算法和数据结构的你，应该很清楚这个 FIFO（先进先出）的数据结构吧。（如果算法基础不太牢，建议你可以学习极客时间平台上王争老师的“数据结构与算法之美”专栏，第 09讲即为队列知识）\n",
                content: "你好，我是景霄。\n在进行这节课的学习前，我们先来回顾一下，前面三节课，我们学了些什么。\n第 34 讲，我们介绍了如何通过 RESTful API 在交易所下单；第 35 讲，我们讲解了如何通过 Websocket ，来获取交易所的 orderbook 数据；第 36 讲，我们介绍了如何实现一个策略，以及如何对策略进行历史回测。\n事实上，到这里，一个简单的、可以运作的量化交易系统已经成型了。你可以对策略进行反复修改，期待能得到不错的 PnL。但是，对于一个完善的量化交易系统来说，只有基本骨架还是不够的。\n在大型量化交易公司，系统一般是分布式运行的，各个模块独立在不同的机器上，然后互相连接来实现。即使是个人的交易系统，在进行诸如高频套利等算法时，也需要将执行层布置在靠近交易所的机器节点上。\n所以，从今天这节课开始，我们继续回到 Python 的技术栈，从量化交易系统这个角度切入，为你讲解如何实现分布式系统之间的复杂协作。\n中间件 link我们先来介绍一下中间件这个概念。中间件，是将技术底层工具和应用层进行连接的组件。它要实现的效果则是，让我们这些需要利用服务的工程师，不必去关心底层的具体实现。我们只需要拿着中间件的接口来用就好了。\n这个概念听起来并不难理解，我们再举个例子让你彻底明白。比如拿数据库来说，底层数据库有很多很多种，从关系型数据库 MySQL 到非关系型数据库 NoSQL，从分布式数据库 Spanner 到内存数据库 Redis，不同的数据库有不同的使用场景，也有着不同的优缺点，更有着不同的调用方式。那么中间件起什么作用呢？\n中间件，等于在这些不同的数据库上加了一层逻辑，这一层逻辑专门用来和数据库打交道，而对外只需要暴露同一个接口即可。这样一来，上层的程序员调用中间件接口时，只需要让中间件指定好数据库即可，其他参数完全一致，极大地方便了上层的开发；同时，下层技术栈在更新换代的时候，也可以做到和上层完全分离，不影响程序员的使用。\n它们之间的逻辑关系，你可以参照下面我画的这张图。我习惯性把中间件的作用调侃为：没有什么事情是加一层解决不了的；如果有，那就加两层。\n当然，这只是其中一个例子，也只是中间件的一种形式。事实上，比如在阿里，中间件主要有分布式关系型数据库 DRDS、消息队列和分布式服务这么三种形式。而我们今天，主要会用到消息队列，因为它非常符合量化交易系统的应用场景，即事件驱动模型。\n消息队列 link那么，什么是消息队列呢？一如其名，消息，即互联网信息传递的个体；而队列，学过算法和数据结构的你，应该很清楚这个 FIFO（先进先出）的数据结构吧。（如果算法基础不太牢，建议你可以学习极客时间平台上王争老师的“数据结构与算法之美”专栏，第 09讲即为队列知识）\n简而言之，消息队列就是一个临时存放消息的容器，有人向消息队列中推送消息；有人则监听消息队列，发现新消息就会取走。根据我们刚刚对中间件的解释，清晰可见，消息队列也是一种中间件。\n目前，市面上使用较多的消息队列有 RabbitMQ、Kafka、RocketMQ、ZMQ 等。不过今天，我只介绍最常用的 ZMQ 和 Kafka。\n我们先来想想，消息队列作为中间件有什么特点呢？\n首先是严格的时序性。刚刚说了，队列是一种先进先出的数据结构，你丢给它 1, 2, 3，然后另一个人从里面取数据，那么取出来的一定也是 1, 2, 3，严格保证了先进去的数据先出去，后进去的数据后出去。显然，这也是消息机制中必须要保证的一点，不然颠三倒四的结果一定不是我们想要的。\n说到队列的特点，简单提一句，与“先进先出“相对的是栈这种数据结构，它是先进后出的，你丢给它 1, 2, 3，再从里面取出来的时候，拿到的就是3, 2, 1了，这一点一定要区分清楚。\n其次，是分布式网络系统的老生常谈问题。如何保证消息不丢失？如何保证消息不重复？这一切，消息队列在设计的时候都已经考虑好了，你只需要拿来用就可以，不必过多深究。\n不过，很重要的一点，消息队列是如何降低系统复杂度，起到中间件的解耦作用呢？我们来看下面这张图。\n消息队列的模式是发布和订阅，一个或多个消息发布者可以发布消息，一个或多个消息接受者可以订阅消息。 从图中你可以看到，消息发布者和消息接受者之间没有直接耦合，其中，\n消息发布者将消息发送到分布式消息队列后，就结束了对消息的处理； 消息接受者从分布式消息队列获取该消息后，即可进行后续处理，并不需要探寻这个消息从何而来。 至于新增业务的问题，只要你对这类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，所以也就实现了业务的可扩展性设计。\n讲了这么多概念层的东西，想必你迫不及待地想看具体代码了吧。接下来，我们来看一下 ZMQ 的实现。\nZMQ link先来看 ZMQ，这是一个非常轻量级的消息队列实现。\n作者 Pieter Hintjens 是一位大牛，他本人的经历也很传奇，2010年诊断出胆管癌，并成功做了手术切除。但2016年4月，却发现癌症大面积扩散到了肺部，已经无法治疗。他写的最后一篇通信模式是关于死亡协议的，之后在比利时选择接受安乐死。\nZMQ 是一个简单好用的传输层，它有三种使用模式：\nRequest - Reply 模式； Publish - Subscribe 模式； Parallel Pipeline 模式。 第一种模式很简单，client 发消息给 server，server 处理后返回给 client，完成一次交互。这个场景你一定很熟悉吧，没错，和 HTTP 模式非常像，所以这里我就不重点介绍了。至于第三种模式，与今天内容无关，这里我也不做深入讲解。\n我们需要详细来看的是第二种，即“PubSub”模式。下面是它的具体实现，代码很清晰，你应该很容易理解：\n# 订阅者 1\rimport zmq\rdef run():\rcontext = zmq.Context()\rsocket = context.socket(zmq.SUB)\rsocket.connect('tcp://127.0.0.1:6666')\rsocket.setsockopt_string(zmq.SUBSCRIBE, '')\rprint('client 1')\rwhile True:\rmsg = socket.recv()\rprint(\"msg: %s\" % msg)\rif __name__ == '__main__':\rrun()\r########## 输出 ##########\rclient 1\rmsg: b'server cnt 1'\rmsg: b'server cnt 2'\rmsg: b'server cnt 3'\rmsg: b'server cnt 4'\rmsg: b'server cnt 5' # 订阅者 2\rimport zmq\rdef run():\rcontext = zmq.Context()\rsocket = context.socket(zmq.SUB)\rsocket.connect('tcp://127.0.0.1:6666')\rsocket.setsockopt_string(zmq.SUBSCRIBE, '')\rprint('client 2')\rwhile True:\rmsg = socket.recv()\rprint(\"msg: %s\" % msg)\rif __name__ == '__main__':\rrun()\r########## 输出 ##########\rclient 2\rmsg: b'server cnt 1'\rmsg: b'server cnt 2'\rmsg: b'server cnt 3'\rmsg: b'server cnt 4'\rmsg: b'server cnt 5' # 发布者\rimport time\rimport zmq\rdef run():\rcontext = zmq.Context()\rsocket = context.socket(zmq.PUB)\rsocket.bind('tcp://*:6666')\rcnt = 1\rwhile True:\rtime.sleep(1)\rsocket.send_string('server cnt {}'.format(cnt))\rprint('send {}'.format(cnt))\rcnt += 1\rif __name__ == '__main__':\rrun()\r########## 输出 ##########\rsend 1\rsend 2\rsend 3\rsend 4\rsend 5 这里要注意的一点是，如果你想要运行代码，请先运行两个订阅者，然后再打开发布者。\n接下来，我来简单讲解一下。\n对于订阅者，我们要做的是创建一个 zmq Context，连接 socket 到指定端口。其中，setsockopt_string() 函数用来过滤特定的消息，而下面这行代码：\nsocket.setsockopt_string(zmq.SUBSCRIBE, '') 则表示不过滤任何消息。最后，我们调用 socket.recv() 来接受消息就行了，这条语句会阻塞在这里，直到有新消息来临。\n对于发布者，我们同样要创建一个 zmq Context，绑定到指定端口，不过请注意，这里用的是 bind 而不是 connect。因为在任何情况下，同一个地址端口 bind 只能有一个，但却可以有很多个 connect 链接到这个地方。初始化完成后，再调用 socket.send_string ，即可将我们想要发送的内容发送给 ZMQ。\n当然，这里还有几个需要注意的地方。首先，有了 send_string，我们其实已经可以通过 JSON 序列化，来传递几乎我们想要的所有数据结构，这里的数据流结构就已经很清楚了。\n另外，把发布者的 time.sleep(1) 放在 while 循环的最后，严格来说应该是不影响结果的。这里你可以尝试做个实验，看看会发生什么。\n你还可以思考下另一个问题，如果这里是多个发布者，那么 ZMQ 应该怎么做呢？\nKafka link接着我们再来看一下 Kafka。\n通过代码实现你也可以发现，ZMQ 的优点主要在轻量、开源和方便易用上，但在工业级别的应用中，大部分人还是会转向 Kafka 这样的有充足支持的轮子上。\n相比而言，Kafka 提供了点对点网络和发布订阅模型的支持，这也是用途最广泛的两种消息队列模型。而且和 ZMQ 一样，Kafka 也是完全开源的，因此你也能得到开源社区的充分支持。\nKafka的代码实现，和ZMQ大同小异，这里我就不专门讲解了。关于Kafka的更多内容，极客时间平台也有对 Kafka 的专门详细的介绍，对此有兴趣的同学，可以在极客时间中搜索“Kafka核心技术与实战”，这个专栏里，胡夕老师用详实的篇幅，讲解了 Kafka 的实战和内核，你可以加以学习和使用。\n来自极客时间专栏“Kafka核心技术与实战”\n基于消息队列的 Orderbook 数据流 link最后回到我们的量化交易系统上。\n量化交易系统中，获取 orderbook 一般有两种用途：策略端获取实时数据，用来做决策；备份在文件或者数据库中，方便让策略和回测系统将来使用。\n如果我们直接单机监听交易所的消息，风险将会变得很大，这在分布式系统中叫做 Single Point Failure。一旦这台机器出了故障，或者网络连接突然中断，我们的交易系统将立刻暴露于风险中。\n于是，一个很自然的想法就是，我们可以在不同地区放置不同的机器，使用不同的网络同时连接到交易所，然后将这些机器收集到的信息汇总、去重，最后生成我们需要的准确数据。相应的拓扑图如下：\n当然，这种做法也有很明显的缺点：因为要同时等待多个数据服务器的数据，再加上消息队列的潜在处理延迟和网络延迟，对策略服务器而言，可能要增加几十到数百毫秒的延迟。如果是一些高频或者滑点要求比较高的策略，这种做法需要谨慎考虑。\n但是，对于低频策略、波段策略，这种延迟换来的整个系统的稳定性和架构的解耦性，还是非常值得的。不过，你仍然需要注意，这种情况下，消息队列服务器有可能成为瓶颈，也就是刚刚所说的Single Point Failure，一旦此处断开，依然会将系统置于风险之中。\n事实上，我们可以使用一些很成熟的系统，例如阿里的消息队列，AWS 的 Simple Queue Service 等等，使用这些非常成熟的消息队列系统，风险也将会最小化。\n总结 link这节课，我们分析了现代化软件工程领域中的中间件系统，以及其中的主要应用——消息队列。我们讲解了最基础的消息队列的模式，包括点对点模型、发布者订阅者模型，和一些其他消息队列自己支持的模型。\n在真实的项目设计中，我们要根据自己的产品需求，来选择使用不同的模型；同时也要在编程实践中，加深对不同技能点的了解，对系统复杂性进行解耦，这才是设计出高质量系统的必经之路。\n思考题 link今天的思考题，文中我也提到过，这里再专门列出强调一下。在ZMQ 那里，我提出了两个问题：\n如果你试着把发布者的 time.sleep(1) 放在 while 循环的最后，会发生什么？为什么？ 如果有多个发布者，ZMQ 应该怎么做呢？ 欢迎留言写下你的思考和疑惑，也欢迎你把这篇文章分享给更多的人一起学习。\n（2）对于有多个发布者，zmq要求不同的发布者绑定到不同的端口，多个发布者还是可以正常发送信息，而对于订阅者，需要绑定对应的发布者端口才能接受到发布者发送的信息。\n以上见解，有错误之处请老师指正。2020-03-07hel793 👍（1） 💬（0）需安装 pyzmq2019-09-14小侠龙旋风 👍（1） 💬（0）socket.bind('tcp://:6666')这句话里域名写成是不是指任意域名？2019-08-04张申傲 👍（0） 💬（0）第37讲打卡~2024-07-17Geek_fc975d 👍（0） 💬（0）老师，使用pip install zmq的安装方式安装后，发现很多函数不能用，请教这是怎么回事？2022-04-2306 👍（0） 💬（0）文章提到中低频策略可以使用消息队列提高稳定性，那么高频策略有没有类似的实现？2021-09-04\n"
            }
        );
    index.add(
            {
                id:  20 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/38---mysql%E6%97%A5%E5%BF%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F\/",
                title: "38 - MySQL：日志和数据存储系统",
                description: "你好，我是景霄。今天这节课，我们来聊聊日志和存储系统。\n在互联网公司中，日志系统是一个非常重要的技术底层。在每一次重要的交互行为中，关键信息都会被记录下来存档，以供日后线下分析，或者线上实时分析。这些数据，甚至可以说是硅谷互联网大公司的命脉所在。\n有了它们，你才能建立机器学习模型来预测用户的行为，从而可以精确描绘用户画像，然后针对性地使用推荐系统、分类器，将用户进一步留下，并精准推送广告来盈利。\n在量化交易中，日志同样有着非常重要的作用。一如前面所讲，我们重要的数据有：行情数据、策略信号、执行情况、仓位信息等等非常多的信息。\n对于简单的、小规模的数据，例如 orderbook 信息，我们完全可以把数据存在 txt、csv 文件中，这样做简单高效。不过，缺点是，随着数据量上升，一个文件将会变得非常大，检索起来也不容易。这时，一个很直观的方式出现了，我们可以把每天的数据存在一个文件中，这样就暂时缓解了尴尬。\n但是，随着数据量的上升，或者是你的算法逐渐来到高频交易领域时，简单地把数据存在文件上，已经不足以满足新的需求，更无法应对分布式量化交易系统的需求。于是，一个显而易见的想法就是，我们可以把日志存在数据库系统中。\n这节课，我们就以 MySQL 这种传统型关系数据库为例，讲解一下数据库在日志中的运用。\n快速理解MySQL link担心一些同学没有数据库的基础，我先来简单介绍一下 MySQL 数据库。\nMySQL 属于典型的关系型数据库（RDBMS），所谓的关系型数据库，就是指建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法，来处理数据库中的数据。基本上任何学习资料都会告诉你，它有着下面这几个特征：\n数据是以表格的形式出现的； 每一行是各种记录名称； 每一列是记录名称所对应的数据域； 许多的行和列，组成一张表单； 若干的表单，组成数据库（database）这个整体。 不过，抛开这些抽象的特征不谈，你首先需要掌握的，是下面这些术语的概念。\n数据库，是一些关联表的集合；而数据表则是数据的矩阵。在一个数据库中，数据表看起来就像是一个简单的电子表格。 在数据表中，每一列包含的是相同类型的数据；每一行则是一组相关的数据。 主键也是数据表中的一个列，只不过，这一列的每行元素都是唯一的，且一个数据表中只能包含一个主键；而外键则用于关联两个表。 除此之外，你还需要了解索引。索引是对数据库表中一列或多列的值进行排序的一种结构。使用索引，我们可以快速访问数据库表中的特定信息。一般来说，你可以对很多列设置索引，这样在检索指定列的时候，就大大加快了速度，当然，代价是插入数据会变得更慢。\n至于操作 MySQL，一般用的是结构化查询语言SQL。SQL是一种典型的领域专用语言（domain-specific language，简称DSL），这里我就不做过多介绍了，如果你感兴趣，可以学习极客时间平台上的“SQL必知必会”专栏。\n",
                content: "你好，我是景霄。今天这节课，我们来聊聊日志和存储系统。\n在互联网公司中，日志系统是一个非常重要的技术底层。在每一次重要的交互行为中，关键信息都会被记录下来存档，以供日后线下分析，或者线上实时分析。这些数据，甚至可以说是硅谷互联网大公司的命脉所在。\n有了它们，你才能建立机器学习模型来预测用户的行为，从而可以精确描绘用户画像，然后针对性地使用推荐系统、分类器，将用户进一步留下，并精准推送广告来盈利。\n在量化交易中，日志同样有着非常重要的作用。一如前面所讲，我们重要的数据有：行情数据、策略信号、执行情况、仓位信息等等非常多的信息。\n对于简单的、小规模的数据，例如 orderbook 信息，我们完全可以把数据存在 txt、csv 文件中，这样做简单高效。不过，缺点是，随着数据量上升，一个文件将会变得非常大，检索起来也不容易。这时，一个很直观的方式出现了，我们可以把每天的数据存在一个文件中，这样就暂时缓解了尴尬。\n但是，随着数据量的上升，或者是你的算法逐渐来到高频交易领域时，简单地把数据存在文件上，已经不足以满足新的需求，更无法应对分布式量化交易系统的需求。于是，一个显而易见的想法就是，我们可以把日志存在数据库系统中。\n这节课，我们就以 MySQL 这种传统型关系数据库为例，讲解一下数据库在日志中的运用。\n快速理解MySQL link担心一些同学没有数据库的基础，我先来简单介绍一下 MySQL 数据库。\nMySQL 属于典型的关系型数据库（RDBMS），所谓的关系型数据库，就是指建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法，来处理数据库中的数据。基本上任何学习资料都会告诉你，它有着下面这几个特征：\n数据是以表格的形式出现的； 每一行是各种记录名称； 每一列是记录名称所对应的数据域； 许多的行和列，组成一张表单； 若干的表单，组成数据库（database）这个整体。 不过，抛开这些抽象的特征不谈，你首先需要掌握的，是下面这些术语的概念。\n数据库，是一些关联表的集合；而数据表则是数据的矩阵。在一个数据库中，数据表看起来就像是一个简单的电子表格。 在数据表中，每一列包含的是相同类型的数据；每一行则是一组相关的数据。 主键也是数据表中的一个列，只不过，这一列的每行元素都是唯一的，且一个数据表中只能包含一个主键；而外键则用于关联两个表。 除此之外，你还需要了解索引。索引是对数据库表中一列或多列的值进行排序的一种结构。使用索引，我们可以快速访问数据库表中的特定信息。一般来说，你可以对很多列设置索引，这样在检索指定列的时候，就大大加快了速度，当然，代价是插入数据会变得更慢。\n至于操作 MySQL，一般用的是结构化查询语言SQL。SQL是一种典型的领域专用语言（domain-specific language，简称DSL），这里我就不做过多介绍了，如果你感兴趣，可以学习极客时间平台上的“SQL必知必会”专栏。\n接下来，我们就来简单看一下，如何使用 Python 来操作 MySQL 数据库。\nPython 连接数据库的方式有好多种，这里我简单介绍其中两种。我们以 Ubuntu 为例，假设你的系统中已经安装过 MySQL Server。（安装 MySQL可以参考这篇文章 https://www.jianshu.com/p/3111290b87f4，或者你可以自行搜索解决）\nmysqlclient link事实上， Python 连接 MySQL 最流行的一个驱动是 MySQL-python，又叫 MySQLdb，很多框架都也是基于此库进行开发。不过，遗憾的是，它只支持 Python2.x，而且安装的时候有很多前置条件。因为它是基于C开发的库，在 Windows 平台安装非常不友好，经常出现失败的情况。所以，现在我们基本不再推荐使用，取代者是它的衍生版本——mysqlclient。\nmysqlclient 完全兼容 MySQLdb，同时支持 Python3.x，是 Django ORM的依赖工具。如果你想使用原生 SQL 来操作数据库，那么我优先推荐使用这个框架。\n它的安装方式很简单：\nsudo apt-get install python3-dev\rpip install mysqlclient 我们来看一个样例代码：\nimport MySQLdb\rdef test_pymysql():\rconn = MySQLdb.connect(\rhost='localhost',\rport=3306,\ruser='your_username',\rpasswd=your_password’,\rdb='mysql'\r)\rcur = conn.cursor()\rcur.execute('''\rCREATE TABLE price (\rtimestamp TIMESTAMP NOT NULL,\rBTCUSD FLOAT(8,2),\rPRIMARY KEY (timestamp)\r);\r''')\rcur.execute('''\rINSERT INTO price VALUES(\r\"2019-07-14 14:12:17\",\r11234.56\r);\r''')\rconn.commit()\rconn.close()\rtest_pymy 代码的思路很清晰明了，首先是通过 connect 命令连接数据库，来创建一个连接；之后，通过 conn.cursor() 函数创建一个游标。这里你可能会问，为什么要使用游标呢？\n一个主要的原因就是，这样可以把集合操作转换成单个记录处理的方式。如果用 SQL 语言从数据库中检索数据，结果会放在内存的一块区域中，并且这个结果往往是一个含有多个记录的集合。而游标机制，则允许用户在 MySQL 内逐行地访问这些记录，这样你就可以按照自己的意愿，来显示和处理这些记录。\n继续回到代码中，再往下走，我们创建了一个 price table，同时向里面插入一条 orderbook 数据。这里为了简化代码突出重点，我只保留了 timestamp 和 price。\n最后，我们使用 conn.commit() 来提交更改，然后 close() 掉连接就可以了。\npeewee link不过，大家逐渐发现，写原生的 SQL 命令很麻烦。因为你需要根据特定的业务逻辑，来构造特定的插入和查询语句，这样可以说就完全抛弃了面向对象的思维。因此，又诞生了很多封装 wrapper 包和 ORM 框架。\n这里所说的ORM（Object Relational Mapping，简称ORM） ，是 Python 对象与数据库关系表的一种映射关系，有了 ORM 后，我们就不再需要写 SQL 语句，而可以直接使用 Python 的数据结构了。\nORM 框架的优点，是提高了写代码的速度，同时兼容多种数据库系统，如SQLite、MySQL、PostgreSQL等这些数据库；而付出的代价，可能就是性能上的一些损失。\n接下来要讲的peewee，正是其中一种基于 Python 的 ORM 框架，它的学习成本非常低，可以说是 Python 中最流行的 ORM 框架。\n它的安装方式也很简单：\npip install peewee 我们来看一个样例代码：\nimport peewee\rfrom peewee import *\rdb = MySQLDatabase('mysql', user='your_username', passwd=your_password’)\rclass Price(peewee.Model):\rtimestamp = peewee.DateTimeField(primary_key=True)\rBTCUSD = peewee.FloatField()\rclass Meta:\rdatabase = db\rdef test_peewee():\rPrice.create_table()\rprice = Price(timestamp='2019-06-07 13:17:18', BTCUSD='12345.67')\rprice.save()\rtest_p 如果你写过 Django，你会发现，这个写法和 Django 简直一模一样。我们通过一个 Python class ，映射了 MySQL 中的一张数据表；只要对其中每一列数据格式进行定义，便可按照 Python 的方式进行操作。\n显而易见，peewee的最大优点，就是让 SQL 语言瞬间变成强类型语言，这样不仅极大地增强了可读性，也能有效减少出 bug 的概率。\n不过，事实上，作为一名数据科学家，或者作为一名量化从业者（quant ），你要处理的数据远比这些复杂很多。互联网工业界有大量的脏数据，金融行业的信噪比更是非常之低，数据处理只能算是基本功。\n如果你对数据分析有兴趣和志向，在学生时期就应该先打牢数学和统计的基础，之后在实习和工作中快速掌握数据处理的方法。当然，如果你已经错过学生时期的话，现在开始也是个不错的选择，毕竟，逐渐形成自己的核心竞争力，才是我们每个人的正道。\n量化数据分析系统 link数据库有了量化数据存入后，接下来，我们便可以开始进行一些量化分析了。这一块儿也是一个很大的学术领域，叫做时间序列分析，不过就今天这节课的主题来说，我们仅做抛砖引玉，列举一个非常简单的例子，即求过去一个小时 BTC/USD 的最高价和最低价。\n我们来看下面这段代码：\nimport MySQLdb\rimport numpy as np\rdef test_pymysql():\rconn = MySQLdb.connect(\rhost='localhost',\rport=3306,\ruser='your_username',\rpasswd='your_password',\rdb='mysql'\r)\rcur = conn.cursor()\rcur.execute('''\rSELECT\rBTCUSD\rFROM\rprice\rWHERE\rtimestamp \u003e now() - interval 60 minute\r''')\rBTCUSD = np.array(cur.fetchall())\rprint(BTCUSD.max(), BTCUSD.min())\rconn.close()\rtest_pym 代码看起来很简单吧！显然，通过 SQL 语句，我们可以抓取到过去一小时的时间序列片段，拿到我们想要的 BTC/USD 价格向量，然后通过 numpy 处理一下即可。不过这里需要注意一点，我们并不需要调用 conn.commit()，因为我们的操作是只读的，对数据库没有任何影响。\n分布式日志系统 link明白了上面的内容后，我们现在来看一下分布式日志系统。\n对量化交易而言，我们需要的模块主要有数据系统、策略系统、交易执行系统、线下模型训练、线上风控系统以及实时监控系统。它们之间的对应关系，我画了一张图，你可以参考来理解。\n这里的每个子系统都是独立运行的，并且还有许多模块需要迭代更新，所以我们简单保存本地日志显然不是一个明智之举。于是，我们可以专门开一台服务器来运行 MySQL server，并且开放指定端口和其他系统进行交互。\n另外，图中的收集系统，其实类似于上一节我们所讲的消息队列体系，在各个上游系统中运行代理工具，负责将各个模块的 log 收集起来，然后发送到收集系统中。收集系统整理过后，再将信息存到日志系统。当然，除了简单的消息队列，我们还能用很多工具，比如阿里云的Logtail、 Apache 的 Flume Agent等等。\n而到了后期，对于日志系统来说，越来越需要注意的就是存储效率和分析效率。随着使用的增加，数据会越来越多，因此我们可以考虑对一些数据进行压缩和保存。而越是久远的数据，越是粗粒度的数据，被调用的概率也就越低，所以它们也就首当其冲，成了我们压缩、保存的目标。\n日志分析 link最后，我再来补充讲一讲日志的分析。前面提到过，分析一般分为两种，离线分析和在线分析。\n在离线分析中，比较常见的是生成报告。\n比如，总结某天某月或某季度内的，收益亏损情况（PnL）、最大回撤、夏普比率等数据。这种基于时间窗口的统计，在关系型数据库中也能得到很方便的支持。\n而另一类常见的离线使用方式，则是回测系统。在一个新策略研发的周期中，我们需要对历史数据进行回测，这样就可以得到历史数据中交易的收益率等数据。回测系统对于评估一个新的策略非常重要，然而，回测往往需要大量的资源，所以选取好数据库、数据存储方式，优化数据连接和计算，就显得至关重要。\n在线分析，则更多应用于风控和警报系统。这种方式，对数据的实时性要求更高一些，于是，一种方法就是，从消息队列中直接拿最快的数据进行操作。当然，这个前提是时间窗口较小，这样你就不需要风控系统来维护大量的本地数据。\n至于实时警报，最关键的依然是数据。\n比如，数据系统异常停止，被监视的表没有更新； 或者，交易系统的连接出了故障，委托订单的某些状态超过了一定的阈值； 再或者，仓位信息出现了较大的、预计之外的变动。 这些情况都需要进行报警，也就是硅谷大公司所说的“oncall”。一旦发生意外，负责人会迅速收到电话、短信和邮件，然后通过监控平台来确认，是真的出了事故还是监控误报。\n当然，现在已经有了不少开源的工具可以在云端使用，其中 AWS 属于全球领先的云计算平台。如果你的服务器架设在美国，那就可以考虑选择它家的各种各样的云服务。这样做的好处是，对于小型量化交易团队而言，避免自己搭建复杂的日志系统，而是把主要精力放在策略的开发迭代之上，提高了不少效率。\n总结 link这一节课，我从工程的角度，为你介绍了量化系统中的存储系统。我们从基础的 MySQL 的使用方法讲起，再讲到后面的量化系统框架。数据库和数据在绝大部分互联网行业都是核心，对量化从业者来说也是重要的生产资料。而搭建一套负载合理、数据可靠的数据系统，也需要一个量化团队长期打磨，并根据需求进行迭代。\n思考题 link最后给你留一道思考题。量化交易需要的数据量不是很大，但是有可能出现调用频率极高的情况，例如回测系统。那么，你能想到哪些优化手段，来降低调用代价吗？欢迎留言和我讨论，也欢迎你把这篇文章分享出去。\n"
            }
        );
    index.add(
            {
                id:  21 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/39---django%E6%90%AD%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0\/",
                title: "39 - Django：搭建监控平台",
                description: "你好，我是景霄。\n通过前几节课的学习，相信你对量化交易系统已经有了一个最基本的认知，也能通过自己的代码，搭建一个简单的量化交易系统来进行盈利。\n前面几节课，我们的重点在后台代码、中间件、分布式系统和设计模式上。这节课，我们重点来看前端交互。\n监控和运维，是互联网工业链上非常重要的一环。监控的目的就是防患于未然。通过监控，我们能够及时了解到企业网络的运行状态。一旦出现安全隐患，你就可以及时预警，或者是以其他方式通知运维人员，让运维监控人员有时间处理和解决隐患，避免影响业务系统的正常使用，将一切问题的根源扼杀在摇篮当中。\n在硅谷互联网大公司中，监控和运维被称为 SRE，是公司正常运行中非常重要的一环。作为 billion 级别的 Facebook，内部自然也有着大大小小、各种各样的监控系统和运维工具，有的对标业务数据，有的对标服务器的健康状态，有的则是面向数据库和微服务的控制信息。\n不过，万变不离其宗，运维工作最重要的就是维护系统的稳定性。除了熟悉运用各种提高运维效率的工具来辅助工作外，云资源费用管理、安全管理、监控等，都需要耗费不少精力和时间。运维监控不是一朝一夕得来的，而是随着业务发展的过程中同步和发展的。\n作为量化实践内容的最后一节，今天我们就使用 Django 这个 Web 框架，来搭建一个简单的量化监控平台。\nDjango 简介和安装 linkDjango 是用 Python 开发的一个免费开源的 Web 框架，可以用来快速搭建优雅的高性能网站。它采用的是“MVC”的框架模式，即模型 M、视图 V 和控制器 C。\nDjango 最大的特色，在于将网页和数据库中复杂的关系，转化为 Python 中对应的简单关系。它的设计目的，是使常见的Web开发任务变得快速而简单。Django是开源的，不是商业项目或者科研项目，并且集中力量解决Web开发中遇到的一系列问题。所以，Django 每天都会在现有的基础上进步，以适应不断更迭的开发需求。这样既节省了开发时间，也提高了后期维护的效率。\n说了这么多，接下来，我们通过上手使用进一步来了解。先来看一下，如何安装和使用 Django。你可以先按照下面代码块的内容来操作，安装Django ：\npip3 install Django\rdjango-admin --version\r########## 输出 ##########\r2.2.3 接着，我们来创建一个新的 Django 项目：\ndjango-admin startproject TradingMonitor\rcd TradingMonitor/\rpython3 manage.py migrate\r########## 输出 ########## Applying contenttypes.0001_initial... OK\rApplying auth.0001_initial... OK\rApplying admin.0001_initial... OK\rApplying admin.0002_logentry_remove_auto_add... OK\rApplying admin.0003_logentry_add_action_flag_choices... OK\rApplying contenttypes.0002_remove_content_type_name... OK\rApplying auth.0002_alter_permission_name_max_length... OK\rApplying auth.0003_alter_user_email_max_length... OK\rApplying auth.0004_alter_user_username_opts... OK\rApplying auth.0005_alter_user_last_login_null... OK\rApplying auth.0006_require_contenttypes_0002... OK\rApplying auth.0007_alter_validators_add_error_messages... OK\rApplying auth.0008_alter_user_username_max_length... OK\rApplying auth.0009_alter_user_last_name_max_length... OK\rApplying auth.0010_alter_group_name_max_length... OK\rApplying auth.0011_update_proxy_permissions... OK\rApplying sessions.0001_initial... OK 这时，你能看到文件系统大概是下面这样的：\n",
                content: "你好，我是景霄。\n通过前几节课的学习，相信你对量化交易系统已经有了一个最基本的认知，也能通过自己的代码，搭建一个简单的量化交易系统来进行盈利。\n前面几节课，我们的重点在后台代码、中间件、分布式系统和设计模式上。这节课，我们重点来看前端交互。\n监控和运维，是互联网工业链上非常重要的一环。监控的目的就是防患于未然。通过监控，我们能够及时了解到企业网络的运行状态。一旦出现安全隐患，你就可以及时预警，或者是以其他方式通知运维人员，让运维监控人员有时间处理和解决隐患，避免影响业务系统的正常使用，将一切问题的根源扼杀在摇篮当中。\n在硅谷互联网大公司中，监控和运维被称为 SRE，是公司正常运行中非常重要的一环。作为 billion 级别的 Facebook，内部自然也有着大大小小、各种各样的监控系统和运维工具，有的对标业务数据，有的对标服务器的健康状态，有的则是面向数据库和微服务的控制信息。\n不过，万变不离其宗，运维工作最重要的就是维护系统的稳定性。除了熟悉运用各种提高运维效率的工具来辅助工作外，云资源费用管理、安全管理、监控等，都需要耗费不少精力和时间。运维监控不是一朝一夕得来的，而是随着业务发展的过程中同步和发展的。\n作为量化实践内容的最后一节，今天我们就使用 Django 这个 Web 框架，来搭建一个简单的量化监控平台。\nDjango 简介和安装 linkDjango 是用 Python 开发的一个免费开源的 Web 框架，可以用来快速搭建优雅的高性能网站。它采用的是“MVC”的框架模式，即模型 M、视图 V 和控制器 C。\nDjango 最大的特色，在于将网页和数据库中复杂的关系，转化为 Python 中对应的简单关系。它的设计目的，是使常见的Web开发任务变得快速而简单。Django是开源的，不是商业项目或者科研项目，并且集中力量解决Web开发中遇到的一系列问题。所以，Django 每天都会在现有的基础上进步，以适应不断更迭的开发需求。这样既节省了开发时间，也提高了后期维护的效率。\n说了这么多，接下来，我们通过上手使用进一步来了解。先来看一下，如何安装和使用 Django。你可以先按照下面代码块的内容来操作，安装Django ：\npip3 install Django\rdjango-admin --version\r########## 输出 ##########\r2.2.3 接着，我们来创建一个新的 Django 项目：\ndjango-admin startproject TradingMonitor\rcd TradingMonitor/\rpython3 manage.py migrate\r########## 输出 ########## Applying contenttypes.0001_initial... OK\rApplying auth.0001_initial... OK\rApplying admin.0001_initial... OK\rApplying admin.0002_logentry_remove_auto_add... OK\rApplying admin.0003_logentry_add_action_flag_choices... OK\rApplying contenttypes.0002_remove_content_type_name... OK\rApplying auth.0002_alter_permission_name_max_length... OK\rApplying auth.0003_alter_user_email_max_length... OK\rApplying auth.0004_alter_user_username_opts... OK\rApplying auth.0005_alter_user_last_login_null... OK\rApplying auth.0006_require_contenttypes_0002... OK\rApplying auth.0007_alter_validators_add_error_messages... OK\rApplying auth.0008_alter_user_username_max_length... OK\rApplying auth.0009_alter_user_last_name_max_length... OK\rApplying auth.0010_alter_group_name_max_length... OK\rApplying auth.0011_update_proxy_permissions... OK\rApplying sessions.0001_initial... OK 这时，你能看到文件系统大概是下面这样的：\nTradingMonitor/\r├── TradingMonitor\r│ ├── __init__.py\r│ ├── settings.py\r│ ├── urls.py\r│ └── wsgi.py\r├── db.sqlite3\r└── manage.py 我简单解释一下它的意思：\nTradingMonitor/TradingMonitor，表示项目最初的 Python 包； TradingMonitor/init.py，表示一个空文件，声明所在目录的包为一个 Python 包； TradingMonitor/settings.py，管理项目的配置信息； TradingMonitor/urls.py，声明请求 URL 的映射关系； TradingMonitor/wsgi.py，表示Python 程序和 Web 服务器的通信协议； manage.py，表示一个命令行工具，用来和 Django 项目进行交互； Db.sqlite3，表示默认的数据库，可以在设置中替换成其他数据库。 另外，你可能注意到了上述命令中的python3 manage.py migrate，这个命令表示创建或更新数据库模式。每当 model 源代码被改变后，如果我们要将其应用到数据库上，就需要执行一次这个命令。\n接下来，我们为这个系统添加管理员账户：\npython3 manage.py createsuperuser\r########## 输出 ##########\rUsername (leave blank to use 'ubuntu'): admin\rEmail address: Password: Password (again): Superuser created successfully. 然后，我们来启动 Django 的 debugging 模式：\npython3 manage.py runserver 最后，打开浏览器输入：http://127.0.0.1:8000。如果你能看到下面这个画面，就说明 Django 已经部署成功了。\nDjango 的安装是不是非常简单呢？这其实也是 Python 一贯的理念，简洁，并简化入门的门槛。\nOK，现在我们再定位到 http://127.0.0.1:8000/admin，你会看到 Django 的后台管理网页，这里我就不过多介绍了。\n到此，Django 就已经成功安装，并且正常启动啦。\nMVC 架构 link刚刚我说过，MVC 架构是 Django 设计模式的精髓。接下来，我们就来具体看一下这个架构，并通过 Django 动手搭建一个服务端。\n设计模型 Model link在之前的日志和存储系统这节课中，我介绍过 peewee 这个库，它能避开通过繁琐的 SQL 语句来操作 MySQL，直接使用 Python 的 class 来进行转换。事实上，这也是 Django 采取的方式。\nDjango 无需数据库就可以使用，它通过对象关系映射器（object-relational mapping），仅使用Python代码就可以描述数据结构。\n我们先来看下面这段 Model 代码：\n# TradingMonitor/models.py\rfrom django.db import models\rclass Position(models.Model):\rasset = models.CharField(max_length=10)\rtimestamp = models.DateTimeField()\ramount = models.DecimalField(max_digits=10, decimal_places=3) models.py 文件主要用一个 Python 类来描述数据表，称为模型 。运用这个类，你可以通过简单的 Python 代码来创建、检索、更新、删除数据库中的记录，而不用写一条又一条的SQL语句，这也是我们之前所说的避免通过 SQL 操作数据库。\n在这里，我们创建了一个 Position 模型，用来表示我们的交易仓位信息。其中，\nasset 表示当前持有资产的代码，例如 btc； timestamp 表示时间戳； amount 则表示时间戳时刻的持仓信息。 设计视图 Views link在模型被定义之后，我们便可以在视图中引用模型了。通常，视图会根据参数检索数据，加载一个模板，并使用检索到的数据呈现模板。\n设计视图，则是我们用来实现业务逻辑的地方。我们来看 render_positions 这个代码，它接受 request 和 asset 两个参数，我们先不用管 request。这里的 asset 表示指定一个资产名称，例如 btc，然后这个函数返回一个渲染页面。\n# TradingMonitor/views.py\rfrom django.shortcuts import render\rfrom .models import Position\rdef render_positions(request, asset):\rpositions = Position.objects.filter(asset = asset)\rcontext = {'asset': asset, 'positions': positions}\rreturn render(request, 'positions.html', context) 不过，这个函数具体是怎么工作的呢？我们一行行来看。\npositions = Position.objects.filter(asset = asset)，这行代码向数据库中执行一个查询操作，其中， filter 表示筛选，意思是从数据库中选出所有我们需要的 asset 的信息。不过，这里我只是为你举例做示范；真正做监控的时候，我们一般会更有针对性地从数据库中筛选读取信息，而不是一口气读取出所有的信息。\ncontext = {'asset': asset, 'positions': positions}，这行代码没什么好说的，封装一个字典。至于这个字典的用处，下面的内容中可以体现。\nreturn render(request, 'positions.html', context)，最后这行代码返回一个页面。这里我们采用的模板设计，这也是 Django 非常推荐的开发方式，也就是让模板和数据分离，这样，数据只需要向其中填充即可。\n最后的模板文件是 position.html，你应该注意到了， context 作为变量传给了模板，下面我们就来看一下设计模板的内容。\n设计模板Templates link模板文件，其实就是 HTML 文件和部分代码的综合。你可以想象成，这个HTML 在最终送给用户之前，需要被我们预先处理一下，而预先处理的方式就是找到对应的地方进行替换。\n我们来看下面这段示例代码：\n# TradingMonitor/templates/positions.html\r\u003c!DOCTYPE html\u003e\rPositions for {{asset}}\rPositions for {{asset}}\rTime\rAmount\r{% for position in positions %}\r{{position.timestamp}}\r{{position.amount}}\r{% endfor %}\r我重点说一下几个地方。首先是Positions for {{asset}}，这里双大括号括住 asset 这个变量，这个变量对应的正是前面 context 字典中的 asset key。Django 的渲染引擎会将 asset ，替换成 context 中 asset 对应的内容，此处是替换成了 btc。\n再来看{% for position in positions %}，这是个很关键的地方。我们需要处理一个列表的情况，用 for 对 positions 进行迭代就行了。这里的 positions ，同样对应的是 context 中的 positions。\n末尾的{% endfor %}，自然就表示结束了。这样，我们就将数据封装到了一个列表之中。\n设计链接 Urls link最后，我们需要为我们的操作提供 URL 接口，具体操作我放在了下面的代码中，内容比较简单，我就不详细展开讲解了。\n# TradingMonitor/urls.py\rfrom django.contrib import admin\rfrom django.urls import path\rfrom . import views\rurlpatterns = [\rpath('admin/', admin.site.urls),\rpath('positions/', views.render_positions),\r] 到这里，我们就可以通过 http://127.0.0.1:8000/positions/btc 来访问啦！\n测试 link当然，除了主要流程外，我还需要强调几个很简单但非常关键的细节，不然，我们这些改变就不能被真正地应用。\n第一步，在 TradingMonitor/TradingMonitor 下，新建一个文件夹 migrations；并在这个文件夹中，新建一个空文件 __init__.py。\nmkdir TradingMonitor/migrations\rtouch TradingMonitor/migrations/__init__.py 此时，你的目录结构应该长成下面这样：\nTradingMonitor/\r├── TradingMonitor\r│ ├── migrations\r│ └── __init__.py\r│ ├── templates\r│ └── positions.html\r│ ├── __init__.py\r│ ├── settings.py\r│ ├── urls.py\r│ ├── models.py\r│ ├── views.py\r│ └── wsgi.py\r├── db.sqlite3\r└── manage.py 第二步，修改 TradingMonitor/settings.py：\nINSTALLED_APPS = [\r'django.contrib.admin',\r'django.contrib.auth',\r'django.contrib.contenttypes',\r'django.contrib.sessions',\r'django.contrib.messages',\r'django.contrib.staticfiles',\r'TradingMonitor', # 这里把我们的 app 加上\r] TEMPLATES = [\r{\r'BACKEND': 'django.template.backends.django.DjangoTemplates',\r'DIRS': [os.path.join(BASE_DIR, 'TradingMonitor/templates')], # 这里把 templates 的目录加上\r'APP_DIRS': True,\r'OPTIONS': {\r'context_processors': [\r'django.template.context_processors.debug',\r'django.template.context_processors.request',\r'django.contrib.auth.context_processors.auth',\r'django.contrib.messages.context_processors.messages',\r],\r},\r},\r] 第三步，运行 python manage.py makemigrations：\npython manage.py makemigrations\r########## 输出 ##########\rMigrations for 'TradingMonitor':\rTradingMonitor/migrations/0001_initial.py\r- Create model Position 第四步，运行 python manage.py migrate：\npython manage.py migrate\r########## 输出 ##########\rOperations to perform:\rApply all migrations: TradingMonitor, admin, auth, contenttypes, sessions\rRunning migrations:\rApplying TradingMonitor.0001_initial... OK 这几步的具体操作，我都用代码和注释表示了出来，你完全可以同步进行操作。操作完成后，现在，我们的数据结构就已经被成功同步到数据库中了。\n最后，输入 python manage.py runserver，然后打开浏览器输入http://127.0.0.1:8000/positions/btc，你就能看到效果啦。\n现在，我们再回过头来看一下 MVC 模式，通过我画的这张图，你可以看到，M、V、C这三者，以一种插件似的、松耦合的方式连接在一起：\n当然，我带你写的只是一个简单的 Django 应用程序，对于真正的量化平台监控系统而言，这还只是一个简单的开始。\n除此之外，对于监控系统来说，其实还有着非常多的开源插件可以使用。有一些界面非常酷炫，有一些可以做到很高的稳定性和易用性，它们很多都可以结合 Django 做出很好的效果来。比较典型的有：\nGraphite 是一款存储时间序列数据，并通过 Django Web 应用程序在图形中显示的插件； Vimeo 则是一个基于 Graphite 的仪表板，具有附加功能和平滑的设计； Scout 监控 Django和Flask应用程序的性能，提供自动检测视图、SQL查询、模板等。 总结 link这一节课的内容更靠近上游应用层，我们以 Django 这个 Python 后端为例，讲解了搭建一个服务端的过程。你应该发现了，使用 RESTful Framework 搭建服务器，是一个如此简单的过程，你可以去开一个自己的交易所了（笑）。相比起具体的技术，今天我所讲的 MVC 框架和 Django 的思想，更值得你去深入学习和领会。\n思考题 link今天我想给你留一个难度比较高的作业。RESTful API 在 Django 中是如何实现安全认证的？你能通过搜索和自学掌握这个知识点吗？希望可以在留言区看到你的认真学习记录和总结，我会一一给出建议。也欢迎你把这篇文章分享给你的朋友、同事，一起交流、一起进步。\n########## 输出 ##########\n2.2.3 老师 django的这些命令再Windows CMD命令框执行后不行，访问不了https://127.0.0.1:8000, 再centos 执行完所有代码 启动后django 服务，命令显示[root@localhost TradingMonitor]# python3 manage.py runserver Watching for file changes with StatReloader Performing system checks…\nSystem check identified no issues (0 silenced). August 12, 2020 - 15:59:14 Django version 3.1, using settings 'TradingMonitor.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C. ，但是浏览器访问失败 是什么原因2020-08-12Geek_aa780e 👍（1） 💬（0）可以讲一下在web项目中，对于非法情况，比如说数据库链接错误报的异常，该怎么处理吗？ 是直接抛到handler层，还是在哪进行捕获？ 2020-08-05\n"
            }
        );
    index.add(
            {
                id:  22 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/40---%E6%80%BB%E7%BB%93python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A8%E6%99%AF\/",
                title: "40 - 总结：Python中的数据结构与算法全景",
                description: "你好，我是景霄。\n不知不觉中，我们又一起完成了量化交易实战篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。\n实战篇的主要用意，是通过一个完整的技术领域，讲明白 Python 在这个领域中如何发挥作用。所以，我们在每节课都会梳理一个小知识点；同时，也在第 36 讲中，我用大量篇幅讲解了策略和回测系统，作为量化交易中最重要内容的解释。\n对于本章答疑，因为不断有同学留言询问Python中数据结构和算法相关的问题，我在这里也简单说一下。\n首先，希望你明白，我们Python 专栏的定位是有一定计算机知识基础的进阶课程，重点在 Python 的核心知识点上，默认你对基础的算法和数据结构有一定的了解。因此，在语法和技术知识点的讲解过程中，我会综合性地穿插不少数据结构的基本知识，但并不会进行深入地讲解。涉及到数据结构中的关键名词和难点，自然都会有所提及，但还是希望你有一定的自学能力来掌握。\n不过，为了进一步方便你理解Python的数据结构和算法，加深对 Python 基础内容的掌握，我在这里总结了一个综合性的提纲。如果你在这方面有所欠缺，可以参考性地借鉴学习一下。当然，有时间和精力的话，我最鼓励的是你可以通过 Python 把所有数据结构和算法实现一下。\n基础数据结构：数组，堆，栈，队列，链表 link数组自不必多说，Python 中的基础数组，满足 O(1) 的随机查找，和 O(n) 的随机插入。\n堆，严格来讲，是一种特殊的二叉树，满足 O(nlogn) 的随机插入和删除，以及 O(1) 时间复杂度拿到最大值或者最小值。堆可以用来实现优先队列，还可以在项目中实现多任务调度，有着非常广泛的应用。\n栈，是一种先进后出的数据结构，入栈和出栈操作都是 O(1) 时间复杂度。\n队列和栈对应，不过功能刚好相反，它是一种先进先出的数据结构，一如其名，先排队者先服务。入队和出队也是 O(1) 的时间复杂度。栈和队列都能用数组来实现，但是对空间的规划需要注意，特别是用数组实现的队列，我们通常用的是循环队列。\n链表则是另一种线性表，和数组的不同是，它不支持随机访问，你不能通过下标来获取链表的元素。链表的元素通过指针相连，单链表中元素可以指向后者，双链表则是让相邻的元素互相连接。\n这些基础数据结构，在 Python 中都有很好的库和包支持，从使用上来说都非常方便，但我仍然希望你对原理能有一定的了解，这样，处理起复杂问题也能得心应手不胆怯。\n进阶数据结构：无向图，有向图，树，DAG 图，字典树，哈希表 link无向图，是由顶点和边组成的数据结构，一条边连接两个顶点（如果两个顶点是一个，这条边称为自环）。一如其名，“无向”，所以它的边没有指向性。\n有向图，和无向图一样都是“图”这种数据结构，不同的是有向图的边有指向性，方向为一个顶点指向另一个顶点。\n树这种数据结构，则可以分为有根树和无根树。前者中，最常见的就是我们的二叉树，从顶点开始一级级向下，每个父结点最多有两个子结点。至于无根树，则是一种特殊的无向图，无环连通的无向图被称为无根树，它有很多特别的性质和优点，在离散数学中应用广泛。\nDAG 图，也叫做有向无环图，是一种特殊应用的数据结构，在图的动态规划问题中出现甚多。遍历 DAG 图的方式，也就是我们常说的拓扑排序，是一种图算法。DAG 可以认为是链表的图版本，如果说区块链是链表，那么区块链 3.0 时代可能就是 DAG 图。\n字典树，又被称为 Trie 树，是一种边为字符的有向图，它在字符串处理中有着非常强大的应用。广为人知的 AC 自动机，就是用 Trie 树来解决多模式字符串匹配问题。Trie 树在工业界也常被拿来做搜索提示，例如你在百度中搜索 “极客时”，就会自动跳出 “极客时间”。\n哈希表，这一定是程序员应用最广、自觉最简单的一个数据结构，比如 Python 的 dict() 就可以拿来即用，简单而自然。不过，哈希表其实有着非常深刻的内涵，冲突算法、哈希算法、扩容算法，都很值得我们去深究一下。\n",
                content: "你好，我是景霄。\n不知不觉中，我们又一起完成了量化交易实战篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。\n实战篇的主要用意，是通过一个完整的技术领域，讲明白 Python 在这个领域中如何发挥作用。所以，我们在每节课都会梳理一个小知识点；同时，也在第 36 讲中，我用大量篇幅讲解了策略和回测系统，作为量化交易中最重要内容的解释。\n对于本章答疑，因为不断有同学留言询问Python中数据结构和算法相关的问题，我在这里也简单说一下。\n首先，希望你明白，我们Python 专栏的定位是有一定计算机知识基础的进阶课程，重点在 Python 的核心知识点上，默认你对基础的算法和数据结构有一定的了解。因此，在语法和技术知识点的讲解过程中，我会综合性地穿插不少数据结构的基本知识，但并不会进行深入地讲解。涉及到数据结构中的关键名词和难点，自然都会有所提及，但还是希望你有一定的自学能力来掌握。\n不过，为了进一步方便你理解Python的数据结构和算法，加深对 Python 基础内容的掌握，我在这里总结了一个综合性的提纲。如果你在这方面有所欠缺，可以参考性地借鉴学习一下。当然，有时间和精力的话，我最鼓励的是你可以通过 Python 把所有数据结构和算法实现一下。\n基础数据结构：数组，堆，栈，队列，链表 link数组自不必多说，Python 中的基础数组，满足 O(1) 的随机查找，和 O(n) 的随机插入。\n堆，严格来讲，是一种特殊的二叉树，满足 O(nlogn) 的随机插入和删除，以及 O(1) 时间复杂度拿到最大值或者最小值。堆可以用来实现优先队列，还可以在项目中实现多任务调度，有着非常广泛的应用。\n栈，是一种先进后出的数据结构，入栈和出栈操作都是 O(1) 时间复杂度。\n队列和栈对应，不过功能刚好相反，它是一种先进先出的数据结构，一如其名，先排队者先服务。入队和出队也是 O(1) 的时间复杂度。栈和队列都能用数组来实现，但是对空间的规划需要注意，特别是用数组实现的队列，我们通常用的是循环队列。\n链表则是另一种线性表，和数组的不同是，它不支持随机访问，你不能通过下标来获取链表的元素。链表的元素通过指针相连，单链表中元素可以指向后者，双链表则是让相邻的元素互相连接。\n这些基础数据结构，在 Python 中都有很好的库和包支持，从使用上来说都非常方便，但我仍然希望你对原理能有一定的了解，这样，处理起复杂问题也能得心应手不胆怯。\n进阶数据结构：无向图，有向图，树，DAG 图，字典树，哈希表 link无向图，是由顶点和边组成的数据结构，一条边连接两个顶点（如果两个顶点是一个，这条边称为自环）。一如其名，“无向”，所以它的边没有指向性。\n有向图，和无向图一样都是“图”这种数据结构，不同的是有向图的边有指向性，方向为一个顶点指向另一个顶点。\n树这种数据结构，则可以分为有根树和无根树。前者中，最常见的就是我们的二叉树，从顶点开始一级级向下，每个父结点最多有两个子结点。至于无根树，则是一种特殊的无向图，无环连通的无向图被称为无根树，它有很多特别的性质和优点，在离散数学中应用广泛。\nDAG 图，也叫做有向无环图，是一种特殊应用的数据结构，在图的动态规划问题中出现甚多。遍历 DAG 图的方式，也就是我们常说的拓扑排序，是一种图算法。DAG 可以认为是链表的图版本，如果说区块链是链表，那么区块链 3.0 时代可能就是 DAG 图。\n字典树，又被称为 Trie 树，是一种边为字符的有向图，它在字符串处理中有着非常强大的应用。广为人知的 AC 自动机，就是用 Trie 树来解决多模式字符串匹配问题。Trie 树在工业界也常被拿来做搜索提示，例如你在百度中搜索 “极客时”，就会自动跳出 “极客时间”。\n哈希表，这一定是程序员应用最广、自觉最简单的一个数据结构，比如 Python 的 dict() 就可以拿来即用，简单而自然。不过，哈希表其实有着非常深刻的内涵，冲突算法、哈希算法、扩容算法，都很值得我们去深究一下。\n算法：排序 link从排序开始入门算法有一定的难度，因为这需要你理解时间复杂度的概念，开始接触到基本的二分思想以及严谨的数学证明过程。不过，不管难度如何，我想强调的是，在学习的过程中一定不要跳过这些必需的科学训练。如果你忽略基础，只会调用 list.sort()，未来遇到稍复杂的问题基本懵圈，需要花费更多的时间来重走基础路，得不偿失。\n我们可以从基础的冒泡排序开始理解排序，这是一个很好理解正确性和代码的算法；然后是选择排序和插入排序，它们和冒泡排序一样，都是 O(n^2) 时间复杂度的算法。\n从归并排序开始，算法复杂度骤降到 O(nlogn) 的理论下界，这里也开始涉及到算法中的一个经典思想——分治（Divide and Conquer）。然后就是快速排序、堆排序这些算法，他们和快速排序一样都是 O(nlogn) 级别。\n除此之外，还有一些针对性的优化排序，比如计数排序、桶排序、基数排序等，在特定条件下可以做到 O(n) 的时间复杂度。\n关于各种算法，我推荐你可以查看这个B站的视频：https://www.bilibili.com/video/av685670\n算法：二分搜索 link二分搜索也是一种思想，甚至在生活中都有很广泛的应用（笑），比如书本的翻页设计是一种二分，你不需要查找很多次，就能找到自己想要的那一页。再比如就是很有名的，就是女生通过图书馆的笑话了。\n图书馆自习的时候，一女生背着一堆书进阅览室，结果警报响了，大妈让女生看是哪本书把警报弄响了，女生把书倒出来，一本一本地测。大妈见状急了，把书分成两份，第一份过了一下，响了。又把这一份分成两份接着测，三回就找到了，大妈用鄙视的眼神看着女生，仿佛在说O(n)和O(log2n)都分不清。\n对于二分搜索算法，你千万不要只是套用 API 和简单的代码，一定要从本质上理解二分思想，做到活学活用。\n算法：深度优先搜索（DFS）和广度优先搜索（BFS） linkDFS 和 BFS是图论算法中的基础。你需要先把这两个基础知识点掌握下来，然后学习几个经典算法，比如最短路算法、并查集、记忆化深度优先搜索、拓扑排序、DAG 图上的 DP 等等。\n这里要注意，我们的重点还是学习思想。对于业务逻辑而言，图算法的重要性可能并没有那么大，但是当你开始接触技术栈深层，接触大数据（Hadoop， Spark），接触神经网络和人工智能时，你会发现，图的基本思想早已渗透到了设计模式中，而 DFS 和 BFS 正是操作图的最基础的两把钥匙。\n算法：贪心和动态规划 link这两个算法依然是两种重要的思维。虽然在绝大部分程序员的工作中，这两个算法可能一年都不会被用到过几次，但同样的，这些都是向更高技术能力升级必备的基本功。你不需要掌握到能够参加 ACM 世界总决赛的级别，但是，我们哪怕是对基本的方法论能有所了解，都将受益匪浅。\n曾有参加过 ACM 竞赛的朋友和我讲过，说他学懂动态规划后，感觉整个人生观和方法论都有了变化。在那之后，他自己去思考一些现实生活中的决策时，就会明白哪些是短视的贪心，哪些才是长远考虑的动态规划（笑）。\n总结 link作为Python语言专栏，我确实不可能给你把每一种数据结构和算法都详细讲解一遍，但是，还是那句话，基础的数据结构和算法，一定是每个程序员的基本功。\n这里，我推荐你可以学习极客时间上王争老师的《数据结构与算法之美》专栏，以及覃超老师的《算法面试通关40讲》视频课程。这两位在 Google和 Facebook 工作过的老师，同样底子扎实、实战经验丰富，将会给你带来不同角度的更翔实的算法精讲。\n在数据爆炸的互联网的今天，学习资料触手可及，时间就显得更加宝贵。我在这里列出这些纲要的目的，也是希望能够帮你节省时间，为你整理出适合入门学习、掌握的基础知识点，让你可以带着全局观更有针对性地去学习。\n当然，一切可以取得成果的学习，都离不开我们自己付出的努力。也只有这样，掌握了数据结构和算法的你，才能在数学基础上对 Python 的理解更进一步。同时，在未来的项目设计中，这些思维亦会在无形之中，帮你设计出更高质量的系统和架构，可以说是终生受益的学习投资了。\n希望你可以学会并且切实有所收获，如果在哪个地方有所困惑，也欢迎在留言区和我交流讨论，我们一起精进和提高！\n"
            }
        );
    index.add(
            {
                id:  23 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/41---%E7%A1%85%E8%B0%B7%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%BD%93%E9%AA%8C\/",
                title: "41 - 硅谷一线互联网公司的工作体验",
                description: "你好， 我是景霄。\n前面四个版块，我们一起由浅入深地学习了Python这门语言，而最后一个版块，我想与你分享一些我的技术与工作见闻，谈谈我的领悟与理解。\n首先，我想带你去了解一下，硅谷Top互联网公司的工作体验与文化，这里就以我工作的Facebook为例。\n扁平化的管理制度 link硅谷的一线互联网公司，都会实行扁平化的管理制度，当然FB也不例外。在这里，虽然也有上下级之分，比如 Software Engineer -\u003e Engineering Manager -\u003e Director -\u003e VP，但是我们大家的思想中，并没有严格上下级这样的概念。\n公司鼓励每个人积极发表自己的观点。比如，一个应届毕业生，因为一个问题和自己的老板，乃至老板的老板据理力争，这样的场景也是很常见的。\n另外，公司每隔一段时间便会组织一次Q\u0026A，我们大家可以向CEO、CTO等提问。比如你想了解某个产品的发展方向，公司目前的侧重点，甚至是一些敏感的问题，都可以提问。\n同时，公司的领导，哪怕是上到CEO、CTO、COO这样的高层，都没有自己的单独办公室，都是和我们一起坐在开放的区域内办公，这样即拉近了距离，也是为了方便交流和讨论。\n开放式的讨论平台 link第二点是开放式的讨论平台。我一直觉得这个方式非常好，也很喜欢。FB用的是自己开发的workplace，相当于一个开放的社区，里面会有不同的群组，无论你有什么问题，都可以去相应的群组提问，那里会有各个领域的高手来帮你解答。\n举个例子，如果你有Python相关的问题，便可以去Python的群组问；你如果有Spark的问题，就去Spark 群组问。\n很多时候，各个组开发的产品，都会涉及很多的跨组合作，要用到其他组开发的一些API、算法、框架等等。这样，在使用的时候就难免会遇到一些问题，这个时候我们大家通常便会在对应的群组中提问。问题解决后也保存了下来，之后再有人遇到相同的问题时，便能直接搜索到对应的帖子及答案，大大提高了办公的效率。\n除了上述Q\u0026A形式的群组外，我们也会有很多其他形式的群组。比如，自己工作组内的群组，用于发布一些重要消息及技术交流；A/B测试的群组，用于大家讨论某个实验的结果等等。当然，还有很多非技术的群组，比如足球俱乐部、篮球俱乐部等用于休闲娱乐的平台。\n在有了这么一个生态系统后，员工可以很方便地获取到自己想要的信息，也大大方便了公司内部员工的交流，可以算是一举多得的事情了。\n数据驱动为中心 linkFB是一个典型的数据驱动型的公司，一切都以数据为依据，这样实际上极大地提高了工程师的地位。比如，在决定一个实验要不要最终发起时，我们都会首先关注各项指标，是不是能带来正向影响，是不是提高了用户的体验等等。\n再比如，每次提出一个新项目时，我们都需要做大量的数据分析与调研，然后与组内的同事及上级领导 review 后再做决定。这样，每次绩效考核时，证明自己最好的依据，便是自己发起的实验对指标的提升等等。这样的一种策略，对于公司及个人的发展都更为有利。\n举一个反例，之前的Snapchat，就是一个典型的不以数据驱动为中心的公司。他们产品的发布、改变，大多依赖一些产品经理和设计师的主观臆断，这样实际上是很偏颇的。后来的结局我们也都知道了，产品变得越来越不受用户喜欢，股价大跌，而我大部分在那里工作的同学，也都纷纷离职了。\nBootcamp linkBootcamp是FB中很著名的一个项目，所有入职FB的员工，在正式进入具体的工作组之前，都会参加4-10周的Bootcamp；而每个员工也会分配一个导师，帮助其了解FB的技术栈、文化以及吃喝玩乐等等。\nBootcamp的前两周，通常会安排不少的课程，帮助新员工了解FB的内部工具。之后就会进入选组阶段，组和员工之间进行双向选择，形式通常是“聊天+做组内的项目”，这样双方都能对彼此有更深入的了解。\n在Bootcamp期间，特别是对于应届毕业生来说，你可以尝试各种不同的方向，这对于未来的职业发展是非常有裨益的。公司也鼓励Bootcamp的员工参加各种娱乐活动，增进交流，而且这期间的吃喝玩乐都可以报销。我身边的每个同事都会有这样的感受：Bootcamp真是在公司最舒服的日子了。\n鼓励工程师更换工作方向 link在FB，无论是内部换组，还是更换工作方向都是非常普遍的现象。很多工程师在一个组做的时间久了，就会想尝试一些新的方向，这在公司是非常鼓励的。\n方法也很简单，一般来说让你去新组做几个任务，或者花一个月的时间做一个Hackamonth就可以了。这种形式是对双方的考量，新组会对工程师的能力有一个大概的了解；而工程师也会对新组的工作、技术有所掌握，并进一步判断自己是否感兴趣。\n因此，在FB，你会看到很多全栈工程师，比如我就是其中一个，对移动端、服务器端以及机器学习都有所涉猎。显然，这样的制度，非常有利于工程师的全面发展。\n福利政策 linkFB的福利，应该可以算是全球互联网公司中最好之一了。公司为了留住人才，提供了很多外人看来非比寻常的福利。\n首先从工位说起，其装备都是业内顶级标准。电脑是可以自己随意选配的，比如你可以随意选配7000多美金的iMac Pro，显示器也可以随意选配价值1000多美金的4K屏幕。至于可升降桌子和椅子，都是Herman Miller 标配，桌椅总价在2000美金以上。\n在技术交流方面，除了正常的学习培训外，公司还鼓励员工每年外出参加一次会议，比如机器学习方向的ICML、KDD等等，给予全程报销。\n另外，公司包一日三餐，包括内部的零食、甜品等全部免费。我们拥有一年21天带薪休假，女性还拥有6个月的带薪产假，同时提供免费的健身房、游泳池等，每年还会提供 720美金的健身私教报销等等。\n写在最后 link以上就是我在FB工作的主要工作体验。其实，在硅谷工作，不仅仅有技术上的收获，比如你可以直接接触到业内顶级大牛，了解到最新最前沿的技术；还有很多认知和思维方式上的影响，比如对于流程、合作、开源等的思考。\n接下来的几篇文章，我会继续讲述，关于技术研发我这些年的工作经验和总结，以及对于职业方向的认识和思考。欢迎你在留言区和我一起讨论交流这些问题，经验分享和交流，是每个技术人成长必不可少的环节。\n",
                content: "你好， 我是景霄。\n前面四个版块，我们一起由浅入深地学习了Python这门语言，而最后一个版块，我想与你分享一些我的技术与工作见闻，谈谈我的领悟与理解。\n首先，我想带你去了解一下，硅谷Top互联网公司的工作体验与文化，这里就以我工作的Facebook为例。\n扁平化的管理制度 link硅谷的一线互联网公司，都会实行扁平化的管理制度，当然FB也不例外。在这里，虽然也有上下级之分，比如 Software Engineer -\u003e Engineering Manager -\u003e Director -\u003e VP，但是我们大家的思想中，并没有严格上下级这样的概念。\n公司鼓励每个人积极发表自己的观点。比如，一个应届毕业生，因为一个问题和自己的老板，乃至老板的老板据理力争，这样的场景也是很常见的。\n另外，公司每隔一段时间便会组织一次Q\u0026A，我们大家可以向CEO、CTO等提问。比如你想了解某个产品的发展方向，公司目前的侧重点，甚至是一些敏感的问题，都可以提问。\n同时，公司的领导，哪怕是上到CEO、CTO、COO这样的高层，都没有自己的单独办公室，都是和我们一起坐在开放的区域内办公，这样即拉近了距离，也是为了方便交流和讨论。\n开放式的讨论平台 link第二点是开放式的讨论平台。我一直觉得这个方式非常好，也很喜欢。FB用的是自己开发的workplace，相当于一个开放的社区，里面会有不同的群组，无论你有什么问题，都可以去相应的群组提问，那里会有各个领域的高手来帮你解答。\n举个例子，如果你有Python相关的问题，便可以去Python的群组问；你如果有Spark的问题，就去Spark 群组问。\n很多时候，各个组开发的产品，都会涉及很多的跨组合作，要用到其他组开发的一些API、算法、框架等等。这样，在使用的时候就难免会遇到一些问题，这个时候我们大家通常便会在对应的群组中提问。问题解决后也保存了下来，之后再有人遇到相同的问题时，便能直接搜索到对应的帖子及答案，大大提高了办公的效率。\n除了上述Q\u0026A形式的群组外，我们也会有很多其他形式的群组。比如，自己工作组内的群组，用于发布一些重要消息及技术交流；A/B测试的群组，用于大家讨论某个实验的结果等等。当然，还有很多非技术的群组，比如足球俱乐部、篮球俱乐部等用于休闲娱乐的平台。\n在有了这么一个生态系统后，员工可以很方便地获取到自己想要的信息，也大大方便了公司内部员工的交流，可以算是一举多得的事情了。\n数据驱动为中心 linkFB是一个典型的数据驱动型的公司，一切都以数据为依据，这样实际上极大地提高了工程师的地位。比如，在决定一个实验要不要最终发起时，我们都会首先关注各项指标，是不是能带来正向影响，是不是提高了用户的体验等等。\n再比如，每次提出一个新项目时，我们都需要做大量的数据分析与调研，然后与组内的同事及上级领导 review 后再做决定。这样，每次绩效考核时，证明自己最好的依据，便是自己发起的实验对指标的提升等等。这样的一种策略，对于公司及个人的发展都更为有利。\n举一个反例，之前的Snapchat，就是一个典型的不以数据驱动为中心的公司。他们产品的发布、改变，大多依赖一些产品经理和设计师的主观臆断，这样实际上是很偏颇的。后来的结局我们也都知道了，产品变得越来越不受用户喜欢，股价大跌，而我大部分在那里工作的同学，也都纷纷离职了。\nBootcamp linkBootcamp是FB中很著名的一个项目，所有入职FB的员工，在正式进入具体的工作组之前，都会参加4-10周的Bootcamp；而每个员工也会分配一个导师，帮助其了解FB的技术栈、文化以及吃喝玩乐等等。\nBootcamp的前两周，通常会安排不少的课程，帮助新员工了解FB的内部工具。之后就会进入选组阶段，组和员工之间进行双向选择，形式通常是“聊天+做组内的项目”，这样双方都能对彼此有更深入的了解。\n在Bootcamp期间，特别是对于应届毕业生来说，你可以尝试各种不同的方向，这对于未来的职业发展是非常有裨益的。公司也鼓励Bootcamp的员工参加各种娱乐活动，增进交流，而且这期间的吃喝玩乐都可以报销。我身边的每个同事都会有这样的感受：Bootcamp真是在公司最舒服的日子了。\n鼓励工程师更换工作方向 link在FB，无论是内部换组，还是更换工作方向都是非常普遍的现象。很多工程师在一个组做的时间久了，就会想尝试一些新的方向，这在公司是非常鼓励的。\n方法也很简单，一般来说让你去新组做几个任务，或者花一个月的时间做一个Hackamonth就可以了。这种形式是对双方的考量，新组会对工程师的能力有一个大概的了解；而工程师也会对新组的工作、技术有所掌握，并进一步判断自己是否感兴趣。\n因此，在FB，你会看到很多全栈工程师，比如我就是其中一个，对移动端、服务器端以及机器学习都有所涉猎。显然，这样的制度，非常有利于工程师的全面发展。\n福利政策 linkFB的福利，应该可以算是全球互联网公司中最好之一了。公司为了留住人才，提供了很多外人看来非比寻常的福利。\n首先从工位说起，其装备都是业内顶级标准。电脑是可以自己随意选配的，比如你可以随意选配7000多美金的iMac Pro，显示器也可以随意选配价值1000多美金的4K屏幕。至于可升降桌子和椅子，都是Herman Miller 标配，桌椅总价在2000美金以上。\n在技术交流方面，除了正常的学习培训外，公司还鼓励员工每年外出参加一次会议，比如机器学习方向的ICML、KDD等等，给予全程报销。\n另外，公司包一日三餐，包括内部的零食、甜品等全部免费。我们拥有一年21天带薪休假，女性还拥有6个月的带薪产假，同时提供免费的健身房、游泳池等，每年还会提供 720美金的健身私教报销等等。\n写在最后 link以上就是我在FB工作的主要工作体验。其实，在硅谷工作，不仅仅有技术上的收获，比如你可以直接接触到业内顶级大牛，了解到最新最前沿的技术；还有很多认知和思维方式上的影响，比如对于流程、合作、开源等的思考。\n接下来的几篇文章，我会继续讲述，关于技术研发我这些年的工作经验和总结，以及对于职业方向的认识和思考。欢迎你在留言区和我一起讨论交流这些问题，经验分享和交流，是每个技术人成长必不可少的环节。\n"
            }
        );
    index.add(
            {
                id:  24 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/42---%E7%BB%86%E6%95%B0%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\/",
                title: "42 - 细数技术研发的注意事项",
                description: "你好，我是景霄。\n技术研发一直以来都是各大公司的核心部分之一，其质量的好坏直接影响到了产品的质量以及用户对产品的体验。如何建立一套规范、健全的开发体系，就显得尤为重要。今天我就和你聊聊技术研发的注意事项。\n选择合适的编程语言 link比如我们正在开发一个系统，首先，根据具体的需求，我们需要对系统的各个部分选择合适的编程语言。一般来说，infra这层我们更偏向于使用C++，而纯的服务器端则是以Python、Java、PHP等等为主。以搜索引擎为例，下面我画了一个它的简略架构图：\n你可以看到，大概的工作流程是：用户在客户端（client）输入一个查询（query），发送请求（request）到达服务器端（server-side）；服务器端首先向NLP service发请求，并对请求进行分析，等到拿到各项信号（signal）后，再向后端（backend）发送请求；后端会做特征抽取（feature extraction），利用ML 模型进行结果的检索（candidate retrieval）、排序，最后再把结果返回给服务器端和客户端。\n这里的NLP Service和后端，我们都会使用C++。因为这部分的处理最为复杂和耗时，都涉及到了特征抽取和model serving，对延迟（latency）的要求极高，只有C/C++这类语言才能满足需求。\n而服务器端或者叫中间层（middle tier），我们则会使用Python、Java、PHP等语言。因为这部分并没有特别复杂的处理和对延迟的高需求，主要是以一些业务逻辑为主；并且，对程序员来说，使用这种高级语言也更容易上手和调试。\n合理使用缓存 link缓存（cache）在实际工程中十分重要，可以想像，如果没了缓存，我们今天所用的绝大多数产品估计都会崩溃。缓存为我们节约了大量的CPU 容量（capacity）和延迟。\n还是以刚刚的搜索引擎系统为例，我们在客户端、服务器端和后端都会设置缓存。在客户端，我们一般会缓存用户的搜索记录，比如当你点击搜索框时，自动弹出的建议关键词的前几个，就可以是缓存的结果。这不需要向服务器端发请求，可以直接从客户端下载。\n而在服务器端，我们也会设置缓存来存储一些搜索结果。这样，如果同一个用户多次发送相同的请求，就不需要再向后端请求，直接从缓存里面拿结果就可以了，快速又高效。\n同样的，后端也需要缓存。比如在model serving这块儿，我们通常会有几个小时的缓存，不然每次提供实时的在线服务时，对CPU的负荷很大，延迟也会很高。\n总而言之，如果没了缓存，容易造成很多问题。\n服务器负荷迅速飙升，崩溃的几率大大增加。 端对端的延迟迅速飙升，请求超时的概率大大增加。 但是不是缓存越多就越好呢？显然也不是。\n第一，通常来说，缓存比较昂贵，所以在使用上，我们都会有一个限度，不能无限制索取。\n第二，缓存不是万能的，过度增加缓存，也会损害用户的产品体验。比如搜索结果的retrieval和排序这两块，理想状况下，肯定是做实时的model serving最好，因为这样对用户的个性化推荐更准确和实时。之所以会对model有几个小时的缓存，更多的是出于性能的考虑，但如果把缓存从几小时改为几天，显然不合适，无疑会对用户的产品体验造成极大的负面影响。\n因此，缓存到底取多久、取多少，往往是用户对产品参与度和性能的一个权衡，需要根据一些具体的分析以及A/B测试做出决定。\n健全的日志记录系统 link健全的日志记录系统也是尤其关键的一点。大型公司的系统，往往由成千十万个小系统组合而来，如果发生故障，比如Google、Facebook的某项服务突然宕机了，我们就需要以最快的速度找出原因并做出修复。这靠的是什么呢？靠的正是健全的日志记录系统，使得我们能够方便地分解错误原因，一层一层追溯，直到找到根源。\n一般来说，在线上环境中，我们需要两种类型的日志记录模式。\n一种是实时logging，考虑到服务器的压力，通常会做降采样（downsampling），比如log实际流量的1%。这样的好处是，可以及时跟踪各项指标，如果有情况，立即触发警报（alert）。\n比如，某天的中午12点，一位工程师push了一段会造成服务器奔溃的代码进入产品，实时logging检测到异常，发出警报，这时有关人员便会进行排查。如果发现这个代码的push时间和警报触发时间一致，就能够最快地恢复（revert），最小化其带来的负面影响。\n同时，实时logging也有利于我们进行各种线上实验。比如，ML组的A/B测试常常需要调参，我们的通常做法，就是每隔几小时查看实时 logging的table，根据各项指标，适度调整参数。\n第二种是每天更新一次也就是daily的 full logging，有助于我们统计一些信息，进行分析，比如做成仪表板（dashboard），方便查看每天的各项指标，来跟踪进度。此外，full logging的table，也常常用于ML组的训练数据（training data）。\nProfiling必不可少 link关于profile，之前我们也提到过，在实际开发中是非常重要的一项功能，能够帮助开发人员详细了解系统每个部分的效率，并加以提高。\n在线上环境中，我们通常会在许多必要的地方加上profile的代码，这样我们就能够知道这段代码的延迟是多少，哪个部分的延迟特别严重等等，然后对症下药。\n如果没有profile，很容易导致开发人员随意增加功能而不进行优化，这样以来，随着时间的推移，系统越来越冗余，延迟也会越来越高。因此，一个成熟的系统，一定会有profile的代码，帮助开发人员随时监控内部的各项指标变化。\ntest、test、test link这一点，我也已经在前面的文章中强调过了，测试（test）一定不能少。无论是单元测试（unit test）、集成测试（integration test）还是其他，都是保证代码质量、减小bug发生概率的一个有效手段。\n在真正规范的公司或是小组里，开发人员如果新增或改变了一个功能而不写测试，是过不了代码评审的。因此，测试一定要写，尤其是系统复杂了以后，很多工程师都要在上面开发各种不同的新功能，很难保证各个部分不受影响，测试便是一种很好的解决方法。\n除了日常开发中所写的测试外，在代码push到线上之前，最好还要加一层测试。还是以刚刚的搜索引擎系统为例，我所知道的，Google或者Facebook的代码在push的过程中，都会有专门的service，去模拟不同的用户发送请求，然后看返回的响应是不是符合要求。如果出错，就会阻止代码的push，这也就告诉了开发人员，他们所写的代码可能存在问题，需要再次检查。\n写在最后 link关于技术研发的注意事项，我主要强调这些内容。事实上，日常开发工作中，很多的细节都值得特别关注，而对于易错的地方，用系统化的流程解决不失为一个高效的方案。那么，在你的日常工作中，有哪些特别留心的地方值得分享，或者有哪些疑惑的地方想要交流吗？欢迎在留言区写下你的想法。\n",
                content: "你好，我是景霄。\n技术研发一直以来都是各大公司的核心部分之一，其质量的好坏直接影响到了产品的质量以及用户对产品的体验。如何建立一套规范、健全的开发体系，就显得尤为重要。今天我就和你聊聊技术研发的注意事项。\n选择合适的编程语言 link比如我们正在开发一个系统，首先，根据具体的需求，我们需要对系统的各个部分选择合适的编程语言。一般来说，infra这层我们更偏向于使用C++，而纯的服务器端则是以Python、Java、PHP等等为主。以搜索引擎为例，下面我画了一个它的简略架构图：\n你可以看到，大概的工作流程是：用户在客户端（client）输入一个查询（query），发送请求（request）到达服务器端（server-side）；服务器端首先向NLP service发请求，并对请求进行分析，等到拿到各项信号（signal）后，再向后端（backend）发送请求；后端会做特征抽取（feature extraction），利用ML 模型进行结果的检索（candidate retrieval）、排序，最后再把结果返回给服务器端和客户端。\n这里的NLP Service和后端，我们都会使用C++。因为这部分的处理最为复杂和耗时，都涉及到了特征抽取和model serving，对延迟（latency）的要求极高，只有C/C++这类语言才能满足需求。\n而服务器端或者叫中间层（middle tier），我们则会使用Python、Java、PHP等语言。因为这部分并没有特别复杂的处理和对延迟的高需求，主要是以一些业务逻辑为主；并且，对程序员来说，使用这种高级语言也更容易上手和调试。\n合理使用缓存 link缓存（cache）在实际工程中十分重要，可以想像，如果没了缓存，我们今天所用的绝大多数产品估计都会崩溃。缓存为我们节约了大量的CPU 容量（capacity）和延迟。\n还是以刚刚的搜索引擎系统为例，我们在客户端、服务器端和后端都会设置缓存。在客户端，我们一般会缓存用户的搜索记录，比如当你点击搜索框时，自动弹出的建议关键词的前几个，就可以是缓存的结果。这不需要向服务器端发请求，可以直接从客户端下载。\n而在服务器端，我们也会设置缓存来存储一些搜索结果。这样，如果同一个用户多次发送相同的请求，就不需要再向后端请求，直接从缓存里面拿结果就可以了，快速又高效。\n同样的，后端也需要缓存。比如在model serving这块儿，我们通常会有几个小时的缓存，不然每次提供实时的在线服务时，对CPU的负荷很大，延迟也会很高。\n总而言之，如果没了缓存，容易造成很多问题。\n服务器负荷迅速飙升，崩溃的几率大大增加。 端对端的延迟迅速飙升，请求超时的概率大大增加。 但是不是缓存越多就越好呢？显然也不是。\n第一，通常来说，缓存比较昂贵，所以在使用上，我们都会有一个限度，不能无限制索取。\n第二，缓存不是万能的，过度增加缓存，也会损害用户的产品体验。比如搜索结果的retrieval和排序这两块，理想状况下，肯定是做实时的model serving最好，因为这样对用户的个性化推荐更准确和实时。之所以会对model有几个小时的缓存，更多的是出于性能的考虑，但如果把缓存从几小时改为几天，显然不合适，无疑会对用户的产品体验造成极大的负面影响。\n因此，缓存到底取多久、取多少，往往是用户对产品参与度和性能的一个权衡，需要根据一些具体的分析以及A/B测试做出决定。\n健全的日志记录系统 link健全的日志记录系统也是尤其关键的一点。大型公司的系统，往往由成千十万个小系统组合而来，如果发生故障，比如Google、Facebook的某项服务突然宕机了，我们就需要以最快的速度找出原因并做出修复。这靠的是什么呢？靠的正是健全的日志记录系统，使得我们能够方便地分解错误原因，一层一层追溯，直到找到根源。\n一般来说，在线上环境中，我们需要两种类型的日志记录模式。\n一种是实时logging，考虑到服务器的压力，通常会做降采样（downsampling），比如log实际流量的1%。这样的好处是，可以及时跟踪各项指标，如果有情况，立即触发警报（alert）。\n比如，某天的中午12点，一位工程师push了一段会造成服务器奔溃的代码进入产品，实时logging检测到异常，发出警报，这时有关人员便会进行排查。如果发现这个代码的push时间和警报触发时间一致，就能够最快地恢复（revert），最小化其带来的负面影响。\n同时，实时logging也有利于我们进行各种线上实验。比如，ML组的A/B测试常常需要调参，我们的通常做法，就是每隔几小时查看实时 logging的table，根据各项指标，适度调整参数。\n第二种是每天更新一次也就是daily的 full logging，有助于我们统计一些信息，进行分析，比如做成仪表板（dashboard），方便查看每天的各项指标，来跟踪进度。此外，full logging的table，也常常用于ML组的训练数据（training data）。\nProfiling必不可少 link关于profile，之前我们也提到过，在实际开发中是非常重要的一项功能，能够帮助开发人员详细了解系统每个部分的效率，并加以提高。\n在线上环境中，我们通常会在许多必要的地方加上profile的代码，这样我们就能够知道这段代码的延迟是多少，哪个部分的延迟特别严重等等，然后对症下药。\n如果没有profile，很容易导致开发人员随意增加功能而不进行优化，这样以来，随着时间的推移，系统越来越冗余，延迟也会越来越高。因此，一个成熟的系统，一定会有profile的代码，帮助开发人员随时监控内部的各项指标变化。\ntest、test、test link这一点，我也已经在前面的文章中强调过了，测试（test）一定不能少。无论是单元测试（unit test）、集成测试（integration test）还是其他，都是保证代码质量、减小bug发生概率的一个有效手段。\n在真正规范的公司或是小组里，开发人员如果新增或改变了一个功能而不写测试，是过不了代码评审的。因此，测试一定要写，尤其是系统复杂了以后，很多工程师都要在上面开发各种不同的新功能，很难保证各个部分不受影响，测试便是一种很好的解决方法。\n除了日常开发中所写的测试外，在代码push到线上之前，最好还要加一层测试。还是以刚刚的搜索引擎系统为例，我所知道的，Google或者Facebook的代码在push的过程中，都会有专门的service，去模拟不同的用户发送请求，然后看返回的响应是不是符合要求。如果出错，就会阻止代码的push，这也就告诉了开发人员，他们所写的代码可能存在问题，需要再次检查。\n写在最后 link关于技术研发的注意事项，我主要强调这些内容。事实上，日常开发工作中，很多的细节都值得特别关注，而对于易错的地方，用系统化的流程解决不失为一个高效的方案。那么，在你的日常工作中，有哪些特别留心的地方值得分享，或者有哪些疑惑的地方想要交流吗？欢迎在留言区写下你的想法。\n"
            }
        );
    index.add(
            {
                id:  25 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/43---qa%E8%81%8A%E4%B8%80%E8%81%8A%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E5%92%8C%E9%80%89%E6%8B%A9\/",
                title: "43 - Q\u0026A：聊一聊职业发展和选择",
                description: "你好，我是景霄。\n在前面几节课中，我分享了在FB工作的一些经验和感想，不少同学都提出了自己的困惑，也希望我能给出一些职业发展方面的建议。综合这些问题，我主要选取了下面三个主题，来说说职业发展、职业选择方面我的看法。\nQ：程序员的岗位主要有哪些类型？我该如何选择？ linkA：无论是在求职阶段，还是正式进入公司工作后，你都会发现，工程师普遍按技术的不同，分为下面几个岗位。\n前端：包括移动（Android、iOS）以及Web前端（JavaScript、CSS）开发。 后端（服务器端）：主要是服务器端的开发，简单来说，就是输入为请求，输出为响应，发送给客户端。 算法：主要涉及到的是机器学习，比如推荐系统如何更好地实现个性化推荐，搜索引擎返回的结果如何才能更符合地用户的需求等等。 架构：涉及系统架构，偏底层，语言以C++为主。 从薪酬的角度来看，普遍来说：算法 \u003e 架构 \u003e 后端 \u003e 前端。当然，这主要是由市场的供需关系决定的。\n就拿算法岗来说，国内市场普遍缺少算法人才，也是因为这个岗位的培养难度更大，需要投入更大的精力。在顶尖互联网公司，参与核心产品研发的算法工程师们，工作三年，年收入100-200W人民币是很常见的。\n不过，我这里所说的算法人才，绝不是指类似在校生那种，看过几篇论文，写过一些MATLAB，在学校做过几个科研项目的程度。算法工作岗位需要的算法能力，是你必须身体力行，有某些产品线的实践经历。还需要你真正了解市场，比如今日头条的推荐算法是怎样的，Google搜索引擎是怎么工作的，头条里的广告排序又是怎么做的等等。\n再来说说架构，这也是目前一个热门的方向。我一直认为这是一个很偏工程、很硬核的领域，发展前景也相当不错，可以说是一个产品的基石。就拿刚刚提到的推荐系统来说，广告的定位和排序系统背后，都需要强有力的架构支撑。因此，这一行也可以称得上是人才紧缺，是企业舍得花高薪聘请的对象之一。\n与算法不同的是，这个领域不会涉及很深的数学知识，工程师的主要关注点，在于如何提高系统性能，包括如何使系统高扩展、减小系统的延迟和所需CPU的容量等等。架构师需要很强的编程能力，常用的语言是C++；当然，最重要的还是不断积累大型项目中获得的第一手经验，对常见的问题有最principle的处理方式。\n最后说说后端和前端，这是绝大多数程序员从事的岗位，也是我刚进公司时的选择。也许比起前两个岗位，不少人会认为，后端、前端工程师的薪酬较低，没有什么发展前景。这其实大错特错了！从一个产品的角度出发，你可以没有算法工程师、没有架构师，但是你能缺少后端和前端的开发人员吗？显然是不可能的。\n后端和前端，相当于是一个产品的框架。框架搭好了，才会有机器学习、算法等的锦上添花。诚然，这两年来看，后端和前端没有前两者那么热门（还是市场供需关系的问题），但这并不代表，这些岗位没有发展前景，或者你就可以小看其技术含量。\n比起算法和架构，后端、前端确实门槛更低些，但是其工作依然存在很高的技术含量。比如对一个产品或者其中的某些部件来说，如何设计搭建前后端的开发框架结构，使系统更加合理、可维护性更高，就是很多资深的开发工程师正在做的事。\n前面聊了这么多，最后回到最根本的问题上：到底如何选择呢？\n这里我给出的建议是：首先以自己的兴趣为出发点，因为只有自己感兴趣的东西，你才能做到最好。比如，一些人就是对前端感兴趣，那么为啥偏要去趟机器学习这趟浑水呢？当然不少人可能没有明确的偏好，那么这种情况下，我建议你尽可能多地去尝试，这是了解自己兴趣最好的方法。\n另外，从广义的角度来看，计算机这门技术存在着study deep和study broad这两个方向，你得想清楚你属于哪类。所谓的study deep，就意味着数十年专攻一个领域，励志成为某个领域的专家；而study broad，便是类似于全栈工程师，对一个产品、系统的end to end都有一个了解，能够随时胜任任意角色的工作，这一点在初创公司身上体现得最为明显。\nQ：如何成为一个全栈工程师？ linkA：相信屏幕前的不少同学是在创业公司工作的，刚刚也提到了，创业公司里全栈工程师的需求尤为突出。那么，如何成为一个优秀的全栈工程师呢？\n简单来说，最好的方法就是“尽可能地多接触、多实践不同领域的项目”。身体力行永远是学习新知识、提高能力的最好办法。\n当然，在每个领域的初始阶段，你可能会感觉到异常艰难，比如从未接触过前端的人被要求写一个页面，一时间内显然会不知从何下手。这个时候，我建议你可以先从“依葫芦画瓢”开始，通过阅读别人相似的代码，并在此基础上加以修改，完成你要实现的功能。时间久了，你看的多了，用的多了，理解自然就越来越深，动起手来也就越来越熟练了。\n有条件的同学，比如工作在类似于FB这种文化的公司，可以通过在公司内部换组的方式，去接触不同的项目。这自然是最好不过了，因为和特定领域的人合作，永远比一个人单干强得多，你能够迅速学到更多的东西。\n不过，没这种条件的同学也不必绝望，你还可以利用业余时间“充电“，自己做一些项目来培养和加强别的领域的能力。毕竟，对于成年人来说，自学才是精进自己的主要方式。\n这样，到了最后，你应该达到的结果便是，自己一个人能够扛起整条产品线的开发，也对系统的整个工作流程有一个全面而深入的理解。\nQ：学完本专栏后，在Python领域我该如何继续进阶呢？ linkA：在我看来，这个专栏的主要目的，是带你掌握Python这门语言的常见基本和高阶用法。接下来的进阶，便是Python本身在各种不同方向的运用，拿后端开发这个方向来说，比如，如何搭建大型系统的后台便是你需要掌握的。一个好的后端，自然离不开：\n合理的系统、框架设计； 简约高效的代码质量； 稳健齐全的单元测试； 出色的性能表现。 具体来说，你搭建的系统后端是不是易于拓展呢？比如过半年后，有了新的产品需求，需要增加新的功能。那么，在你的框架下，是否可以尽可能少地改动来实现新的功能，而不需要把某部分推倒重来呢？\n再比如，你搭建的系统是不是符合可维护性高、可靠性高、单元测试齐全的要求，从而不容易在线上发生bug呢？\n总之，在某一领域到了进阶的阶段，你需要关注的，绝不仅仅只是某些功能的实现，更需要你考虑所写代码的性能、质量，甚至于整个系统的设计等等。\n虽然讲了这么多东西，但最后我想说的是，三百六十行，行行出状元。对于计算机行业，乃至整个职场来说，每一个领域都没有优劣之分，每个领域你都可以做得很牛逼，前提是你不懈地学习、实践和思考。\n那么，对于职业选择和发展，你又是如何看待和理解的呢？欢迎留言和我一起交流探讨，也希望屏幕前的一直不懈学习的你，能找到属于自己的方向，不断前进和创新，实现自己的人生理想。\n",
                content: "你好，我是景霄。\n在前面几节课中，我分享了在FB工作的一些经验和感想，不少同学都提出了自己的困惑，也希望我能给出一些职业发展方面的建议。综合这些问题，我主要选取了下面三个主题，来说说职业发展、职业选择方面我的看法。\nQ：程序员的岗位主要有哪些类型？我该如何选择？ linkA：无论是在求职阶段，还是正式进入公司工作后，你都会发现，工程师普遍按技术的不同，分为下面几个岗位。\n前端：包括移动（Android、iOS）以及Web前端（JavaScript、CSS）开发。 后端（服务器端）：主要是服务器端的开发，简单来说，就是输入为请求，输出为响应，发送给客户端。 算法：主要涉及到的是机器学习，比如推荐系统如何更好地实现个性化推荐，搜索引擎返回的结果如何才能更符合地用户的需求等等。 架构：涉及系统架构，偏底层，语言以C++为主。 从薪酬的角度来看，普遍来说：算法 \u003e 架构 \u003e 后端 \u003e 前端。当然，这主要是由市场的供需关系决定的。\n就拿算法岗来说，国内市场普遍缺少算法人才，也是因为这个岗位的培养难度更大，需要投入更大的精力。在顶尖互联网公司，参与核心产品研发的算法工程师们，工作三年，年收入100-200W人民币是很常见的。\n不过，我这里所说的算法人才，绝不是指类似在校生那种，看过几篇论文，写过一些MATLAB，在学校做过几个科研项目的程度。算法工作岗位需要的算法能力，是你必须身体力行，有某些产品线的实践经历。还需要你真正了解市场，比如今日头条的推荐算法是怎样的，Google搜索引擎是怎么工作的，头条里的广告排序又是怎么做的等等。\n再来说说架构，这也是目前一个热门的方向。我一直认为这是一个很偏工程、很硬核的领域，发展前景也相当不错，可以说是一个产品的基石。就拿刚刚提到的推荐系统来说，广告的定位和排序系统背后，都需要强有力的架构支撑。因此，这一行也可以称得上是人才紧缺，是企业舍得花高薪聘请的对象之一。\n与算法不同的是，这个领域不会涉及很深的数学知识，工程师的主要关注点，在于如何提高系统性能，包括如何使系统高扩展、减小系统的延迟和所需CPU的容量等等。架构师需要很强的编程能力，常用的语言是C++；当然，最重要的还是不断积累大型项目中获得的第一手经验，对常见的问题有最principle的处理方式。\n最后说说后端和前端，这是绝大多数程序员从事的岗位，也是我刚进公司时的选择。也许比起前两个岗位，不少人会认为，后端、前端工程师的薪酬较低，没有什么发展前景。这其实大错特错了！从一个产品的角度出发，你可以没有算法工程师、没有架构师，但是你能缺少后端和前端的开发人员吗？显然是不可能的。\n后端和前端，相当于是一个产品的框架。框架搭好了，才会有机器学习、算法等的锦上添花。诚然，这两年来看，后端和前端没有前两者那么热门（还是市场供需关系的问题），但这并不代表，这些岗位没有发展前景，或者你就可以小看其技术含量。\n比起算法和架构，后端、前端确实门槛更低些，但是其工作依然存在很高的技术含量。比如对一个产品或者其中的某些部件来说，如何设计搭建前后端的开发框架结构，使系统更加合理、可维护性更高，就是很多资深的开发工程师正在做的事。\n前面聊了这么多，最后回到最根本的问题上：到底如何选择呢？\n这里我给出的建议是：首先以自己的兴趣为出发点，因为只有自己感兴趣的东西，你才能做到最好。比如，一些人就是对前端感兴趣，那么为啥偏要去趟机器学习这趟浑水呢？当然不少人可能没有明确的偏好，那么这种情况下，我建议你尽可能多地去尝试，这是了解自己兴趣最好的方法。\n另外，从广义的角度来看，计算机这门技术存在着study deep和study broad这两个方向，你得想清楚你属于哪类。所谓的study deep，就意味着数十年专攻一个领域，励志成为某个领域的专家；而study broad，便是类似于全栈工程师，对一个产品、系统的end to end都有一个了解，能够随时胜任任意角色的工作，这一点在初创公司身上体现得最为明显。\nQ：如何成为一个全栈工程师？ linkA：相信屏幕前的不少同学是在创业公司工作的，刚刚也提到了，创业公司里全栈工程师的需求尤为突出。那么，如何成为一个优秀的全栈工程师呢？\n简单来说，最好的方法就是“尽可能地多接触、多实践不同领域的项目”。身体力行永远是学习新知识、提高能力的最好办法。\n当然，在每个领域的初始阶段，你可能会感觉到异常艰难，比如从未接触过前端的人被要求写一个页面，一时间内显然会不知从何下手。这个时候，我建议你可以先从“依葫芦画瓢”开始，通过阅读别人相似的代码，并在此基础上加以修改，完成你要实现的功能。时间久了，你看的多了，用的多了，理解自然就越来越深，动起手来也就越来越熟练了。\n有条件的同学，比如工作在类似于FB这种文化的公司，可以通过在公司内部换组的方式，去接触不同的项目。这自然是最好不过了，因为和特定领域的人合作，永远比一个人单干强得多，你能够迅速学到更多的东西。\n不过，没这种条件的同学也不必绝望，你还可以利用业余时间“充电“，自己做一些项目来培养和加强别的领域的能力。毕竟，对于成年人来说，自学才是精进自己的主要方式。\n这样，到了最后，你应该达到的结果便是，自己一个人能够扛起整条产品线的开发，也对系统的整个工作流程有一个全面而深入的理解。\nQ：学完本专栏后，在Python领域我该如何继续进阶呢？ linkA：在我看来，这个专栏的主要目的，是带你掌握Python这门语言的常见基本和高阶用法。接下来的进阶，便是Python本身在各种不同方向的运用，拿后端开发这个方向来说，比如，如何搭建大型系统的后台便是你需要掌握的。一个好的后端，自然离不开：\n合理的系统、框架设计； 简约高效的代码质量； 稳健齐全的单元测试； 出色的性能表现。 具体来说，你搭建的系统后端是不是易于拓展呢？比如过半年后，有了新的产品需求，需要增加新的功能。那么，在你的框架下，是否可以尽可能少地改动来实现新的功能，而不需要把某部分推倒重来呢？\n再比如，你搭建的系统是不是符合可维护性高、可靠性高、单元测试齐全的要求，从而不容易在线上发生bug呢？\n总之，在某一领域到了进阶的阶段，你需要关注的，绝不仅仅只是某些功能的实现，更需要你考虑所写代码的性能、质量，甚至于整个系统的设计等等。\n虽然讲了这么多东西，但最后我想说的是，三百六十行，行行出状元。对于计算机行业，乃至整个职场来说，每一个领域都没有优劣之分，每个领域你都可以做得很牛逼，前提是你不懈地学习、实践和思考。\n那么，对于职业选择和发展，你又是如何看待和理解的呢？欢迎留言和我一起交流探讨，也希望屏幕前的一直不懈学习的你，能找到属于自己的方向，不断前进和创新，实现自己的人生理想。\n"
            }
        );
    index.add(
            {
                id:  26 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/%E5%8A%A0%E9%A4%90---%E5%B8%A6%E4%BD%A0%E4%B8%8A%E6%89%8Bswig%E4%B8%80%E4%BB%BD%E6%B8%85%E6%99%B0%E5%A5%BD%E7%94%A8%E7%9A%84swig%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97\/",
                title: "加餐 - 带你上手SWIG：一份清晰好用的SWIG编程实践指南",
                description: "你好，我是卢誉声，Autodesk 数据平台和计算平台资深软件工程师，也是《移动平台深度神经网络实战》和《分布式实时处理系统：原理架构与实现》的作者，主要从事C/C++、JavaScript开发工作和平台架构方面的研发工作，对SWIG也有比较深的研究。很高兴受极客时间邀请来做本次分享，今天，我们就来聊一聊SWIG这个话题。\n我们都知道，Python 是一门易于上手并实验友好的胶水语言。现在有很多机器学习开发或研究人员，都选择Python作为主力编程语言；流行的机器学习框架也都会提供Python语言的支持作为调用接口和工具。因此，相较于学习成本更高的C++来说，把Python作为进入机器学习世界的首选编程语言，就再合适不过了。\n不过，像TensorFlow或PyTorch这样的机器学习框架的核心，是使用Python编写的吗？\n显然不是。这里面的原因比较多，但最为显著的一个原因就是“性能”。通过C++编写的机器学习框架内核，加上编译器的优化能力，为系统提供了接近于机器码执行的效率。这种得天独厚的优势，让C++在机器学习的核心领域站稳了脚跟。我们前面所说的TensorFlow和PyTorch的核心，便都是使用C/C++开发的。其中，TensorFlow的内核，就是由高度优化的C++代码和CUDA编写而成。\n因此，我们可以理解为，TensorFlow通过Python来描述模型，而实际的运算则是由高性能C++代码执行的。而且，在绝大多数情况下，不同操作之间传递的数据，并不会拷贝回Python代码的执行空间。机器学习框架，正是通过这样的方式确保了计算性能，同时兼顾了对框架易用性方面的考虑。\n因此，当Python和C++结合使用的时候，Python本身的性能瓶颈就不那么重要了。它足够胜任我们给它的任务就可以了，至于对计算有更高要求的任务，就交给C++来做吧！\n今天，我们就来讨论下，如何通过SWIG对C++程序进行Python封装。我会先带你编写一段Python脚本，来执行一个简单的机器学习任务；接着，尝试将计算密集的部分改写成C++程序，再通过SWIG对其进行封装。最后的结果就是，Python把计算密集的任务委托给C++执行。\n我们会对性能做一个简单比较，并在这个过程中，讲解使用SWIG的方法。同时，在今天这节课的最后，我会为你提供一个学习路径，作为日后提高的参考。\n明确了今天的学习目的，也就是使用SWIG来实现Python对C++代码的调用，那么，我们今天的内容，其实可以看成一份关于SWIG的编程实践指南。学习这份指南之前，我们先来简单了解一下SWIG。\nSWIG 是什么？ linkSWIG，是一款能够连接C/C++与多种高级编程语言（我们在这里特别强调Python）的软件开发工具。SWIG支持多种不同类型的目标语言，这其中，支持的常见脚本语言包括JavaScript、Perl、PHP、Tcl、Ruby和Python等，支持的高级编程语言则包括C#、D、Go语言、Java（包括对Android的支持）、Lua、OCaml、Octave、Scilab和R。\n我们通常使用SWIG来创建高级解释或编译型的编程环境和接口，它也常被用来当作C/C++编写原型的测试工具。一个典型的应用场景，便是解析和创建C/C++接口，生成胶水代码供像Python这样的高级编程语言调用。近期发布的4.0.0版本，更是带来了对C++的显著改进和支持，这其中包括（不局限于）下面几点。\n针对C#、Java和Ruby而改进的STL包装器。 针对Java、Python和Ruby，增加C++11标准下的STL容器的支持。 改进了对C++11和C++14代码的支持。 修正了C++中对智能指针shared_ptr的一系列bug修复。 一系列针对C预处理器的极端case修复。 一系列针对成员函数指针问题的修复。 低支持的Python版本为2.7、3.2-3.7。 使用Python实现PCA算法 link借助于SWIG，我们可以简单地实现用Python调用C/C++库，甚至可以用Python继承和使用C++类。接下来，我们先来看一个你十分熟悉的使用Python编写的PCA（Principal Component Analysis，主成分分析）算法。\n因为我们今天的目标不是讲解PCA算法，所以如果你对这个算法还不是很熟悉，也没有关系，我会直接给出具体的代码，我们把焦点放在如何使用SWIG上就可以了。下面，我先给出代码清单1。\n代码清单1，基于Python编写的PCA算法 testPCAPurePython.py ：\nimport numpy as np\rdef compute_pca(data):\rm = np.mean(data, axis=0)\rdatac = np.array([obs - m for obs in data])\rT = np.dot(datac, datac.T)\r[u,s,v] = np.linalg.svd(T)\rpcs = [np.dot(datac.T, item) for item in u.T ]\rpcs = np.array([d / np.linalg.norm(d) for d in pcs])\rreturn pcs, m, s, T, u\rdef compute_projections(I,pcs,m):\rprojections = []\rfor i in I:\rw = []\rfor p in pcs:\rw.append(np.dot(i - m, p))\rprojections.append(w)\rreturn projections\rdef reconstruct(w, X, m,dim = 5):\rreturn np.dot(w[:dim],X[:dim,:]) + m\rdef normalize(samples, maxs = None):\rif not maxs:\rmaxs = np.max(samples)\rreturn np.array([np.ravel(s) / maxs for s in samples]) 现在，我们保存这段编写好的代码，并通过下面的命令来执行：\n",
                content: "你好，我是卢誉声，Autodesk 数据平台和计算平台资深软件工程师，也是《移动平台深度神经网络实战》和《分布式实时处理系统：原理架构与实现》的作者，主要从事C/C++、JavaScript开发工作和平台架构方面的研发工作，对SWIG也有比较深的研究。很高兴受极客时间邀请来做本次分享，今天，我们就来聊一聊SWIG这个话题。\n我们都知道，Python 是一门易于上手并实验友好的胶水语言。现在有很多机器学习开发或研究人员，都选择Python作为主力编程语言；流行的机器学习框架也都会提供Python语言的支持作为调用接口和工具。因此，相较于学习成本更高的C++来说，把Python作为进入机器学习世界的首选编程语言，就再合适不过了。\n不过，像TensorFlow或PyTorch这样的机器学习框架的核心，是使用Python编写的吗？\n显然不是。这里面的原因比较多，但最为显著的一个原因就是“性能”。通过C++编写的机器学习框架内核，加上编译器的优化能力，为系统提供了接近于机器码执行的效率。这种得天独厚的优势，让C++在机器学习的核心领域站稳了脚跟。我们前面所说的TensorFlow和PyTorch的核心，便都是使用C/C++开发的。其中，TensorFlow的内核，就是由高度优化的C++代码和CUDA编写而成。\n因此，我们可以理解为，TensorFlow通过Python来描述模型，而实际的运算则是由高性能C++代码执行的。而且，在绝大多数情况下，不同操作之间传递的数据，并不会拷贝回Python代码的执行空间。机器学习框架，正是通过这样的方式确保了计算性能，同时兼顾了对框架易用性方面的考虑。\n因此，当Python和C++结合使用的时候，Python本身的性能瓶颈就不那么重要了。它足够胜任我们给它的任务就可以了，至于对计算有更高要求的任务，就交给C++来做吧！\n今天，我们就来讨论下，如何通过SWIG对C++程序进行Python封装。我会先带你编写一段Python脚本，来执行一个简单的机器学习任务；接着，尝试将计算密集的部分改写成C++程序，再通过SWIG对其进行封装。最后的结果就是，Python把计算密集的任务委托给C++执行。\n我们会对性能做一个简单比较，并在这个过程中，讲解使用SWIG的方法。同时，在今天这节课的最后，我会为你提供一个学习路径，作为日后提高的参考。\n明确了今天的学习目的，也就是使用SWIG来实现Python对C++代码的调用，那么，我们今天的内容，其实可以看成一份关于SWIG的编程实践指南。学习这份指南之前，我们先来简单了解一下SWIG。\nSWIG 是什么？ linkSWIG，是一款能够连接C/C++与多种高级编程语言（我们在这里特别强调Python）的软件开发工具。SWIG支持多种不同类型的目标语言，这其中，支持的常见脚本语言包括JavaScript、Perl、PHP、Tcl、Ruby和Python等，支持的高级编程语言则包括C#、D、Go语言、Java（包括对Android的支持）、Lua、OCaml、Octave、Scilab和R。\n我们通常使用SWIG来创建高级解释或编译型的编程环境和接口，它也常被用来当作C/C++编写原型的测试工具。一个典型的应用场景，便是解析和创建C/C++接口，生成胶水代码供像Python这样的高级编程语言调用。近期发布的4.0.0版本，更是带来了对C++的显著改进和支持，这其中包括（不局限于）下面几点。\n针对C#、Java和Ruby而改进的STL包装器。 针对Java、Python和Ruby，增加C++11标准下的STL容器的支持。 改进了对C++11和C++14代码的支持。 修正了C++中对智能指针shared_ptr的一系列bug修复。 一系列针对C预处理器的极端case修复。 一系列针对成员函数指针问题的修复。 低支持的Python版本为2.7、3.2-3.7。 使用Python实现PCA算法 link借助于SWIG，我们可以简单地实现用Python调用C/C++库，甚至可以用Python继承和使用C++类。接下来，我们先来看一个你十分熟悉的使用Python编写的PCA（Principal Component Analysis，主成分分析）算法。\n因为我们今天的目标不是讲解PCA算法，所以如果你对这个算法还不是很熟悉，也没有关系，我会直接给出具体的代码，我们把焦点放在如何使用SWIG上就可以了。下面，我先给出代码清单1。\n代码清单1，基于Python编写的PCA算法 testPCAPurePython.py ：\nimport numpy as np\rdef compute_pca(data):\rm = np.mean(data, axis=0)\rdatac = np.array([obs - m for obs in data])\rT = np.dot(datac, datac.T)\r[u,s,v] = np.linalg.svd(T)\rpcs = [np.dot(datac.T, item) for item in u.T ]\rpcs = np.array([d / np.linalg.norm(d) for d in pcs])\rreturn pcs, m, s, T, u\rdef compute_projections(I,pcs,m):\rprojections = []\rfor i in I:\rw = []\rfor p in pcs:\rw.append(np.dot(i - m, p))\rprojections.append(w)\rreturn projections\rdef reconstruct(w, X, m,dim = 5):\rreturn np.dot(w[:dim],X[:dim,:]) + m\rdef normalize(samples, maxs = None):\rif not maxs:\rmaxs = np.max(samples)\rreturn np.array([np.ravel(s) / maxs for s in samples]) 现在，我们保存这段编写好的代码，并通过下面的命令来执行：\npython3 testPCAPurePython.py 准备SWIG link这样，我们已经获得了一些进展——使用Python编写了一个PCA算法，并得到了一些结果。接下来，我们看一下如何开始SWIG的开发工作。我会先从编译相关组件开始，再介绍一个简单使用的例子，为后续内容做准备。\n首先，我们从SWIG的网站（http://swig.org/download.html）下载源代码包，并开始构建：\n$ wget https://newcontinuum.dl.sourceforge.net/project/swig/swig/swig-4.0.0/swig-4.0.0.tar.gz # 下载路径可能会有所变化\r$ tar -xvf swig-4.0.0.tar.gz\r$ cd swig-4.0.0\r$ wget https://ftp.pcre.org/pub/pcre/pcre-8.43.tar.gz # SWIG需要依赖pcre工作\r$ sh ./Tools/pcre-build.sh # 该脚本会将pcre自动构建成SWIG使用的静态库\r$ ./configure # 注意需要安装bison，如果没有安装需要读者手动安装\r$ make\r$ sudo make install 一切就绪后，我们就来编写一个简单的例子吧。这个例子同样来源于SWIG网站（http://swig.org/tutorial.html）。我们先来创建一个简单的c文件，你可以通过你习惯使用的文本编辑器（比如vi），创建一个名为example.c的文件，并编写代码。代码内容我放在了代码清单2中。\n代码清单2，example.c：\n#include double My_variable = 3.0;\rint fact(int n) {\rif (n \u003c= 1) return 1;\relse return n*fact(n-1);\r}\rint my_mod(int x, int y) {\rreturn (x%y);\r}\rchar *get_time()\r{\rtime_t ltime;\rtime(\u0026ltime);\rreturn ctime(\u0026ltime);\r} 接下来，我们编写一个名为example.i的接口定义文件，和稍后用作测试的Python脚本，内容如代码清单3和代码清单4所示。\n代码清单3，example.i：\n%module example\r%{\r/* Put header files here or function declarations like below */\rextern double My_variable;\rextern int fact(int n);\rextern int my_mod(int x, int y);\rextern char *get_time();\r%}\rextern double My_variable;\rextern int fact(int n);\rextern int my_mod(int x, int y);\rextern char *get_time(); 我来解释下清单3这段代码。第1行，我们定义了模块的名称为example。第2-8行，我们直接指定了example.c中的函数定义，也可以定义一个example.h头文件，并将这些定义加入其中；然后，在 %{ … %}结构体中包含example.h，来实现相同的功能。第10-13行，则是定义了导出的接口，以便你在Python中直接调用这些接口。\n代码清单4，testExample.py：\nimport example\rprint(example.fact(5))\rprint(example.my_mod(7,3))\rprint(example.get_time()) 好了， 到现在为止，我们已经准备就绪了。现在，我们来执行下面的代码，创建目标文件和最后链接的文件吧：\nswig -python example.i\rgcc -c -fPIC example.c example_wrap.c -I/usr/include/python3.6\rgcc -shared example.o example_wrap.o -o _example.so\rpython3 testExample.py # 测试调用 其实，从代码清单4中你也能够看到，通过导入example，我们可以直接在Python脚本中，调用使用C实现的函数接口，并获得返回值。\n通过SWIG封装基于C++编写的Python模块 link到这一步，我们已经准备好了一份使用C++编写的PCA算法，接下来，我们就要对其进行一个简单的封装。由于C++缺少线性代数的官方支持，因此，为了简化线性代数运算，我这里用了一个第三方库Armadillo。在Ubuntu下，它可以使用apt-get install libarmadillo-dev安装支持。\n另外，还是要再三说明一下，我们今天这节课的重点并不是讲解PCA算法本身，所以希望你不要困于此处，而错过了真正的使用方法。当然，为了完整性考虑，我还是会对代码做出最基本的解释。\n封装正式开始。我们先来编写一个名为pca.h的头文件定义，内容我放在了代码清单5中。\n代码清单5，pca.h：\n#pragma once\r#include #include #include class pca {\rpublic:\rpca();\rexplicit pca(long num_vars);\rvirtual ~pca();\rbool operator==(const pca\u0026 other);\rvoid set_num_variables(long num_vars);\rlong get_num_variables() const;\rvoid add_record(const std::vector\u0026 record);\rstd::vector get_record(long record_index) const;\rlong get_num_records() const;\rvoid set_do_normalize(bool do_normalize);\rbool get_do_normalize() const;\rvoid set_solver(const std::string\u0026 solver);\rstd::string get_solver() const;\rvoid solve();\rdouble check_eigenvectors_orthogonal() const;\rdouble check_projection_accurate() const;\rvoid save(const std::string\u0026 basename) const;\rvoid load(const std::string\u0026 basename);\rvoid set_num_retained(long num_retained);\rlong get_num_retained() const;\rstd::vector to_principal_space(const std::vector\u0026 record) const;\rstd::vector to_variable_space(const std::vector\u0026 data) const;\rdouble get_energy() const;\rdouble get_eigenvalue(long eigen_index) const;\rstd::vector get_eigenvalues() const;\rstd::vector get_eigenvector(long eigen_index) const;\rstd::vector get_principal(long eigen_index) const;\rstd::vector get_mean_values() const;\rstd::vector get_sigma_values() const;\rprotected:\rlong num_vars_;\rlong num_records_;\rlong record_buffer_;\rstd::string solver_;\rbool do_normalize_;\rlong num_retained_;\rarma::Mat data_;\rarma::Col energy_;\rarma::Col eigval_;\rarma::Mat eigvec_;\rarma::Mat proj_eigvec_;\rarma::Mat princomp_;\rarma::Col mean_;\rarma::Col sigma_;\rvoid initialize_();\rvoid assert_num_vars_();\rvoid resize_data_if_needed_();\r}; 接着，我们再来编写具体实现pca.cpp，也就是代码清单6的内容。\n代码清单6，pca.cpp：\n#include \"pca.h\"\r#include \"utils.h\"\r#include #include pca::pca()\r: num_vars_(0),\rnum_records_(0),\rrecord_buffer_(1000),\rsolver_(\"dc\"),\rdo_normalize_(false),\rnum_retained_(1),\renergy_(1)\r{}\rpca::pca(long num_vars)\r: num_vars_(num_vars),\rnum_records_(0),\rrecord_buffer_(1000),\rsolver_(\"dc\"),\rdo_normalize_(false),\rnum_retained_(num_vars_),\rdata_(record_buffer_, num_vars_),\renergy_(1),\reigval_(num_vars_),\reigvec_(num_vars_, num_vars_),\rproj_eigvec_(num_vars_, num_vars_),\rprincomp_(record_buffer_, num_vars_),\rmean_(num_vars_),\rsigma_(num_vars_)\r{\rassert_num_vars_();\rinitialize_();\r}\rpca::~pca()\r{}\rbool pca::operator==(const pca\u0026 other) {\rconst double eps = 1e-5;\rif (num_vars_ == other.num_vars_ \u0026\u0026\rnum_records_ == other.num_records_ \u0026\u0026\rrecord_buffer_ == other.record_buffer_ \u0026\u0026\rsolver_ == other.solver_ \u0026\u0026\rdo_normalize_ == other.do_normalize_ \u0026\u0026\rnum_retained_ == other.num_retained_ \u0026\u0026\rutils::is_approx_equal_container(eigval_, other.eigval_, eps) \u0026\u0026\rutils::is_approx_equal_container(eigvec_, other.eigvec_, eps) \u0026\u0026\rutils::is_approx_equal_container(princomp_, other.princomp_, eps) \u0026\u0026\rutils::is_approx_equal_container(energy_, other.energy_, eps) \u0026\u0026\rutils::is_approx_equal_container(mean_, other.mean_, eps) \u0026\u0026\rutils::is_approx_equal_container(sigma_, other.sigma_, eps) \u0026\u0026\rutils::is_approx_equal_container(proj_eigvec_, other.proj_eigvec_, eps))\rreturn true;\relse\rreturn false;\r}\rvoid pca::resize_data_if_needed_() {\rif (num_records_ == record_buffer_) {\rrecord_buffer_ += record_buffer_;\rdata_.resize(record_buffer_, num_vars_);\r}\r}\rvoid pca::assert_num_vars_() {\rif (num_vars_ \u003c 2)\rthrow std::invalid_argument(\"Number of variables smaller than two.\");\r}\rvoid pca::initialize_() {\rdata_.zeros();\reigval_.zeros();\reigvec_.zeros();\rprincomp_.zeros();\rmean_.zeros();\rsigma_.zeros();\renergy_.zeros();\r}\rvoid pca::set_num_variables(long num_vars) {\rnum_vars_ = num_vars;\rassert_num_vars_();\rnum_retained_ = num_vars_;\rdata_.resize(record_buffer_, num_vars_);\reigval_.resize(num_vars_);\reigvec_.resize(num_vars_, num_vars_);\rmean_.resize(num_vars_);\rsigma_.resize(num_vars_);\rinitialize_();\r}\rvoid pca::add_record(const std::vector\u0026 record) {\rassert_num_vars_();\rif (num_vars_ != long(record.size()))\rthrow std::domain_error(utils::join(\"Record has the wrong size: \", record.size()));\rresize_data_if_needed_();\rarma::Row row(\u0026record.front(), record.size());\rdata_.row(num_records_) = std::move(row);\r++num_records_;\r}\rstd::vector pca::get_record(long record_index) const {\rreturn std::move(utils::extract_row_vector(data_, record_index));\r}\rvoid pca::set_do_normalize(bool do_normalize) {\rdo_normalize_ = do_normalize;\r}\rvoid pca::set_solver(const std::string\u0026 solver) {\rif (solver!=\"standard\" \u0026\u0026 solver!=\"dc\")\rthrow std::invalid_argument(utils::join(\"No such solver available: \", solver));\rsolver_ = solver;\r}\rvoid pca::solve() {\rassert_num_vars_();\rif (num_records_ \u003c 2)\rthrow std::logic_error(\"Number of records smaller than two.\");\rdata_.resize(num_records_, num_vars_);\rmean_ = utils::compute_column_means(data_);\rutils::remove_column_means(data_, mean_);\rsigma_ = utils::compute_column_rms(data_);\rif (do_normalize_) utils::normalize_by_column(data_, sigma_);\rarma::Col eigval(num_vars_);\rarma::Mat eigvec(num_vars_, num_vars_);\rarma::Mat cov_mat = utils::make_covariance_matrix(data_);\rarma::eig_sym(eigval, eigvec, cov_mat, solver_.c_str());\rarma::uvec indices = arma::sort_index(eigval, 1);\rfor (long i=0; i"
            }
        );
    index.add(
            {
                id:  27 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/%E7%BB%93%E8%AF%BE%E6%B5%8B%E8%AF%95---%E5%85%B3%E4%BA%8Epython%E7%9A%84%E8%BF%99%E4%BA%9B%E7%9F%A5%E8%AF%86%E4%BD%A0%E9%83%BD%E6%8E%8C%E6%8F%A1%E4%BA%86%E5%90%97\/",
                title: "结课测试 - 关于Python的这些知识，你都掌握了吗？",
                description: "你好，我是景霄。\n《Python核心技术与实战》这门课程已经完结一段时间了，在完结的这段时间里，我依然会收到很多留言，很感谢你一直以来的认真学习和支持！\n为了帮助你检验自己的学习效果，我特别给你准备了一套结课测试题。这套测试题共有20道题目，包括5道单选题和15道多选题，满分 100 分。\n还等什么，点击下面按钮开始测试吧！\n",
                content: "你好，我是景霄。\n《Python核心技术与实战》这门课程已经完结一段时间了，在完结的这段时间里，我依然会收到很多留言，很感谢你一直以来的认真学习和支持！\n为了帮助你检验自己的学习效果，我特别给你准备了一套结课测试题。这套测试题共有20道题目，包括5道单选题和15道多选题，满分 100 分。\n还等什么，点击下面按钮开始测试吧！\n"
            }
        );
    index.add(
            {
                id:  28 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/%E7%BB%93%E6%9D%9F%E8%AF%AD---%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96%E7%9A%84%E5%87%A0%E7%82%B9%E6%88%90%E9%95%BF%E5%BB%BA%E8%AE%AE\/",
                title: "结束语 - 技术之外的几点成长建议",
                description: "你好，我是景霄。\n不知不觉，专栏上线已经4个月了，终于到了和你们说再见的时候，心中既有兴奋，又有不舍。说兴奋，是因为自己坚持完成了40多篇文章的写作，这对我而言是一项体力与脑力的“马拉松”，颇有成就感；说不舍，是因为你们的热情远超乎我当时的想象，和你们一起交流学习真的很高兴，收获也很大。\n这里也非常感谢极客时间能提供这个平台，让我得以和一万多的学员分享经验。当然，虽然课程结束了，但是技术人的学习并未终止，最后我还想再着重强调这么几点。\n计算机科学是一门需要实践的学科 link无论是对于Python这门课程，还是其他语言，或是计算机的其他领域，我认为实践永远是至关重要的。计算机科学是一门偏向工程的学科，所以一定要多实践，多写代码，多交流，多思考。实际生活中，我见过不少同学虽然看了很多的书籍，但是代码功底非常差，这是一个很严重的问题。\n那么，怎么提高呢？答案就是，请尽可能地参与更多的项目。俗话说“实践出真知”，说的正是这个道理。当你做的东西多了以后，你就会发现，很多的知识都会自然而然地串接起来，感觉自己的任督二脉似乎被打通了一般。\n选择适合自己的职业方向 link关于职业方向的问题，我还是那句话，对于尚不清晰自己兴趣所在的同学，最好的办法就是多尝试，因为在尝试的过程中，你就会发现自己的特长，发现自己的喜好，从而坚定不移、一步一步地走下去。\n当然，我了解到很多同学都是转行做程序员，以前都不是学计算机的，所以，很多人首先都会遇到“找工作”或者“跳槽”的难题。这种情况下，请不要气馁或是放弃。我也不完全算是科班出身的，我身边好多同事都不是科班出身，但是几年以后，你就会发现，好多当年非科班出身的同学，干得甚至比科班出身的都要好。因此，只要你坚定信念，不要放弃，风雨之后必有彩虹。\n能用代码解决的问题都不是问题 link这句话，主要送给有一定工作经验的朋友。其实，有了一定的积累后，你就会发现，能用代码解决的问题都不是问题。职场上，要想出类拔萃，除了能在技术上独当一面，如何与他人进行沟通交流，如何正确地处理同事间的关系，都是你额外需要学习的东西。实际工作中，我也见过不少人，代码能力天赋异禀，但是沟通交流不行，这同样也会阻碍你向上晋升。\n就拿一个很简单的例子来说。如果你和周围的同事合作一个项目，你觉得他有一样东西做得不好，你会直接说诸如“你很傻”，“你这样做大错特错”的话吗？你如果这样说了，那可真的是“大错特错了”。事实上，我们通常的一个措辞是，“我觉得你这里做得很好，不过，如果你可以……的话，那就更好了”。\n说了这么多，最后，还是要感谢你的订阅，感谢你的一路陪伴，祝你的生活学习一帆风顺，永远幸福！课程虽然已经结束，但是你仍然可以留言，我会尽可能多地一一回复，让你的学习没有遗憾。\n结束不是终点，而是更高阶旅程的重新启航。最后的最后，我们专栏的编辑同学，特意为你准备了一份毕业调查问卷，希望你能抽出两三分钟时间，写下你的学习经历和感受。这既是你课程学习的仪式感，作为你这几个月学习的记录和总结；也是我后续为你优化课程的重要参考资料，很有价值。感谢你的反馈，学习不停，精进不止！\n",
                content: "你好，我是景霄。\n不知不觉，专栏上线已经4个月了，终于到了和你们说再见的时候，心中既有兴奋，又有不舍。说兴奋，是因为自己坚持完成了40多篇文章的写作，这对我而言是一项体力与脑力的“马拉松”，颇有成就感；说不舍，是因为你们的热情远超乎我当时的想象，和你们一起交流学习真的很高兴，收获也很大。\n这里也非常感谢极客时间能提供这个平台，让我得以和一万多的学员分享经验。当然，虽然课程结束了，但是技术人的学习并未终止，最后我还想再着重强调这么几点。\n计算机科学是一门需要实践的学科 link无论是对于Python这门课程，还是其他语言，或是计算机的其他领域，我认为实践永远是至关重要的。计算机科学是一门偏向工程的学科，所以一定要多实践，多写代码，多交流，多思考。实际生活中，我见过不少同学虽然看了很多的书籍，但是代码功底非常差，这是一个很严重的问题。\n那么，怎么提高呢？答案就是，请尽可能地参与更多的项目。俗话说“实践出真知”，说的正是这个道理。当你做的东西多了以后，你就会发现，很多的知识都会自然而然地串接起来，感觉自己的任督二脉似乎被打通了一般。\n选择适合自己的职业方向 link关于职业方向的问题，我还是那句话，对于尚不清晰自己兴趣所在的同学，最好的办法就是多尝试，因为在尝试的过程中，你就会发现自己的特长，发现自己的喜好，从而坚定不移、一步一步地走下去。\n当然，我了解到很多同学都是转行做程序员，以前都不是学计算机的，所以，很多人首先都会遇到“找工作”或者“跳槽”的难题。这种情况下，请不要气馁或是放弃。我也不完全算是科班出身的，我身边好多同事都不是科班出身，但是几年以后，你就会发现，好多当年非科班出身的同学，干得甚至比科班出身的都要好。因此，只要你坚定信念，不要放弃，风雨之后必有彩虹。\n能用代码解决的问题都不是问题 link这句话，主要送给有一定工作经验的朋友。其实，有了一定的积累后，你就会发现，能用代码解决的问题都不是问题。职场上，要想出类拔萃，除了能在技术上独当一面，如何与他人进行沟通交流，如何正确地处理同事间的关系，都是你额外需要学习的东西。实际工作中，我也见过不少人，代码能力天赋异禀，但是沟通交流不行，这同样也会阻碍你向上晋升。\n就拿一个很简单的例子来说。如果你和周围的同事合作一个项目，你觉得他有一样东西做得不好，你会直接说诸如“你很傻”，“你这样做大错特错”的话吗？你如果这样说了，那可真的是“大错特错了”。事实上，我们通常的一个措辞是，“我觉得你这里做得很好，不过，如果你可以……的话，那就更好了”。\n说了这么多，最后，还是要感谢你的订阅，感谢你的一路陪伴，祝你的生活学习一帆风顺，永远幸福！课程虽然已经结束，但是你仍然可以留言，我会尽可能多地一一回复，让你的学习没有遗憾。\n结束不是终点，而是更高阶旅程的重新启航。最后的最后，我们专栏的编辑同学，特意为你准备了一份毕业调查问卷，希望你能抽出两三分钟时间，写下你的学习经历和感受。这既是你课程学习的仪式感，作为你这几个月学习的记录和总结；也是我后续为你优化课程的重要参考资料，很有价值。感谢你的反馈，学习不停，精进不止！\n"
            }
        );
    index.add(
            {
                id:  29 ,
                href: "\/docs\/python\/",
                title: "Python",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  30 ,
                href: "\/docs\/",
                title: "Stay Hungry , Stay Foolish",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  31 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/",
                title: "Python核心技术与实战",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  32 ,
                href: "\/docs\/%E6%97%A5%E5%B8%B8\/%E5%91%8A%E5%88%AB%E4%BB%A3%E7%A0%81%E5%B7%A5%E4%BA%BA\/",
                title: "告别代码工人",
                description: "过去 25 年，从互联网到移动互联网的浪潮，创造了海量的工程需求，软件工程师也因此成为了时代的宠儿。但现在，这波巨大的增长红利期已经结束。\n那下一个浪潮是什么？文章给出了答案：Agentic AI (智能体 AI)。\n这不仅仅是一个新技术，它将彻底重塑我们的工作方式，重写“软件工程师”这个岗位的核心要求。这不是一次普通的更新，这是一场彻底的进化。\n告别“代码工人”，拥抱“智能体工程师” link文章预言，软件工程师不会被淘汰，而是将进化，去“驾驭”这波新的 AI 浪潮。我们将成为所谓的 “智能体软件工程师” (Agentic Software Engineer)。\n在这个新角色下，我们的工作不再是整天埋头编写成千上万行代码。AI Agent 可以比我们更快、更不知疲倦地完成这项任务。我们的核心职责，将转变为：\n一个指挥、协调、审查和运维 AI Agent 军团的专家。\n我们从亲自下场比赛的“运动员”，变成了运筹帷幄的“教练”。\nAI 时代的生存指南：你的技能升级清单 link那么，要成为一名合格的“智能体软件工程师”，我们需要点亮哪些新的技能树？文章为我们梳理了一份极其宝贵的“技能升值/贬值清单”。\n技能升值 (Skills++)：这 6 项能力将是你未来的护城河 link 版本控制 (Version Control) Git 不再仅仅是你个人的代码管理工具，它将成为协调你与成百上千个“AI 码农”协同工作的核心骨干。你需要用它来管理 Agent 的并行工作流、审查 Agent 提交的 PR、以及在 Agent 犯错时进行回滚。精通 Git 模型，将是从业基础。\n产品思维 (“Product”) AI Agent 擅长执行，但前提是指令必须清晰。任务分解、需求定义、接口设计等产品经理的核心技能，将成为每个工程师的必备能力。如果你无法将一个模糊的想法拆解成 Agent 可以处理的、足够小的任务块，你将无法与 Agent 高效协作。\n代码审查 (Code Review) 这是未来我们耗时最多的日常工作。当 Agent 可以在 10 分钟内生成 500 行复杂的代码时，你的价值就体现在审查这些代码的正确性、可维护性和安全性上。接受吧，你正在从一个 Code Writer 变成一个 Code Editor。\n",
                content: "过去 25 年，从互联网到移动互联网的浪潮，创造了海量的工程需求，软件工程师也因此成为了时代的宠儿。但现在，这波巨大的增长红利期已经结束。\n那下一个浪潮是什么？文章给出了答案：Agentic AI (智能体 AI)。\n这不仅仅是一个新技术，它将彻底重塑我们的工作方式，重写“软件工程师”这个岗位的核心要求。这不是一次普通的更新，这是一场彻底的进化。\n告别“代码工人”，拥抱“智能体工程师” link文章预言，软件工程师不会被淘汰，而是将进化，去“驾驭”这波新的 AI 浪潮。我们将成为所谓的 “智能体软件工程师” (Agentic Software Engineer)。\n在这个新角色下，我们的工作不再是整天埋头编写成千上万行代码。AI Agent 可以比我们更快、更不知疲倦地完成这项任务。我们的核心职责，将转变为：\n一个指挥、协调、审查和运维 AI Agent 军团的专家。\n我们从亲自下场比赛的“运动员”，变成了运筹帷幄的“教练”。\nAI 时代的生存指南：你的技能升级清单 link那么，要成为一名合格的“智能体软件工程师”，我们需要点亮哪些新的技能树？文章为我们梳理了一份极其宝贵的“技能升值/贬值清单”。\n技能升值 (Skills++)：这 6 项能力将是你未来的护城河 link 版本控制 (Version Control) Git 不再仅仅是你个人的代码管理工具，它将成为协调你与成百上千个“AI 码农”协同工作的核心骨干。你需要用它来管理 Agent 的并行工作流、审查 Agent 提交的 PR、以及在 Agent 犯错时进行回滚。精通 Git 模型，将是从业基础。\n产品思维 (“Product”) AI Agent 擅长执行，但前提是指令必须清晰。任务分解、需求定义、接口设计等产品经理的核心技能，将成为每个工程师的必备能力。如果你无法将一个模糊的想法拆解成 Agent 可以处理的、足够小的任务块，你将无法与 Agent 高效协作。\n代码审查 (Code Review) 这是未来我们耗时最多的日常工作。当 Agent 可以在 10 分钟内生成 500 行复杂的代码时，你的价值就体现在审查这些代码的正确性、可维护性和安全性上。接受吧，你正在从一个 Code Writer 变成一个 Code Editor。\n测试 (Testing) 文章说：“We’re all SDETs now.”（我们现在都是软件测试开发工程师了）。面对一个可能会“创造性”地修改代码以绕过测试的 Agent，编写精准、全面的测试用例，是约束和指导 Agent 行为的最有力工具。 那些热衷于寻找边界条件、享受“破坏”代码乐趣的工程师，将在新时代中变得极其宝贵。\n系统设计 (System Design) 未来的系统设计，需要更多地考虑如何容纳和管理不那么可靠的 Agent。你需要设计出具有清晰边界、强健接口、高度可测试性的系统，这样即使 Agent 的某个部分出错，也不会导致整个系统崩溃。\n运维 (Operations) 我们都将成为 “智能体可靠性工程师” (Agent Reliability Engineer)。你需要设计、部署、监控和调试由无数 Agent 组成的复杂网络。当仪表盘上警报响起时，你需要快速定位问题是出在哪个 Agent 的行为上。学习大规模系统的运维之道，宜早不宜迟。\n技能贬值 (Skills–)：这些技能正在被 AI 替代 link LeetCode 式算法题： AI 已经能在瞬间解决大部分算法题。 语言语法熟练度： Agent 知道所有语法细节，你只需能读懂代码即可。 打字速度： AI “思考”和“打字”的速度，是人类无法企及的。 现在，立即开始行动 link这篇文章给我们的不应是焦虑，而是行动的路线图。我们应该如何开始？\n亲自使用 Agent： 去尝试 Claude Code、Gemini CLI 等领先的编码智能体。找一个终端窗口，看着它工作 15 分钟，感受一下未来的工作形态。 “外包”你的日常工作： 在你现有的开发流程中，寻找那些可以“委托”给 Agent 的任务。比如：“为我刚才的提交补充单元测试”，或者“重构这个函数，让它更具可读性”。 刻意练习新技能： 将你的学习时间，有意识地投入到上述 6 项“升值技能”上。 小结：浪潮已至，要么驾驭，要么被吞没 link软件工程师的“25年黄金时代”或许已经落幕，但这不意味着职业的终结。\n一个由 AI 驱动的、充满无限可能的新时代正在开启。这场变革是不可避免的，拥抱 Agent 的公司，必将“碾压”那些固步自封的公司。而能够驾驭 Agent 的工程师，也必将成为这些公司的核心。\n角色的转变或许是痛苦的，甚至会像文章所说的那样，变得有些“无聊”。我们可能会失去一些亲手创造的“流心”时刻。但这是进化的代价，也是我们保持价值的唯一途径。\n现在，拿起你的冲浪板，开始学习如何驾驭这波巨浪吧。\n成为一名“智能体软件工程师”，从今天开始\n参考链接 linkAI 正在重写“软件工程师”的岗位描述：未来你需要这 6 项核心技能 - Tony Bai\nThe Agentic Software Engineer | DoltHub Blog\n"
            }
        );
    index.add(
            {
                id:  33 ,
                href: "\/docs\/%E6%97%A5%E5%B8%B8\/",
                title: "资讯文章",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  34 ,
                href: "\/docs\/ai\/",
                title: "AI 实践",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  35 ,
                href: "\/docs\/ai\/mcp-%E5%88%9D%E8%AF%95%E9%AA%8C\/",
                title: "MCP 初试验",
                description: "Where are we?（我们现在在哪？） link现在已经拥有了数据分析平台，拥有的基本的数据查询和数据分析能力。\nWhere are we going?（我们要到哪⼉去？） link但是我们的分析平台想和AI进行结合，能够拥有更灵活，更简单，更智能的查询方式，能够通过自然语言去执行对应的查询和分析工作，不再依赖一板一眼的面板操作\nHow can we get there?（我们如何到达那⾥？） link增加MCP服务，衔接后端服务和智能体客户端（可以是Cursor，Trae这样的，也可以是自己开发的）\n示例 link MCP实现方式并不拘泥于某种编程语言，本文以Java实现。\nSystem requirements 系统要求 linkJava 17 或更高版本已安装。 Spring Boot 3.3.x 或更高版本\n依赖选择 link通过 SpringBoot 项目初始化之后，再额外添加以下依赖\norg.springframework.ai\rspring-ai-starter-mcp-server\rorg.springframework\rspring-web\rBest Practices 最佳实践 link 作者提示： 这里虽说是最佳实践，我以为是必须要严格执行的。后文中的属性配置，其实就是这里要求的具体实现。\nUse a logging library that writes to stderr or files. 使用将日志写入 stderr 或文件的日志库。 Ensure any configured logging library will not write to STDOUT 确保任何配置的日志库不会将日志写入 STDOUT 程序属性配置 link spring.main.bannerMode=off\rlogging.pattern.console= 或者习惯yaml的话\n",
                content: "Where are we?（我们现在在哪？） link现在已经拥有了数据分析平台，拥有的基本的数据查询和数据分析能力。\nWhere are we going?（我们要到哪⼉去？） link但是我们的分析平台想和AI进行结合，能够拥有更灵活，更简单，更智能的查询方式，能够通过自然语言去执行对应的查询和分析工作，不再依赖一板一眼的面板操作\nHow can we get there?（我们如何到达那⾥？） link增加MCP服务，衔接后端服务和智能体客户端（可以是Cursor，Trae这样的，也可以是自己开发的）\n示例 link MCP实现方式并不拘泥于某种编程语言，本文以Java实现。\nSystem requirements 系统要求 linkJava 17 或更高版本已安装。 Spring Boot 3.3.x 或更高版本\n依赖选择 link通过 SpringBoot 项目初始化之后，再额外添加以下依赖\norg.springframework.ai\rspring-ai-starter-mcp-server\rorg.springframework\rspring-web\rBest Practices 最佳实践 link 作者提示： 这里虽说是最佳实践，我以为是必须要严格执行的。后文中的属性配置，其实就是这里要求的具体实现。\nUse a logging library that writes to stderr or files. 使用将日志写入 stderr 或文件的日志库。 Ensure any configured logging library will not write to STDOUT 确保任何配置的日志库不会将日志写入 STDOUT 程序属性配置 link spring.main.bannerMode=off\rlogging.pattern.console= 或者习惯yaml的话\nlogging:\rpattern:\rconsole:\rspring:\rmain:\rbanner-mode: off 相关的配置全集 ： 点击查看\n编写Service link官方文档内容如下：\n@Service 注解会自动将服务注册到应用程序上下文中。Spring AI @Tool 注解，使得创建和维护 MCP 工具变得非常容易。The auto-configuration will automatically register these tools with the MCP server. 自动配置会自动将这些工具注册到 MCP 服务器上。\n作者按： 看起来与平常编写sevice，并无二异。但其中暗藏玄机\n和前面提到的一样， 编码过程不要出现任何打印输出的内容，如果非要打印，以err的形式打印 Sysout.err.println(); @Tool 注解会将对应的方法 注册到MCP服务器上作为工具使用 package com.xmic.mcp.data.analysis.service;\rimport com.fasterxml.jackson.databind.ObjectMapper;\rimport com.xmic.mcp.data.analysis.common.Constants;\rimport com.xmic.mcp.data.analysis.common.R;\rimport com.xmic.mcp.data.analysis.common.ResponseData;\rimport com.xmic.mcp.data.analysis.dto.DataQueryDTO;\rimport com.xmic.mcp.data.analysis.dto.ItemDTO;\rimport com.xmic.mcp.data.analysis.utils.JsonUtils;\rimport org.springframework.ai.tool.annotation.Tool;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.web.client.RestClient;\rimport java.util.HashMap;\rimport java.util.List;\rimport java.util.Map;\rimport java.util.Objects;\r@Service\rpublic class DataQueryService {\r@Autowired\rprivate ObjectMapper objectMapper;\rprivate static final String BASE_URL = \"http://192.168.15.172/api\";\rprivate RestClient restClient;\rpublic DataQueryService() {\rthis.restClient = RestClient.builder()\r.baseUrl(BASE_URL)\r.defaultHeader(\"Accept\", \"*/*\")\r.defaultHeader(\"Content-Type\", \"application/json\")\r.defaultHeader(\"User-Agent\", \"WeatherApiClient/1.0 (zxt@xmic.com)\")\r.defaultHeader(\"Authorization\", Constants.TOKEN_NEVER_EXPIRE)\r.build();\r}\r@Tool(description = \"依据工作面code和设备因子名称查询对应的历史数据，包含 最大值，平均值，和最小值\")\rpublic String queryHistoryDataOnFaceCode(DataQueryDTO query) {\r// 判断query中 faceCode ,factorCode 不能为空\rif (Objects.isNull(query.getFaceCode()) || Objects.isNull(query.getFactorCodes())) {\rreturn \"faceCode 和 factorCode 不能为空\";\r}\rMap result = new HashMap\u003c\u003e();\rR response = restClient.post()\r.uri(\"/data/history/chart/figure2D\")\r.body(query)\r.retrieve()\r.body(R.class);\rif (Objects.isNull(response)) {\rresult.put(\"msg\", \"查询失败了\");\rreturn JsonUtils.toJson(result);\r}\rif (Objects.equals(response.getStatus(), R.OK)) {\rResponseData responseData = objectMapper.convertValue(response.getData(), ResponseData.class);\rMap"
            }
        );
    search.addEventListener('input', show_results, true);

    function show_results(){
        const maxResult =  5 ;
        const minlength =  0 ;
        var searchQuery = sanitizeHTML(this.value);
        var results = index.search(searchQuery, {limit: maxResult, enrich: true});

        
        const flatResults = new Map(); 
        for (const result of results.flatMap(r => r.result)) {
        if (flatResults.has(result.doc.href)) continue;
        flatResults.set(result.doc.href, result.doc);
        }

        suggestions.innerHTML = "";
        suggestions.classList.remove('d-none');

        
        if (searchQuery.length < minlength) {
            const minCharMessage = document.createElement('div')
            minCharMessage.innerHTML = `Please type at least <strong>${minlength}</strong> characters`
            minCharMessage.classList.add("suggestion__no-results");
            suggestions.appendChild(minCharMessage);
            return;
        } else {
            
            if (flatResults.size === 0 && searchQuery) {
                const noResultsMessage = document.createElement('div')
                noResultsMessage.innerHTML = "No results for" + ` "<strong>${searchQuery}</strong>"`
                noResultsMessage.classList.add("suggestion__no-results");
                suggestions.appendChild(noResultsMessage);
                return;
            }
        }

        
        for(const [href, doc] of flatResults) {
            const entry = document.createElement('div');
            suggestions.appendChild(entry);

            const a = document.createElement('a');
            a.href = href;
            entry.appendChild(a);

            const title = document.createElement('span');
            title.textContent = doc.title;
            title.classList.add("suggestion__title");
            a.appendChild(title);

            const description = document.createElement('span');
            description.textContent = doc.description;
            description.classList.add("suggestion__description");
            a.appendChild(description);

            suggestions.appendChild(entry);

            if(suggestions.childElementCount == maxResult) break;
        }
    }
    }());
</script>
        
    </body>
</html>
