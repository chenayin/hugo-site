<!DOCTYPE html>





    

    

    

    

<html lang="zh-CN"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <title>Python核心技术与实战 | 别人打药我拽管</title>
    <meta name="robots" content="noindex">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="Documentation, Hugo, Hugo Theme, Bootstrap" />
    <meta name="author" content="Colin Wilson - Lotus Labs" />
    <meta name="email" content="support@aigis.uk" />
    <meta name="website" content="https://lotusdocs.dev" />
    <meta name="Version" content="v0.1.0" />
    
    <link rel="icon" href="http://localhost:1313/favicon.ico" sizes="any">
<link rel="icon" type="image/svg+xml" href="http://localhost:1313/favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="manifest" crossorigin="use-credentials" href="http://localhost:1313/site.webmanifest">
<meta property="og:title" content="Python核心技术与实战" />
<meta property="og:description" content="课程介绍 linkPython核心技术与实战
人工智能时代下，Python毫无疑问是最热的编程语言。有人夸它功能强大还上手轻松，有人说它学习曲线不那么陡峭，但是更多的人，在推开Python的大门后却发现，Python入门容易但精通却不易?

你是否也曾傻傻分不清“列表”“元组”“字典”“集合”等的用法，甚至试图在集合中采用索引方式?
你是否也曾苦苦钻研面向对象的理念，却在被要求设计一个稍复杂点的系统时束手无策？
你是否也曾羡慕别人能巧用装饰器、生成器等高级操作，可自己在写代码时，却连异常抛出、内存不足等边界条件都战战兢兢搞不定呢？

由此可见，想要精通这门语言，必须真正理解知识概念，比如适当从源码层面深化认知，然后熟悉实际的工程应用，独立完成项目开发。这样，你才能成为真正的语言高手?
在这个专栏里，景霄会从工程的角度，带你学习Python。专栏基于Python最新的3.7版本，以语言知识结合工程应用为主线，其中包含了大量的独家解读和实际工作案例。内容难易兼顾，既可以带你巩固核心基础，更会教你各种高级进阶操作，让你循序渐进、系统掌握Python这门语言?
专栏按照进阶难度分为4个模块?
前两部分主要?Python的基础篇和进阶篇。除去必要的概念、操作讲解，基础篇和进阶篇都着重强调了学习中的重难点和易错?，并从性能分析、实际应用举例等不同维度出发，让你轻松理解和掌握它们?
第三部分?规范?，通过讲解合理分解代码、运用assert、写单元测试等具体编程技巧，教你写出高质量的Python程序?
第四部分则是实战篇，这部分会通过量化交易系统项目的开发，带你串联起前面所学的Python知识，并加入大量的实战经验和技巧，让你在独立项目开发中获得质的提高?
课程的练习代码：
https://github.com/zwdnet/PythonPractice
开篇词 link你好，我是景霄?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/00---%E5%BC%80%E7%AF%87%E8%AF%8D/" /><meta property="og:image" content="http://localhost:1313/opengraph/card-base-2_hu_dfe25bc65e22b972.png"/><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2025-08-04T10:59:24+08:00" />
<meta property="article:modified_time" content="2025-08-04T10:59:24+08:00" /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://localhost:1313/opengraph/card-base-2_hu_dfe25bc65e22b972.png"/>
<meta name="twitter:title" content="Python核心技术与实战"/>
<meta name="twitter:description" content="课程介绍 linkPython核心技术与实战
人工智能时代下，Python毫无疑问是最热的编程语言。有人夸它功能强大还上手轻松，有人说它学习曲线不那么陡峭，但是更多的人，在推开Python的大门后却发现，Python入门容易但精通却不易?

你是否也曾傻傻分不清“列表”“元组”“字典”“集合”等的用法，甚至试图在集合中采用索引方式?
你是否也曾苦苦钻研面向对象的理念，却在被要求设计一个稍复杂点的系统时束手无策？
你是否也曾羡慕别人能巧用装饰器、生成器等高级操作，可自己在写代码时，却连异常抛出、内存不足等边界条件都战战兢兢搞不定呢？

由此可见，想要精通这门语言，必须真正理解知识概念，比如适当从源码层面深化认知，然后熟悉实际的工程应用，独立完成项目开发。这样，你才能成为真正的语言高手?
在这个专栏里，景霄会从工程的角度，带你学习Python。专栏基于Python最新的3.7版本，以语言知识结合工程应用为主线，其中包含了大量的独家解读和实际工作案例。内容难易兼顾，既可以带你巩固核心基础，更会教你各种高级进阶操作，让你循序渐进、系统掌握Python这门语言?
专栏按照进阶难度分为4个模块?
前两部分主要?Python的基础篇和进阶篇。除去必要的概念、操作讲解，基础篇和进阶篇都着重强调了学习中的重难点和易错?，并从性能分析、实际应用举例等不同维度出发，让你轻松理解和掌握它们?
第三部分?规范?，通过讲解合理分解代码、运用assert、写单元测试等具体编程技巧，教你写出高质量的Python程序?
第四部分则是实战篇，这部分会通过量化交易系统项目的开发，带你串联起前面所学的Python知识，并加入大量的实战经验和技巧，让你在独立项目开发中获得质的提高?
课程的练习代码：
https://github.com/zwdnet/PythonPractice
开篇词 link你好，我是景霄?"/>

    
        <link rel="alternate" type="application/atom+xml" title="Atom feed for 别人打药我拽管" href="/index.xml" />
    
    
    
            
                <script type="text/javascript" src="http://localhost:1313/docs/js/flexsearch.bundle.js"></script>
            
        
    
    

    <link rel="stylesheet" href="/docs/scss/style.css" crossorigin="anonymous">
    
    
    </head>
<body>
        <div class="content">
            <div class="page-wrapper toggled">
<nav id="sidebar" class="sidebar-wrapper">
    <div class="sidebar-brand">
        <a href='/' aria-label="HomePage" alt="HomePage">
            
                <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
            
        </a>
    </div>
    <div class="sidebar-content" style="height: calc(100% - 131px);">
        <ul class="sidebar-menu">
            
                
                
                    
                    
                        <li class="sidebar-dropdown  current active">
                            <button class="btn">
                                <i class="material-icons me-2">Summarize</i>
                                Python
                            </button>
                            <div class="sidebar-submenu d-block">
                                <ul>
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python/">Python学习笔记</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/">Python中的集合</a></li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  current active">
                                                <button class="btn">
                                                    
                                                    Python核心技术与实战
                                                </button>
                                                <div class="sidebar-submenu d-block">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class="current "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/00---%E5%BC%80%E7%AF%87%E8%AF%8D/">Python核心技术与实战</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/01---%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E7%AA%81%E7%A0%B4%E6%88%90%E4%B8%BApython%E9%AB%98%E6%89%8B/">01-如何逐步突破，成为Python高手</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/03---%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E5%88%B0%E5%BA%95%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA/">03-列表和元组，到底用哪一个？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/06---python-%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/">06 - Python &#34;黑箱&#34;：输入与输出</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/08---%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/">08 - 异常处理：如何提高程序的稳定性？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/09---%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/">09 - 不可或缺的自定义函数</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/10---%E7%AE%80%E7%BA%A6%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/">10 - 简约不简单的匿名函数</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/12---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">12 - 面向对象（下）：如何实现一个搜索引擎？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/14---%E7%AD%94%E7%96%91%E4%B8%80%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/">14 - 答疑（一）：列表和元组的内部实现是怎样的？</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/17---%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/">17 - 强大的装饰器</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/20---%E6%8F%AD%E7%A7%98-python-%E5%8D%8F%E7%A8%8B/">20 - 揭秘 Python 协程</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">Newsmode</i>
                                AI 实践
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="http://localhost:1313/docs/ai/mcp-%E5%88%9D%E8%AF%95%E9%AA%8C/">MCP 初试验</a></li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
            
        </ul>
        
    </div>
    
        <ul class="sidebar-footer list-unstyled mb-0">
            
        </ul>
    
</nav>

                    <main class="page-content bg-transparent">
                        
<div id="top-header" class="top-header d-print-none">
    <div class="header-bar d-flex justify-content-between">
        <div class="d-flex align-items-center">
            <a href='/' class="logo-icon me-3" aria-label="HomePage" alt="HomePage">
                <div class="small">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
                <div class="big">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
            </a>
            <button id="close-sidebar" class="btn btn-icon btn-soft">
                <span class="material-icons size-20 menu-icon align-middle">menu</span>
            </button>
            
            
                    
                    <button id="flexsearch-button" class="ms-3 btn btn-soft" data-bs-toggle="collapse" data-bs-target="#FlexSearchCollapse" aria-expanded="false" aria-controls="FlexSearchCollapse">
                        <span class="material-icons size-20 menu-icon align-middle">search</span>
                        <span class="flexsearch-button-placeholder ms-1 me-2 d-none d-sm-block">Search</span>
                        <div class="d-none d-sm-block">
                            <span class="flexsearch-button-keys">
                                <kbd class="flexsearch-button-cmd-key">
                                    <svg width="44" height="15"><path d="M2.118,11.5A1.519,1.519,0,0,1,1,11.042,1.583,1.583,0,0,1,1,8.815a1.519,1.519,0,0,1,1.113-.458h.715V6.643H2.118A1.519,1.519,0,0,1,1,6.185,1.519,1.519,0,0,1,.547,5.071,1.519,1.519,0,0,1,1,3.958,1.519,1.519,0,0,1,2.118,3.5a1.519,1.519,0,0,1,1.114.458A1.519,1.519,0,0,1,3.69,5.071v.715H5.4V5.071A1.564,1.564,0,0,1,6.976,3.5,1.564,1.564,0,0,1,8.547,5.071,1.564,1.564,0,0,1,6.976,6.643H6.261V8.357h.715a1.575,1.575,0,0,1,1.113,2.685,1.583,1.583,0,0,1-2.227,0A1.519,1.519,0,0,1,5.4,9.929V9.214H3.69v.715a1.519,1.519,0,0,1-.458,1.113A1.519,1.519,0,0,1,2.118,11.5Zm0-.857a.714.714,0,0,0,.715-.714V9.214H2.118a.715.715,0,1,0,0,1.429Zm4.858,0a.715.715,0,1,0,0-1.429H6.261v.715a.714.714,0,0,0,.715.714ZM3.69,8.357H5.4V6.643H3.69ZM2.118,5.786h.715V5.071a.714.714,0,0,0-.715-.714.715.715,0,0,0-.5,1.22A.686.686,0,0,0,2.118,5.786Zm4.143,0h.715a.715.715,0,0,0,.5-1.22.715.715,0,0,0-1.22.5Z" fill="currentColor"></path><path d="M12.4,11.475H11.344l3.879-7.95h1.056Z" fill="currentColor"></path><path d="M25.073,5.384l-.864.576a2.121,2.121,0,0,0-1.786-.923,2.207,2.207,0,0,0-2.266,2.326,2.206,2.206,0,0,0,2.266,2.325,2.1,2.1,0,0,0,1.782-.918l.84.617a3.108,3.108,0,0,1-2.622,1.293,3.217,3.217,0,0,1-3.349-3.317,3.217,3.217,0,0,1,3.349-3.317A3.046,3.046,0,0,1,25.073,5.384Z" fill="currentColor"></path><path d="M30.993,5.142h-2.07v5.419H27.891V5.142h-2.07V4.164h5.172Z" fill="currentColor"></path><path d="M34.67,4.164c1.471,0,2.266.658,2.266,1.851,0,1.087-.832,1.809-2.134,1.855l2.107,2.691h-1.28L33.591,7.87H33.07v2.691H32.038v-6.4Zm-1.6.969v1.8h1.572c.832,0,1.22-.3,1.22-.918s-.411-.882-1.22-.882Z" fill="currentColor"></path><path d="M42.883,10.561H38.31v-6.4h1.033V9.583h3.54Z" fill="currentColor"></path></svg>
                                </kbd>
                                <kbd class="flexsearch-button-key">
                                    <svg width="15" height="15"><path d="M5.926,12.279H4.41L9.073,2.721H10.59Z" fill="currentColor"/></svg>
                                </kbd>
                            </span>
                        </div>
                    </button>
                
            </div>

        <div class="d-flex align-items-center">
            <ul class="list-unstyled mb-0">
                
            </ul>
            
        </div>
    </div>
    
    
            <div class="collapse" id="FlexSearchCollapse">
                <div class="flexsearch-container">
                    <div class="flexsearch-keymap">
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to navigate</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to select</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to close</span>
                        </li>
                    </div>
                    <form class="flexsearch position-relative flex-grow-1 ms-2 me-2">
                        <div class="d-flex flex-row">
                            <input id="flexsearch" class="form-control" type="search" placeholder="Search" aria-label="Search" autocomplete="off">
                            <button id="hideFlexsearch" type="button" class="ms-2 btn btn-soft">
                                cancel
                            </button>
                        </div>
                        <div id="suggestions" class="shadow rounded-1 d-none"></div>
                    </form>
                </div>
            </div>
        
    
    
</div>


                            <div class="container-fluid">
                                <div class="layout-spacing">
                                    
                                        <div class="d-md-flex justify-content-between align-items-center"><nav aria-label="breadcrumb" class="d-inline-block pb-2 mt-1 mt-sm-0">
    <ul id="breadcrumbs" class="breadcrumb bg-transparent mb-0" itemscope itemtype="https://schema.org/BreadcrumbList">
        
            
                <li class="breadcrumb-item text-capitalize active" aria-current="page" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/">
                        <i class="material-icons size-20 align-text-bottom" itemprop="name">Home</i>
                    </a>
                    <meta itemprop="position" content='1' />
                </li>
            
            
                <li class="breadcrumb-item text-capitalize" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/python/">
                        <span itemprop="name">Python</span>
                    </a>
                    <meta itemprop="position" content='2' />
                </li>
            
            
                <li class="breadcrumb-item text-capitalize" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/">
                        <span itemprop="name">Python核心技术与实战</span>
                    </a>
                    <meta itemprop="position" content='3' />
                </li>
            
        
            <li class="breadcrumb-item text-capitalize active" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                <span itemprop="name">Python核心技术与实战</span>
                <meta itemprop="position" content='4' />
            </li>
        
    </ul>
</nav></div>
                                    
                                    <div class="row flex-xl-nowrap">
                                        
                                        <div class="docs-toc col-xl-3    d-xl-block"><toc>
    <div class="fw-bold text-uppercase mb-2">On this page</div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#课程介绍">课程介绍</a></li>
    <li><a href="#开篇词">开篇词</a></li>
  </ul>
</nav>
    </toc></div>
                                        
                                        
                                        <div class="docs-toc-mobile    d-print-none d-xl-none">
                                            <button id="toc-dropdown-btn" class="btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" data-bs-offset="0,0" aria-expanded="false">
                                                Table of Contents
                                            </button>
<nav id="toc-mobile">
  <ul class="dropdown-menu">
    <li><a href="#课程介绍">课程介绍</a></li>
    <li><a href="#开篇词">开篇词</a></li>
  </ul>
</nav></div>
                                        <div class="docs-content col-12 col-xl-9 mt-0">
                                            <div class="mb-0 d-flex">
                                                
                                                <i class="material-icons title-icon me-2">article</i>
                                                
                                                <h1 class="content-title mb-0">
                                                    Python核心技术与实战
                                                    
                                                </h1>
                                            </div>
                                            
                                            <div id="content" class="main-content" >
                                                
    
    <div data-prismjs-copy="" data-prismjs-copy-success="" data-prismjs-copy-error="">
        <h2 id="课程介绍">课程介绍 <a href="#%e8%af%be%e7%a8%8b%e4%bb%8b%e7%bb%8d" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>Python核心技术与实战</p>
<p>人工智能时代下，Python毫无疑问是最热的编程语言。有人夸它功能强大还上手轻松，有人说它学习曲线不那么陡峭，但是更多的人，在推开Python的大门后却发现，Python入门容易但精通却不易?</p>
<ul>
<li>你是否也曾傻傻分不清“列表”“元组”“字典”“集合”等的用法，甚至试图在集合中采用索引方式?</li>
<li>你是否也曾苦苦钻研面向对象的理念，却在被要求设计一个稍复杂点的系统时束手无策？</li>
<li>你是否也曾羡慕别人能巧用装饰器、生成器等高级操作，可自己在写代码时，却连异常抛出、内存不足等边界条件都战战兢兢搞不定呢？</li>
</ul>
<p>由此可见，想要精通这门语言，必须真正理解知识概念，比如适当从源码层面深化认知，然后熟悉实际的工程应用，独立完成项目开发。这样，你才能成为真正的语言高手?</p>
<p>在这个专栏里，景霄会从工程的角度，带你学习Python。专栏基于Python最新的3.7版本，以语言知识结合工程应用为主线，其中包含了大量的独家解读和实际工作案例。内容难易兼顾，既可以带你巩固核心基础，更会教你各种高级进阶操作，让你循序渐进、系统掌握Python这门语言?</p>
<p>专栏按照<strong>进阶难度</strong>分为4个模块?</p>
<p>前两部分主要?<em>Python的基础篇和进阶篇。除去必要的概念、操作讲解，基础篇和进阶篇都着重强调了学习中的重难点和易错?</em>，并从性能分析、实际应用举例等不同维度出发，让你轻松理解和掌握它们?</p>
<p>第三部分?<em>规范?</em>，通过讲解合理分解代码、运用assert、写单元测试等具体编程技巧，教你写出高质量的Python程序?</p>
<p>第四部分则是<strong>实战篇，这部分会通过量化交易系统项目的开发，带你串联起前面所学的Python知识</strong>，并加入大量的实战经验和技巧，让你在独立项目开发中获得质的提高?</p>
<p>课程的练习代码：<br>
<a href="https://github.com/zwdnet/PythonPractice" rel="external" target="_blank">https://github.com/zwdnet/PythonPractice<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/></svg></a></p>
<h2 id="开篇词">开篇词 <a href="#%e5%bc%80%e7%af%87%e8%af%8d" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>你好，我是景霄?</p>
<p>我是Facebook的一名全栈工程师，目前从事机器学习的相关工作，主要工作领域是人工智能的推荐排序系统与算法。工作期间，我曾领导多个上亿用户级产品的开发与落地，有丰富的工程与实战经验?</p>
<p>一听机器学习，很多人第一反应可能是“好难呀、厉害呀”。可事实上，我的编程之路并非一路高光?</p>
<p>不同于大城市长大或竞赛出身、十一二岁接触编程的人，在刚上大学时，我的编程基础几乎为零。大一上的C语言，便是我出生起学到的第一门编程语言。初识计算机语言的世界，很有趣也很吸引我，这也是我成为程序员的最初动力?</p>
<p>和很多对编程感兴趣的人一样，哪怕老师只是在讲台上，照本宣科地读着N年前的课件，我也会竖起耳朵认真听讲、认真做笔记。并且，私下里我还买了不少厚重的大块头书，在网上查了不少博客、帖子，照着上面的例子一行行地敲代码。很多内容我并不理解，比如指针、递归这类抽象的概念，查了一堆资料也没看明白。但靠着死记硬背，考试基本可以过关，虽然这个过程比较痛苦，也比较累?</p>
<p>后来，为了更深入了解计算机，我去了哥伦比亚大学攻读计算机硕士学位，又陆续学到不少新的编程语言，比如Node.js、Python、PHP、Scala等等。这个阶段，我边学习，边做项目，却发现轻松了很多?</p>
<p>这两个学习阶段，收获和感受天差地别，难道仅仅是因为“万事入门难”吗？我不止一次反思过这个问题，终于发现，问题出在?*资料本身**上?</p>
<p>为什么这么说呢？一是因为书上或网上的很多东西，非常理论化，实例少之又少，单凭死记硬背很难真正掌握；二是这些内容中，原创的观点和经验更少，大多互相抄袭，内容雷同且不实用，远离实际工程，毫无借鉴价值?</p>
<p>但显然，市面上的资料问题，我们个人是很难解决的。我们能做的，便是克服常见资料的弊端，另辟蹊径来学习。这其中，最重要的一点就是，从工程的角度思考学习，以实用为出发点，多练习、多阅读、多做项目，这样才能有质的提高?</p>
<p>在Facebook工作的这么多年，也验证了我的观点。我身边的新手，他们学习新的语言总是只会啃书练习，还难以上手；而有经验的同事则不同，他们能花很短的时间看完基础语法，然后找行家去了解一些重难点、易错点，最后亲自动手完成一个项目，达到融会贯通的效果。这样下来，可能几周时间就掌握得差不多了?</p>
<p>这样的差距，确实让人心塞，而这也是我开这个专栏的最初动力——帮助更多入门级程序员迅速成长。至于专栏主题，我选择了Python这门编程语言，原因也很明了?</p>
<p>这首先来自于我个人的重要感悟。经过多年学习工作的积累，我深刻认识到，<strong>牢牢掌握一门编程语言及其学习方法，是日后在所有领域深造的根基</strong>。而在实际工作和生活中，我更是见过不少反例，比如搞机器学习的工程师，算法、理论等极强，但是编程水平或是工程水平很一般，于是涉及到偏工程的工作或合作时，就显得力不从心，这样就非常可惜了?</p>
<p>另外，不可否认，Python确实是这个时代最流行、也必须要掌握的编程语言。Python可以运用在数据处理、Web开发、人工智能等多个领域，它的语言简洁、开发效率高、可移植性强，并且可以和其他编程语言（比如C++）轻松无缝衔接。现如今，不少学校的文科生甚至中学生也开设了此课程，可见其重要程度?</p>
<p>因此，我决定开设这么一个专栏，从工程的角度去讲解Python这门编程语言。我不是语言学专家，不会死抠一些很偏的知识点；相反，作为一名工程师，我会从实际出发，以工作中遇到的实例为主线，去讲解Python的核心技术和应用?</p>
<p>专栏的所有内容都基于Python最新的3.7版本，其中有大量独家解读、案例，以及不少我阅读源码后的发现和体会。同时，在层次划分上，我希望能难易兼顾，循序渐进。专栏中既有核心的基础知识，也有高级的进阶操作，尽量做到“老少皆宜”?</p>
<p>从内容上来说，专栏主要分为四大版块?</p>
<p>*<em>1. Python基础?</em></p>
<p>第一部分主要讲解Python的基础知识。当然，不同于其他基础教材，专栏的基础版块并不只有基础概念、操作，我同时加入了很多进阶难度的知识，或是一些重难点、易错点等需要注意的地方。如果你觉得自己基础的东西都会了，这部分不用学了，那你就大错特错了。比如，</p>
<ul>
<li>列表和元组存储结构的差异是怎样的？它们性能的详细比较又如何?</li>
<li>字符串相加的时间复杂度，你真的清楚吗?</li>
</ul>
<p>基础不牢，地动山摇。更深刻、实质的基础理解，才是更牢固的知识大厦的根基。我希望这一版块，不仅可以让入门级的程序员查漏补缺、打牢基础，也能让有经验的程序员，重新从工程角度认识基础、升华理解?</p>
<p>*<em>2. Python进阶?</em></p>
<p>这部分讲的是 Python的一些进阶知识，比如装饰器、并发编程等等。如果你的工作只是写100行以下的脚本程序，可能不怎么会用得到。但如果你做的是大型程序的开发，则非常有必要。我希望通过这一版块，让你熟悉各种高级用法，真正理解Python，理解这门编程语言的特点?</p>
<p>*<em>3. Python规范?</em></p>
<p>这部分着重于教你把程序写得更加规范、更加稳定。我在实际工作中见过不少程序员，会写程序，但写得实在有点“惨不忍睹”，导致最后调试起来错误不断，修改非常费劲儿。因此，我觉得用单独一个版块讲解这个问题非常有必要?</p>
<p>当然，我不会用一些似是而非的规范来说教，而是会用具体的编程操作和技巧，教你提高代码质量。比如，如何合理地分解代码、运用assert，如何写单元测试等等?</p>
<p>*<em>4. Python实战?</em></p>
<p>没上过战场开过枪的人，不可能做主官；没有实战经验的语言学习者，不可能成为高手。这部分?<em>我会通过量化交易系统这个具体的实战案例，带你综合运用前面所学的Python知识</em>*?</p>
<p>真正要掌握一门编程语言，仅仅学会分散的知识点是不够的，还必须要把知识点串联起来，做一些中型的项目才能有更深的领悟与提高?</p>
<p>专栏篇幅只有40多篇，但是每篇绝对都是干货满满。我希望这个专栏，能帮助更多入门级和有一定项目基础的程序员，真正掌握Python，并且给你一些学习上的启发?</p>
<p>100天后，晋级为Python高手，让我们一起加油吧?</p>
<p>课程的练习代码：<a href="https://github.com/zwdnet/PythonPractice" rel="external" target="_blank">https://github.com/zwdnet/PythonPractice<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/></svg></a></p>

    </div>

    

    
                                            </div>
                                            <div><hr class="doc-hr">
<div id="doc-nav" class="d-print-none">

	<div class="row flex-xl-nowrap flex-row-reverse">
	<div class="col-sm-6 pt-2 doc-prev">
		<a class="ms-auto" href="/docs/python/python/">
			<div class="card h-100 my-1 text-end">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0">Python学习笔记 <i class="material-icons align-middle">navigate_next</i></p>
					
				</div>
			</div>
		</a>
        </div>
	</div>
</div></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
<footer class="shadow py-3 d-print-none">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col">
                <div class="text-sm-start text-center mx-md-2">
                    <p class="mb-0">
                        
                        <strong>NineDoller</strong>@<strong><a href="http://net.chenayin.com">Chenayin</a></strong>
                    </p>
                </div>
            </div>
        </div>
    </div>
</footer>
</main>
            </div>
        </div>

        
        
        <button onclick="topFunction()" id="back-to-top" aria-label="Back to Top Button" class="back-to-top fs-5"><svg width="24" height="24"><path d="M12,10.224l-6.3,6.3L4.32,15.152,12,7.472l7.68,7.68L18.3,16.528Z" style="fill:#fff"/></svg></button>
        
        

        
        




    
    
    






    <script src="/docs/js/bootstrap.js" defer></script>


    <script type="text/javascript" src="http://localhost:1313/docs/js/bundle.js" defer></script>

        

        
        <script type="module">
    var suggestions = document.getElementById('suggestions');
    var search = document.getElementById('flexsearch');

    const flexsearchContainer = document.getElementById('FlexSearchCollapse');

    const hideFlexsearchBtn = document.getElementById('hideFlexsearch');

    const configObject = { toggle: false }
    const flexsearchContainerCollapse = new Collapse(flexsearchContainer, configObject) 

    if (search !== null) {
        document.addEventListener('keydown', inputFocus);
        flexsearchContainer.addEventListener('shown.bs.collapse', function () {
            search.focus();
        });
        
        var topHeader = document.getElementById("top-header");
        document.addEventListener('click', function(elem) {
            if (!flexsearchContainer.contains(elem.target) && !topHeader.contains(elem.target))
                flexsearchContainerCollapse.hide();
        });
    }

    hideFlexsearchBtn.addEventListener('click', () =>{
        flexsearchContainerCollapse.hide()
    })

    function inputFocus(e) {
        if (e.ctrlKey && e.key === '/') {
            e.preventDefault();
            flexsearchContainerCollapse.toggle();
        }
        if (e.key === 'Escape' ) {
            search.blur();
            
            flexsearchContainerCollapse.hide();
        }
    };

    document.addEventListener('click', function(event) {

    var isClickInsideElement = suggestions.contains(event.target);

    if (!isClickInsideElement) {
        suggestions.classList.add('d-none');
    }

    });

    


    document.addEventListener('keydown',suggestionFocus);

    function suggestionFocus(e) {
    const suggestionsHidden = suggestions.classList.contains('d-none');
    if (suggestionsHidden) return;

    const focusableSuggestions= [...suggestions.querySelectorAll('a')];
    if (focusableSuggestions.length === 0) return;

    const index = focusableSuggestions.indexOf(document.activeElement);

    if (e.key === "ArrowUp") {
        e.preventDefault();
        const nextIndex = index > 0 ? index - 1 : 0;
        focusableSuggestions[nextIndex].focus();
    }
    else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
        focusableSuggestions[nextIndex].focus();
    }

    }

    


    (function(){

    var index = new FlexSearch.Document({
        
        tokenize: "forward",
        minlength:  0 ,
        cache:  100 ,
        optimize:  true ,
        document: {
        id: 'id',
        store: [
            "href", "title", "description"
        ],
        index: ["title", "description", "content"]
        }
    });


    


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    

    

    index.add(
            {
                id:  0 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/00---%E5%BC%80%E7%AF%87%E8%AF%8D\/",
                title: "Python核心技术与实战",
                description: "课程介绍 linkPython核心技术与实战\n人工智能时代下，Python毫无疑问是最热的编程语言。有人夸它功能强大还上手轻松，有人说它学习曲线不那么陡峭，但是更多的人，在推开Python的大门后却发现，Python入门容易但精通却不易��?\n你是否也曾傻傻分不清“列表”“元组”“字典”“集合”等的用法，甚至试图在集合中采用索引方式��? 你是否也曾苦苦钻研面向对象的理念，却在被要求设计一个稍复杂点的系统时束手无策？ 你是否也曾羡慕别人能巧用装饰器、生成器等高级操作，可自己在写代码时，却连异常抛出、内存不足等边界条件都战战兢兢搞不定呢？ 由此可见，想要精通这门语言，必须真正理解知识概念，比如适当从源码层面深化认知，然后熟悉实际的工程应用，独立完成项目开发。这样，你才能成为真正的语言高手��?\n在这个专栏里，景霄会从工程的角度，带你学习Python。专栏基于Python最新的3.7版本，以语言知识结合工程应用为主线，其中包含了大量的独家解读和实际工作案例。内容难易兼顾，既可以带你巩固核心基础，更会教你各种高级进阶操作，让你循序渐进、系统掌握Python这门语言��?\n专栏按照进阶难度分为4个模块��?\n前两部分主要��?Python的基础篇和进阶篇。除去必要的概念、操作讲解，基础篇和进阶篇都着重强调了学习中的重难点和易错��?，并从性能分析、实际应用举例等不同维度出发，让你轻松理解和掌握它们��?\n第三部分��?规范��?，通过讲解合理分解代码、运用assert、写单元测试等具体编程技巧，教你写出高质量的Python程序��?\n第四部分则是实战篇，这部分会通过量化交易系统项目的开发，带你串联起前面所学的Python知识，并加入大量的实战经验和技巧，让你在独立项目开发中获得质的提高��?\n课程的练习代码：\nhttps://github.com/zwdnet/PythonPractice\n开篇词 link你好，我是景霄��?\n",
                content: "课程介绍 linkPython核心技术与实战\n人工智能时代下，Python毫无疑问是最热的编程语言。有人夸它功能强大还上手轻松，有人说它学习曲线不那么陡峭，但是更多的人，在推开Python的大门后却发现，Python入门容易但精通却不易��?\n你是否也曾傻傻分不清“列表”“元组”“字典”“集合”等的用法，甚至试图在集合中采用索引方式��? 你是否也曾苦苦钻研面向对象的理念，却在被要求设计一个稍复杂点的系统时束手无策？ 你是否也曾羡慕别人能巧用装饰器、生成器等高级操作，可自己在写代码时，却连异常抛出、内存不足等边界条件都战战兢兢搞不定呢？ 由此可见，想要精通这门语言，必须真正理解知识概念，比如适当从源码层面深化认知，然后熟悉实际的工程应用，独立完成项目开发。这样，你才能成为真正的语言高手��?\n在这个专栏里，景霄会从工程的角度，带你学习Python。专栏基于Python最新的3.7版本，以语言知识结合工程应用为主线，其中包含了大量的独家解读和实际工作案例。内容难易兼顾，既可以带你巩固核心基础，更会教你各种高级进阶操作，让你循序渐进、系统掌握Python这门语言��?\n专栏按照进阶难度分为4个模块��?\n前两部分主要��?Python的基础篇和进阶篇。除去必要的概念、操作讲解，基础篇和进阶篇都着重强调了学习中的重难点和易错��?，并从性能分析、实际应用举例等不同维度出发，让你轻松理解和掌握它们��?\n第三部分��?规范��?，通过讲解合理分解代码、运用assert、写单元测试等具体编程技巧，教你写出高质量的Python程序��?\n第四部分则是实战篇，这部分会通过量化交易系统项目的开发，带你串联起前面所学的Python知识，并加入大量的实战经验和技巧，让你在独立项目开发中获得质的提高��?\n课程的练习代码：\nhttps://github.com/zwdnet/PythonPractice\n开篇词 link你好，我是景霄��?\n我是Facebook的一名全栈工程师，目前从事机器学习的相关工作，主要工作领域是人工智能的推荐排序系统与算法。工作期间，我曾领导多个上亿用户级产品的开发与落地，有丰富的工程与实战经验��?\n一听机器学习，很多人第一反应可能是“好难呀、厉害呀”。可事实上，我的编程之路并非一路高光��?\n不同于大城市长大或竞赛出身、十一二岁接触编程的人，在刚上大学时，我的编程基础几乎为零。大一上的C语言，便是我出生起学到的第一门编程语言。初识计算机语言的世界，很有趣也很吸引我，这也是我成为程序员的最初动力��?\n和很多对编程感兴趣的人一样，哪怕老师只是在讲台上，照本宣科地读着N年前的课件，我也会竖起耳朵认真听讲、认真做笔记。并且，私下里我还买了不少厚重的大块头书，在网上查了不少博客、帖子，照着上面的例子一行行地敲代码。很多内容我并不理解，比如指针、递归这类抽象的概念，查了一堆资料也没看明白。但靠着死记硬背，考试基本可以过关，虽然这个过程比较痛苦，也比较累��?\n后来，为了更深入了解计算机，我去了哥伦比亚大学攻读计算机硕士学位，又陆续学到不少新的编程语言，比如Node.js、Python、PHP、Scala等等。这个阶段，我边学习，边做项目，却发现轻松了很多��?\n这两个学习阶段，收获和感受天差地别，难道仅仅是因为“万事入门难”吗？我不止一次反思过这个问题，终于发现，问题出在��?*资料本身**上��?\n为什么这么说呢？一是因为书上或网上的很多东西，非常理论化，实例少之又少，单凭死记硬背很难真正掌握；二是这些内容中，原创的观点和经验更少，大多互相抄袭，内容雷同且不实用，远离实际工程，毫无借鉴价值��?\n但显然，市面上的资料问题，我们个人是很难解决的。我们能做的，便是克服常见资料的弊端，另辟蹊径来学习。这其中，最重要的一点就是，从工程的角度思考学习，以实用为出发点，多练习、多阅读、多做项目，这样才能有质的提高��?\n在Facebook工作的这么多年，也验证了我的观点。我身边的新手，他们学习新的语言总是只会啃书练习，还难以上手；而有经验的同事则不同，他们能花很短的时间看完基础语法，然后找行家去了解一些重难点、易错点，最后亲自动手完成一个项目，达到融会贯通的效果。这样下来，可能几周时间就掌握得差不多了��?\n这样的差距，确实让人心塞，而这也是我开这个专栏的最初动力——帮助更多入门级程序员迅速成长。至于专栏主题，我选择了Python这门编程语言，原因也很明了��?\n这首先来自于我个人的重要感悟。经过多年学习工作的积累，我深刻认识到，牢牢掌握一门编程语言及其学习方法，是日后在所有领域深造的根基。而在实际工作和生活中，我更是见过不少反例，比如搞机器学习的工程师，算法、理论等极强，但是编程水平或是工程水平很一般，于是涉及到偏工程的工作或合作时，就显得力不从心，这样就非常可惜了��?\n另外，不可否认，Python确实是这个时代最流行、也必须要掌握的编程语言。Python可以运用在数据处理、Web开发、人工智能等多个领域，它的语言简洁、开发效率高、可移植性强，并且可以和其他编程语言（比如C++）轻松无缝衔接。现如今，不少学校的文科生甚至中学生也开设了此课程，可见其重要程度��?\n因此，我决定开设这么一个专栏，从工程的角度去讲解Python这门编程语言。我不是语言学专家，不会死抠一些很偏的知识点；相反，作为一名工程师，我会从实际出发，以工作中遇到的实例为主线，去讲解Python的核心技术和应用��?\n专栏的所有内容都基于Python最新的3.7版本，其中有大量独家解读、案例，以及不少我阅读源码后的发现和体会。同时，在层次划分上，我希望能难易兼顾，循序渐进。专栏中既有核心的基础知识，也有高级的进阶操作，尽量做到“老少皆宜”��?\n从内容上来说，专栏主要分为四大版块��?\n*1. Python基础��?\n第一部分主要讲解Python的基础知识。当然，不同于其他基础教材，专栏的基础版块并不只有基础概念、操作，我同时加入了很多进阶难度的知识，或是一些重难点、易错点等需要注意的地方。如果你觉得自己基础的东西都会了，这部分不用学了，那你就大错特错了。比如，\n列表和元组存储结构的差异是怎样的？它们性能的详细比较又如何��? 字符串相加的时间复杂度，你真的清楚吗��? 基础不牢，地动山摇。更深刻、实质的基础理解，才是更牢固的知识大厦的根基。我希望这一版块，不仅可以让入门级的程序员查漏补缺、打牢基础，也能让有经验的程序员，重新从工程角度认识基础、升华理解��?\n*2. Python进阶��?\n这部分讲的是 Python的一些进阶知识，比如装饰器、并发编程等等。如果你的工作只是写100行以下的脚本程序，可能不怎么会用得到。但如果你做的是大型程序的开发，则非常有必要。我希望通过这一版块，让你熟悉各种高级用法，真正理解Python，理解这门编程语言的特点��?\n*3. Python规范��?\n这部分着重于教你把程序写得更加规范、更加稳定。我在实际工作中见过不少程序员，会写程序，但写得实在有点“惨不忍睹”，导致最后调试起来错误不断，修改非常费劲儿。因此，我觉得用单独一个版块讲解这个问题非常有必要��?\n当然，我不会用一些似是而非的规范来说教，而是会用具体的编程操作和技巧，教你提高代码质量。比如，如何合理地分解代码、运用assert，如何写单元测试等等��?\n*4. Python实战��?\n没上过战场开过枪的人，不可能做主官；没有实战经验的语言学习者，不可能成为高手。这部分��?我会通过量化交易系统这个具体的实战案例，带你综合运用前面所学的Python知识*��?\n真正要掌握一门编程语言，仅仅学会分散的知识点是不够的，还必须要把知识点串联起来，做一些中型的项目才能有更深的领悟与提高��?\n专栏篇幅只有40多篇，但是每篇绝对都是干货满满。我希望这个专栏，能帮助更多入门级和有一定项目基础的程序员，真正掌握Python，并且给你一些学习上的启发��?\n100天后，晋级为Python高手，让我们一起加油吧��?\n课程的练习代码：https://github.com/zwdnet/PythonPractice\n"
            }
        );
    index.add(
            {
                id:  1 ,
                href: "\/docs\/python\/python\/",
                title: "Python学习笔记",
                description: " 笔者为 Javaer 所以仅记录和Java语言的不同之处，方便快速学习\n基础数据类型 link 数字 bool（布尔型）：True | False\n笔者按： 布尔值要驼峰命令\ncomplex （复数），如 1 + 2j、 1.1 + 2.2j。\n笔者按： 已经忘记复数这个数学概念啦~\n字符串 索引 字符串的组成元素为字符，每个字符在字符串中有对应的索引。\n和java不同的是，不光有正序索引，还有倒序索引\n截取 字符串的截取，都是 前闭后开 或者 叫 含头不含尾\npython字符串的截取和索引强相关；\n但又因为有正序和倒序，两排索引，所以截取时非常灵活，使用时也要谨慎\n图片来自网络，倒数第二个例子有点奇怪： 描述和结果都不对；要实现输出结果ab，可通过如下方式\nprint(str[:2]) # ab\rprint(str[:-5]) # ab str=\"abcdefg\"\rprint(str[1:]) # bcdefg\rprint(str[:5]) # abcde\rprint(str[1:5]) # bcde\rprint(str[-4:]) # defg\rprint(str[-2:-6]) # 空字符串 是 '' 不是None\rprint(str[-6:-2]) #bcde\rprint(str[::-1]) # 字符串反转 gfedcba\rprint(str[:2]) # ab\rprint(str[:-5]) # ab 列表 笔者按： 和Java中的数组特点一样； 最大最大的区别是 一个数组可以有不同类型的元素；\n",
                content: " 笔者为 Javaer 所以仅记录和Java语言的不同之处，方便快速学习\n基础数据类型 link 数字 bool（布尔型）：True | False\n笔者按： 布尔值要驼峰命令\ncomplex （复数），如 1 + 2j、 1.1 + 2.2j。\n笔者按： 已经忘记复数这个数学概念啦~\n字符串 索引 字符串的组成元素为字符，每个字符在字符串中有对应的索引。\n和java不同的是，不光有正序索引，还有倒序索引\n截取 字符串的截取，都是 前闭后开 或者 叫 含头不含尾\npython字符串的截取和索引强相关；\n但又因为有正序和倒序，两排索引，所以截取时非常灵活，使用时也要谨慎\n图片来自网络，倒数第二个例子有点奇怪： 描述和结果都不对；要实现输出结果ab，可通过如下方式\nprint(str[:2]) # ab\rprint(str[:-5]) # ab str=\"abcdefg\"\rprint(str[1:]) # bcdefg\rprint(str[:5]) # abcde\rprint(str[1:5]) # bcde\rprint(str[-4:]) # defg\rprint(str[-2:-6]) # 空字符串 是 '' 不是None\rprint(str[-6:-2]) #bcde\rprint(str[::-1]) # 字符串反转 gfedcba\rprint(str[:2]) # ab\rprint(str[:-5]) # ab 列表 笔者按： 和Java中的数组特点一样； 最大最大的区别是 一个数组可以有不同类型的元素；\n换句话说： 一个数组中可以同时存在 数字，字符串。\nlist1 = ['Google', 'baidu', 1997, 2000] 删除方法\ndel list[1] 添加方法\nlist.append('red') 【思考】如何预创建一个容量为n的列表？\n📝 注意事项\nPython 列表是动态数组，不需要像 C++ 的 vector 或 Java 的 ArrayList 那样“预分配容量”来提高性能。 如果你只是想创建一个将来要存 n 个元素的列表，直接使用空列表即可： python深色版本\nlst = [] 然后通过 append() 添加元素即可。\n如果非要创建呢？\nlst = [None] * 6\rprint(lst) # 输出: [None, None, None, None, None, None] 元组 和列表功能类似，区别有两个\n元祖不可变： 不可变指：元素数量和值在定义之后都不允许发生变化\n元祖用 () ; 列表用 [] .\ntup = (1, 2, 3, 4, 5 )\rprint(tup) # (1, 2, 3, 4, 5)\r#tup[0] = 15\r#print(tup) # TypeError: 'tuple' object does not support item assignment\r#tup.append(6)\r#print(tup) # AttributeError: 'tuple' object has no attribute 'append' 集合 使用方式:注意是 {}\n特点有三：\n可变 无序 元素唯一 （不重复） 和Java的Set的特点相似，在Python中也叫Set;\n元素唯一的特性常常用来去重\nfruits = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\rprint(fruits) # 这⾥演示的是去重功能 {'pear', 'orange', 'banana', 'apple'}\rprint( 'orange' in fruits) # 快速判断元素是否在集合内 True\rprint( 'crabgrass' in fruits) # False 字典 字典就是KV；可以依据key，查询value\n在Java中就是Map; put的方式不一样\n字典的初始化、进和出 示例如下:\nzhangsan={\r\"name\":\"zhangsan\",\r\"age\":\"17\",\r\"height\":\"180\",\r\"weight\":\"80kg\"\r}\r#给字典添加元素\rzhangsan[\"city\"]=\"BeiJing\"\r#获取字典的元素\rprint(zhangsan.get(\"age\")) 数据类型的判断和转换 link判断 linktype(变量)\n常规的判断就不展示了，展示一些有悖常规的。\n\u003e\u003e\u003e type([1,2,3])\r"
            }
        );
    index.add(
            {
                id:  2 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/01---%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E7%AA%81%E7%A0%B4%E6%88%90%E4%B8%BApython%E9%AB%98%E6%89%8B\/",
                title: "01-如何逐步突破，成为Python高手",
                description: "你好，我是景霄��?\n工作中，我总听到很多程序员抱怨，说现在的计算机编程语言太多了，学不过来了。一些人Java用了很多年，但是最近的项目突然需要用Python，就会不知所措，压力很大��?\n众所周知，Facebook的主流语言是Hack（PHP的进化版本）。不过，我敢拍着胸脯说，就刚入职的工程师而言��?00个里至少��?5个，以前都从未用过Hack或者PHP。但是，这些人上手都特别快，基本上一两周后，日常编程便毫无压力了��?\n他们是怎么做到的呢��?\n事实上，他们遵循的，正是我在开篇词中提到的方法，也是本专栏学习的中心观点：“从工程的角度去学习Python”。那么具体来说，到底要怎么学，学习的过程中又要特别注意哪些地方呢？\n不同语言，需融会贯��? link其实，如果你在学一门语言的时候多阅读、多练习、多思考，你就会发现，不同语言都是类似的。编程语言本就是人类控制计算机的指令，语法规则等方面自然大同小异��?\n而在原有基础上，学习一门新的编程语言，其实也没有那么难，你首先要做到的是明确区分。比如，在学习Python的条件与循环语句时，多回忆一下其他语言的语法是怎样的。再如，遇到Python中的字符串相加时，你能分析出它的复杂度吗？再联想到其他语言，比如Java中字符串相加的复杂度，它们之间有什么相同点、又有什么区别呢��?\n除了能够明确区分语言的不同点，我们还要能联系起来灵活运用。比如，最典型的“编程语言两问”：\n你了解你学过的每种编程语言的特点吗��? 你能根据不同的产品需求，选用合适的编程语言吗？ 举个例子，Python的优点之一是特别擅长数据分析，所以广泛应用于人工智能、机器学习等领域，如机器学习中TensorFlow的框架，就是用Python写的。但是涉及到底层的矩阵运算等等，还是要依赖于C++完成，因为C++的速度快，运行效率更高��?\n事实上，很多公司都是这样，服务器端开发基于Python，但底层的基础架构依赖于C++。这就是典型的“不同需求选用不同语言”。毕竟，你要明白，哪怕只是几十到几百毫秒的速度差距，对于公司、对于用户体验来说都是决定性的��?\n唯一语言，可循序渐进 link当然，如果Python是你学的第一门编程语言，那也不必担心。我们知道，虽然同为人机交互的桥梁，Python语言比起C++、Java等主流语言，语法更简洁，也更接近英语，对编程世界的新人还是很友好的，这也是其显著优点。这种情况下，你要做的就是专注于Python这一门语言，明确学习的重点，把握好节奏循序渐进地学习��?\n根据我多年的学习工作经验，我把编程语言的学习重点，总结成了下面这三步，无论你是否有其他语言的基础，都可以对照来做，稳步进阶��?\n第一步：大厦之基，勤加练��? link任何一门编程语言，其覆盖范围都是相当广泛的，从基本的变量赋值、条件循环，到并发编程、Web开发等等，我想市面上几乎没有任何一本书能够罗列完全��?\n所以，我建议你，在掌握必要的基础时，就得多上手操作了。千万不要等到把教材上所有东西都学完了才开始，因为到那时候你会发现，前面好不容易记住的一堆东西似乎又忘记了。计算机科学是一门十分讲究实战的学科，因此越早上手练习，练得越多越勤，就越好��?\n不过，到底什么叫做必要的基础呢？以Python为例，如果你能够理解变量间的赋值、基本的数据类型、条件与循环语句、函数的用法，那么你就达到了第一步的底线标准，应该开始在课下多多练习了��?\n比方说，你可以自己动手编程做一个简易的计算器，这应该也是大多数程序员实操的第一个小项目。用户输入数字和运算符后，你的程序能够检查输入是否合法并且返回正确的结果吗？\n在做这个小项目的过程中，你可能会遇到不少问题。我的建议是，遇到不懂的问题时，多去Stack Overflow上查询，这样你还能阅读别人优秀的代码，借鉴别人的思路，对于你的学习肯定大有帮助。当然，实在解决不了的问题，也可以写在留言区，我们一起来解决��?\n",
                content: "你好，我是景霄��?\n工作中，我总听到很多程序员抱怨，说现在的计算机编程语言太多了，学不过来了。一些人Java用了很多年，但是最近的项目突然需要用Python，就会不知所措，压力很大��?\n众所周知，Facebook的主流语言是Hack（PHP的进化版本）。不过，我敢拍着胸脯说，就刚入职的工程师而言��?00个里至少��?5个，以前都从未用过Hack或者PHP。但是，这些人上手都特别快，基本上一两周后，日常编程便毫无压力了��?\n他们是怎么做到的呢��?\n事实上，他们遵循的，正是我在开篇词中提到的方法，也是本专栏学习的中心观点：“从工程的角度去学习Python”。那么具体来说，到底要怎么学，学习的过程中又要特别注意哪些地方呢？\n不同语言，需融会贯��? link其实，如果你在学一门语言的时候多阅读、多练习、多思考，你就会发现，不同语言都是类似的。编程语言本就是人类控制计算机的指令，语法规则等方面自然大同小异��?\n而在原有基础上，学习一门新的编程语言，其实也没有那么难，你首先要做到的是明确区分。比如，在学习Python的条件与循环语句时，多回忆一下其他语言的语法是怎样的。再如，遇到Python中的字符串相加时，你能分析出它的复杂度吗？再联想到其他语言，比如Java中字符串相加的复杂度，它们之间有什么相同点、又有什么区别呢��?\n除了能够明确区分语言的不同点，我们还要能联系起来灵活运用。比如，最典型的“编程语言两问”：\n你了解你学过的每种编程语言的特点吗��? 你能根据不同的产品需求，选用合适的编程语言吗？ 举个例子，Python的优点之一是特别擅长数据分析，所以广泛应用于人工智能、机器学习等领域，如机器学习中TensorFlow的框架，就是用Python写的。但是涉及到底层的矩阵运算等等，还是要依赖于C++完成，因为C++的速度快，运行效率更高��?\n事实上，很多公司都是这样，服务器端开发基于Python，但底层的基础架构依赖于C++。这就是典型的“不同需求选用不同语言”。毕竟，你要明白，哪怕只是几十到几百毫秒的速度差距，对于公司、对于用户体验来说都是决定性的��?\n唯一语言，可循序渐进 link当然，如果Python是你学的第一门编程语言，那也不必担心。我们知道，虽然同为人机交互的桥梁，Python语言比起C++、Java等主流语言，语法更简洁，也更接近英语，对编程世界的新人还是很友好的，这也是其显著优点。这种情况下，你要做的就是专注于Python这一门语言，明确学习的重点，把握好节奏循序渐进地学习��?\n根据我多年的学习工作经验，我把编程语言的学习重点，总结成了下面这三步，无论你是否有其他语言的基础，都可以对照来做，稳步进阶��?\n第一步：大厦之基，勤加练��? link任何一门编程语言，其覆盖范围都是相当广泛的，从基本的变量赋值、条件循环，到并发编程、Web开发等等，我想市面上几乎没有任何一本书能够罗列完全��?\n所以，我建议你，在掌握必要的基础时，就得多上手操作了。千万不要等到把教材上所有东西都学完了才开始，因为到那时候你会发现，前面好不容易记住的一堆东西似乎又忘记了。计算机科学是一门十分讲究实战的学科，因此越早上手练习，练得越多越勤，就越好��?\n不过，到底什么叫做必要的基础呢？以Python为例，如果你能够理解变量间的赋值、基本的数据类型、条件与循环语句、函数的用法，那么你就达到了第一步的底线标准，应该开始在课下多多练习了��?\n比方说，你可以自己动手编程做一个简易的计算器，这应该也是大多数程序员实操的第一个小项目。用户输入数字和运算符后，你的程序能够检查输入是否合法并且返回正确的结果吗？\n在做这个小项目的过程中，你可能会遇到不少问题。我的建议是，遇到不懂的问题时，多去Stack Overflow上查询，这样你还能阅读别人优秀的代码，借鉴别人的思路，对于你的学习肯定大有帮助。当然，实在解决不了的问题，也可以写在留言区，我们一起来解决��?\n第二步：代码规范，必不可��? link诚然，学习编程讲究快和高效。但是，与此同时，请一定不要忽略每一种语言必要的编程规范。在你自己刚开始写代码练习时，你可以不写单元测试，但总不能几百行的代码却没有一个函数，而是从头顺序写到尾吧？你可以省略一些可有可无的注释，但总不能把很多行代码全部并到一行吧��?\n比如，我们来看下面这行代码：\nv.A(param1, param2, param3).B(param4, param5).C(param6, param7).D() 显然，这样写十分不科学，应该把它拆分成多行：\nv.A(param1, param2, param3) \\ # 字符'\\'表示换行\r.B(param4, param5) \\\r.C(param6, param7) \\\r.D() 再比如，变量和函数的命名虽有一定的随意性，但一定要有意义。如果你图省事，直接把变量依次命名为v1、v2、v3等，把函数依次命名为func1、func2、func3等等，不仅让其他人难理解，就算是你自己，日后维护起来都费劲儿��?\n一名优秀的程序员，一定遵守编程语言的代码规范。像Facebook的工程师，每次写完代码都必须经过别人的review才能提交。如果有不遵守代码规范的例子，哪怕只是一个函数或是一个变量的命名，我们都会要求原作者加以修改，严格规范才能保证代码库的代码质量��?\n第三步：开发经验，质的突破 link想要真正熟练地掌握Python或者是任何一门其他的编程语言，拥有大中型产品的开发经验是必不可少的。因为实战经验才能让你站得更高，望得更远��?\n比如我们每天都在用搜索引擎，但你了解一个搜索引擎的服务器端实现吗？这是一个典型的面向对象设计，你需要定义一系列相关的类和函数，需要从产品需求、代码复杂度、效率以及可读性等多个方面考虑，同时，上线后还要进行各种优化等等��?\n当然，在专栏里我没办法让你完成一个上亿用户级的实践产品，但是我会把自己这些年的开发经验倾囊相授，并通过量化交易这个实战案例，带你踏入“高级战场”，帮你掌握必要的开发知识��?\n最后，我专门为你绘制了一张Python学习的知识图谱，里面涵盖了Python最高频的核心知识，大部分内容我在专栏中都会讲到。你可以保存或者打印出来，作为学习参考��?\n今天，我跟你分享了Python的学习方法和注意事项，其实这些观点不只适用于Python，也能帮助你学习任何一门其他计算机编程语言，希望你能牢记在心。在接下来的课程里，我会带你逐步突破，最终成为一名Python高手��?\n那么，对于学习Python或者是其他编程语言，你有什么困扰或是心得吗？欢迎在留言区与我交流！\n"
            }
        );
    index.add(
            {
                id:  3 ,
                href: "\/docs\/python\/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84\/",
                title: "Python中的集合",
                description: "一、列表和元组 link共同点 link 任意数据类型的有序集合\n都⽀持负数索引\n都⽀持切⽚操作\n可以随意嵌套（其实就是任意数据类型的一种表现）\n通过list()和tuple()函数相互转换\n不同点 link 列表 元组 动态 静态 list.reverse() 倒转列表list.sort() 排序 没有内置的这两个函数 存储空间可变包含以下内容：- 指针- 已分配内容- 元素内容 存储空间固定 各有千秋 link 占用空间 集合元素少，空间差异可忽略；\n集合元素数量级大，空间差异明显 ，列表空间明显大于元组；\n可用作选择 列表和元组的参考因素\n性能 元组性能略优\n原因如下：\npython优化静态数据-\u003e资源缓存；\n元组属于静态数据，会被缓存，资源重复利用率高；\n在初始化方面，元组性能高于列表；\n二、字典和集合 link",
                content: "一、列表和元组 link共同点 link 任意数据类型的有序集合\n都⽀持负数索引\n都⽀持切⽚操作\n可以随意嵌套（其实就是任意数据类型的一种表现）\n通过list()和tuple()函数相互转换\n不同点 link 列表 元组 动态 静态 list.reverse() 倒转列表list.sort() 排序 没有内置的这两个函数 存储空间可变包含以下内容：- 指针- 已分配内容- 元素内容 存储空间固定 各有千秋 link 占用空间 集合元素少，空间差异可忽略；\n集合元素数量级大，空间差异明显 ，列表空间明显大于元组；\n可用作选择 列表和元组的参考因素\n性能 元组性能略优\n原因如下：\npython优化静态数据-\u003e资源缓存；\n元组属于静态数据，会被缓存，资源重复利用率高；\n在初始化方面，元组性能高于列表；\n二、字典和集合 link"
            }
        );
    index.add(
            {
                id:  4 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/03---%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E5%88%B0%E5%BA%95%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA\/",
                title: "03-列表和元组，到底用哪一个？",
                description: "你好，我是景霄��?\n前面的课程，我们讲解了Python语言的学习方法，并且带你了解了Python必知的常用工具——Jupyter。那么从这节课开始，我们将正式学习Python的具体知识��?\n对于每一门编程语言来说，数据结构都是其根基。了解掌握Python的基本数据结构，对于学好这门语言至关重要。今天我们就一起来学习，Python中最常见的两种数据结构：列表（list）和元组（tuple）��?\n列表和元组基础 link首先，我们需要弄清楚最基本的概念，什么是列表和元组呢��?\n实际上，列表和元组，都是一个可以放置任意数据类型的有序集合��?\n在绝大多数编程语言中，集合的数据类型必须一致。不过，对于Python的列表和元组来说，并无此要求��?\nl = [1, 2, 'hello', 'world'] # 列表中同时含有int和string类型的元��?\rl\r[1, 2, 'hello', 'world']\rtup = ('jason', 22) # 元组中同时含有int和string类型的元��?\rtup\r('jason', 22) 其次，我们必须掌握它们的区别��?\n列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）��? 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）��? 下面的例子中，我们分别创建了一个列表与元组。你可以看到，对于列表，我们可以很轻松地让其最后一个元素，��?变为40；但是，如果你对元组采取相同的操作，Python 就会报错，原因就是元组是不可变的��?\nl = [1, 2, 3, 4]\rl[3] = 40 # 和很多语言类似，python中索引同样从0开始，l[3]表示访问列表的第四个元素\rl\r[1, 2, 3, 40]\rtup = (1, 2, 3, 4)\rtup[3] = 40\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: 'tuple' object does not support item assignment 可是，如果你想对已有的元组做任何\"改变\"，该怎么办呢？那就只能重新开辟一块内存，创建新的元组了��?\n",
                content: "你好，我是景霄��?\n前面的课程，我们讲解了Python语言的学习方法，并且带你了解了Python必知的常用工具——Jupyter。那么从这节课开始，我们将正式学习Python的具体知识��?\n对于每一门编程语言来说，数据结构都是其根基。了解掌握Python的基本数据结构，对于学好这门语言至关重要。今天我们就一起来学习，Python中最常见的两种数据结构：列表（list）和元组（tuple）��?\n列表和元组基础 link首先，我们需要弄清楚最基本的概念，什么是列表和元组呢��?\n实际上，列表和元组，都是一个可以放置任意数据类型的有序集合��?\n在绝大多数编程语言中，集合的数据类型必须一致。不过，对于Python的列表和元组来说，并无此要求��?\nl = [1, 2, 'hello', 'world'] # 列表中同时含有int和string类型的元��?\rl\r[1, 2, 'hello', 'world']\rtup = ('jason', 22) # 元组中同时含有int和string类型的元��?\rtup\r('jason', 22) 其次，我们必须掌握它们的区别��?\n列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）��? 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）��? 下面的例子中，我们分别创建了一个列表与元组。你可以看到，对于列表，我们可以很轻松地让其最后一个元素，��?变为40；但是，如果你对元组采取相同的操作，Python 就会报错，原因就是元组是不可变的��?\nl = [1, 2, 3, 4]\rl[3] = 40 # 和很多语言类似，python中索引同样从0开始，l[3]表示访问列表的第四个元素\rl\r[1, 2, 3, 40]\rtup = (1, 2, 3, 4)\rtup[3] = 40\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: 'tuple' object does not support item assignment 可是，如果你想对已有的元组做任何\"改变\"，该怎么办呢？那就只能重新开辟一块内存，创建新的元组了��?\n比如下面的例子，我们想增加一个元��?给元组，实际上就是创建了一个新的元组，然后把原来两个元组的值依次填充进去��?\n而对于列表来说，由于其是动态的，我们只需简单地在列表末尾，加入对应元素就可以了。如下操作后，会修改原来列表中的元素，而不会创建新的列表��?\ntup = (1, 2, 3, 4)\rnew_tup = tup + (5, ) # 创建新的元组new_tup，并依次填充原元组的��?\rnew _tup\r(1, 2, 3, 4, 5)\rl = [1, 2, 3, 4]\rl.append(5) # 添加元素5到原列表的末��?\rl\r[1, 2, 3, 4, 5] 通过上面的例子，相信你肯定掌握了列表和元组的基本概念。接下来我们来看一些列表和元组的基本操作和注意事项��?\n首先，和其他语言不同��?Python中的列表和元组都支持负数索引*��?1表示最后一个元素，-2表示倒数第二个元素，以此类推��?\nl = [1, 2, 3, 4]\rl[-1]\r4\rtup = (1, 2, 3, 4)\rtup[-1]\r4 除了基本的初始化，索引外��?列表和元组都支持切片操作*��?\nl = [1, 2, 3, 4]\rl[1:3] # 返回列表中索引从1��?的子列表\r[2, 3]\rtup = (1, 2, 3, 4)\rtup[1:3] # 返回元组中索引从1��?的子元组\r(2, 3) 另外，列表和元组��?可以随意嵌套*��?\nl = [[1, 2, 3], [4, 5]] # 列表的每一个元素也是一个列��?\rtup = ((1, 2, 3), (4, 5, 6)) # 元组的每一个元素也是一个元��? 当然，两者也可以通过list()和tuple()函数相互转换��?\nlist((1, 2, 3))\r[1, 2, 3]\rtuple([1, 2, 3])\r(1, 2, 3) 最后，我们来看一些列表和元组常用的内置函数：\nl = [3, 2, 3, 7, 8, 1]\rl.count(3) 2\rl.index(7)\r3\rl.reverse()\rl\r[1, 8, 7, 3, 2, 3]\rl.sort()\rl\r[1, 2, 3, 3, 7, 8]\rtup = (3, 2, 3, 7, 8, 1)\rtup.count(3)\r2\rtup.index(7)\r3\rlist(reversed(tup))\r[1, 8, 7, 3, 2, 3]\rsorted(tup)\r[1, 2, 3, 3, 7, 8] 这里我简单解释一下这几个函数的含义��?\ncount(item)表示统计列表/元组中item出现的次数��? index(item)表示返回列表/元组中item第一次出现的索引��? list.reverse()和list.sort()分别表示原地倒转列表和排序（注意，元组没有内置的这两个函��?��? reversed()和sorted()同样表示对列��?元组进行倒转和排序，reversed()返回一个倒转后的迭代器（上文例子使用list()函数再将其转换为列表）；sorted()返回排好序的新列表��? 列表和元组存储方式的差异 link前面说了，列表和元组最重要的区别就是，列表是动态的、可变的，而元组是静态的、不可变的。这样的差异，势必会影响两者存储方式。我们可以来看下面的例子��?\nl = [1, 2, 3]\rl.__sizeof__()\r64\rtup = (1, 2, 3)\rtup.__sizeof__()\r48 你可以看到，对列表和元组，我们放置了相同的元素，但是元组的存储空间，却比列表要少16字节。这是为什么呢��?\n事实上，由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于int型，8字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小��?字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间��?\nl = []\rl.__sizeof__() // 空列表的存储空间��?0字节\r40\rl.append(1)\rl.__sizeof__() 72 // 加入了元��?之后，列表为其分配了可以存储4个元素的空间 (72 - 40)/8 = 4\rl.append(2) l.__sizeof__()\r72 // 由于之前分配了空间，所以加入元��?，列表空间不��?\rl.append(3)\rl.__sizeof__() 72 // 同上\rl.append(4)\rl.__sizeof__() 72 // 同上\rl.append(5)\rl.__sizeof__() 104 // 加入元素5之后，列表的空间不足，所以又额外分配了可以存��?个元素的空间 上面的例子，大概描述了列表空间分配的过程。我们可以看到，为了减小每次增加/删减操作时空间分配的开销，Python每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加/删除的时间复杂度均为O(1)��?\n但是对于元组，情况就不同了。元组长度大小固定，元素不可变，所以存储空间固定��?\n看了前面的分析，你也许会觉得，这样的差异可以忽略不计。但是想象一下，如果列表和元组存储元素的个数是一亿，十亿甚至更大数量级时，你还能忽略这样的差异吗��?\n列表和元组的性能 link通过学习列表和元组存储方式的差异，我们可以得出结论：元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表��?\n另外，Python会在后台，对静态数据做一��?资源缓存*（resource caching）。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用��?\n但是对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度��?\n下面的例子，是计��?*初始��?*一个相同元素的列表和元组分别所需的时间。我们可以看到，元组的初始化速度，要比列表快5倍��?\npython3 -m timeit 'x=(1,2,3,4,5,6)'\r20000000 loops, best of 5: 9.97 nsec per loop\rpython3 -m timeit 'x=[1,2,3,4,5,6]'\r5000000 loops, best of 5: 50.1 nsec per loop 但如果是索引操作的话，两者的速度差别非常小，几乎可以忽略不计��?\npython3 -m timeit -s 'x=[1,2,3,4,5,6]' 'y=x[3]'\r10000000 loops, best of 5: 22.2 nsec per loop\rpython3 -m timeit -s 'x=(1,2,3,4,5,6)' 'y=x[3]'\r10000000 loops, best of 5: 21.9 nsec per loop 当然，如果你想要增加、删减或者改变元素，那么列表显然更优。原因你现在肯定知道了，那就是对于元组，你必须得通过新建一个元组来完成��?\n列表和元组的使用场景 link那么列表和元组到底用哪一个呢？根据上面所说的特性，我们具体情况具体分析��?\n1. 如果存储的数据和数量不变，比如你有一个函数，需要返回的是一个地点的经纬度，然后直接传给前端渲染，那么肯定选用元组更合适��?\ndef get_location():\r..... return (longitude, latitude) 2. 如果存储的数据或数量是可变的，比如社交平台上的一个日志功能，是统计一个用户在一周之内看了哪些用户的帖子，那么则用列表更合适��?\nviewer_owner_id_list = [] # 里面的每个元素记录了这个viewer一周内看过的所有owner的id\rrecords = queryDB(viewer_id) # 索引数据库，拿到某个viewer一周内的日��?\rfor record in records:\rviewer_owner_id_list.append(record.id) 总结 link关于列表和元组，我们今天聊了很多，最后一起总结一下你必须掌握的内容��?\n总的来说，列表和元组都是有序的，可以存储任意数据类型的集合，区别主要在于下面这两点��?\n列表是动态的，长度可变，可以随意的增加、删减或改变元素。列表的存储空间略大于元组，性能略逊于元组��? 元组是静态的，长度大小固定，不可以对元素进行增加、删减或者改变操作。元组相对于列表更加轻量级，性能稍优��? 思考题 link1. 想创建一个空的列表，我们可以用下面的A、B两种方式，请问它们在效率上有什么区别吗？我们应该优先考虑使用哪种呢？可以说说你的理由��?\n# 创建空列��?\r# option A\rempty_list = list()\r# option B\rempty_list = [] 2. 你在平时的学习工作中，是在什么场景下使用列表或者元组呢？欢迎留言和我分享��\n"
            }
        );
    index.add(
            {
                id:  5 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/06---python-%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA\/",
                title: "06 - Python \"黑箱\"：输入与输出",
                description: "你好，我是景霄��?\n世纪之交的论坛上曾有一句流行语：在互联网上，没人知道你是一条狗。互联网刚刚兴起时，一根网线链接到你家，信息通过这条高速线缆直达你的屏幕，你通过键盘飞速回应朋友的消息，信息再次通过网线飞入错综复杂的虚拟世界，再进入朋友家。抽象来看，一台台的电脑就是一个个黑箱，黑箱有了输入和输出，就拥有了图灵机运作的必要条件��?\nPython 程序也是一个黑箱：通过输入流将数据送达，通过输出流将处理后的数据送出，可��?Python 解释器后面藏了一个人，还是一个史莱哲林？No one cares��?\n好了废话不多说，今天我们就由浅及深讲��?Python 的输入和输出��?\n输入输出基础 link最简单直接的输入来自键盘操作，比如下面这个例子��?\nname = input('your name:')\rgender = input('you are a boy?(y/n)')\r###### 输入 ######\ryour name:Jack\ryou are a boy?\rwelcome_str = 'Welcome to the matrix {prefix} {name}.'\rwelcome_dic = {\r'prefix': 'Mr.' if gender == 'y' else 'Mrs',\r'name': name\r}\rprint('authorizing...')\rprint(welcome_str.format(**welcome_dic))\r########## 输出 ##########\rauthorizing...\rWelcome to the matrix Mr. Jack. input() 函数暂停程序运行，同时等待键盘输入；直到回车被按下，函数的参数即为提示语，输入的类型永远是字符串型（str）。注意，初学者在这里很容易犯错，下面的例子我会讲到。print() 函数则接受字符串、数字、字典、列表甚至一些自定义类的输出��?\n",
                content: "你好，我是景霄��?\n世纪之交的论坛上曾有一句流行语：在互联网上，没人知道你是一条狗。互联网刚刚兴起时，一根网线链接到你家，信息通过这条高速线缆直达你的屏幕，你通过键盘飞速回应朋友的消息，信息再次通过网线飞入错综复杂的虚拟世界，再进入朋友家。抽象来看，一台台的电脑就是一个个黑箱，黑箱有了输入和输出，就拥有了图灵机运作的必要条件��?\nPython 程序也是一个黑箱：通过输入流将数据送达，通过输出流将处理后的数据送出，可��?Python 解释器后面藏了一个人，还是一个史莱哲林？No one cares��?\n好了废话不多说，今天我们就由浅及深讲��?Python 的输入和输出��?\n输入输出基础 link最简单直接的输入来自键盘操作，比如下面这个例子��?\nname = input('your name:')\rgender = input('you are a boy?(y/n)')\r###### 输入 ######\ryour name:Jack\ryou are a boy?\rwelcome_str = 'Welcome to the matrix {prefix} {name}.'\rwelcome_dic = {\r'prefix': 'Mr.' if gender == 'y' else 'Mrs',\r'name': name\r}\rprint('authorizing...')\rprint(welcome_str.format(**welcome_dic))\r########## 输出 ##########\rauthorizing...\rWelcome to the matrix Mr. Jack. input() 函数暂停程序运行，同时等待键盘输入；直到回车被按下，函数的参数即为提示语，输入的类型永远是字符串型（str）。注意，初学者在这里很容易犯错，下面的例子我会讲到。print() 函数则接受字符串、数字、字典、列表甚至一些自定义类的输出��?\n我们再来看下面这个例子��?\na = input()\r1\rb = input()\r2\rprint('a + b = {}'.format(a + b))\r########## 输出 ##############\ra + b = 12\rprint('type of a is {}, type of b is {}'.format(type(a), type(b)))\r########## 输出 ##############\rtype of a is "
            }
        );
    index.add(
            {
                id:  6 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/08---%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7\/",
                title: "08 - 异常处理：如何提高程序的稳定性？",
                description: "你好，我是景霄��?\n今天这节课，我想和你聊聊Python的异常处理。和其他语言一样，异常处理是Python中一种很常见，并且很重要的机制与代码规范��?\n我在实际工作中，见过很多次这样的情况：一位工程师提交了代码，不过代码某处忘记了异常处理。碰巧这种异常发生的频率不低，所以在代码push到线上后没多久，就会收到紧急通知——服务器崩溃了��?\n如果事情严重，对用户的影响也很大，这位工程师还得去专门的会议上做自我检讨，可以说是很惨了。这类事件层出不穷，也告诉我们，正确理解和处理程序中的异常尤为关键��?\n*错误与异��? link首先要了解，Python中的错误和异常是什么？两者之间又有什么联系和区别呢？\n通常来说，程序中的错误至少包括两种，一种是语法错误，另一种则是异常��?\n所谓语法错误，你应该很清楚，也就是你写的代码不符合编程规范，无法被识别与执行，比如下面这个例子��?\nif name is not None\rprint(name) If语句漏掉了冒号，不符合Python的语法规范，所以程序就会报错invalid syntax��?\n而异常则是指程序的语法正确，也可以被执行，但在执行过程中遇到了错误，抛出了异常，比如下面��?个例子：\n10 / 0\rTraceback (most recent call last):\rFile \"\", line 1, in ZeroDivisionError: integer division or modulo by zero\rorder * 2\rTraceback (most recent call last):\rFile \"\", line 1, in NameError: name 'order' is not defined\r1 + [1, 2]\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: unsupported operand type(s) for +: 'int' and 'list' 它们语法完全正确，但显然，我们不能做除法时让分母��?；也不能使用未定义的变量做运算；而让一个整型和一个列表相加也是不可取的��?\n",
                content: "你好，我是景霄��?\n今天这节课，我想和你聊聊Python的异常处理。和其他语言一样，异常处理是Python中一种很常见，并且很重要的机制与代码规范��?\n我在实际工作中，见过很多次这样的情况：一位工程师提交了代码，不过代码某处忘记了异常处理。碰巧这种异常发生的频率不低，所以在代码push到线上后没多久，就会收到紧急通知——服务器崩溃了��?\n如果事情严重，对用户的影响也很大，这位工程师还得去专门的会议上做自我检讨，可以说是很惨了。这类事件层出不穷，也告诉我们，正确理解和处理程序中的异常尤为关键��?\n*错误与异��? link首先要了解，Python中的错误和异常是什么？两者之间又有什么联系和区别呢？\n通常来说，程序中的错误至少包括两种，一种是语法错误，另一种则是异常��?\n所谓语法错误，你应该很清楚，也就是你写的代码不符合编程规范，无法被识别与执行，比如下面这个例子��?\nif name is not None\rprint(name) If语句漏掉了冒号，不符合Python的语法规范，所以程序就会报错invalid syntax��?\n而异常则是指程序的语法正确，也可以被执行，但在执行过程中遇到了错误，抛出了异常，比如下面��?个例子：\n10 / 0\rTraceback (most recent call last):\rFile \"\", line 1, in ZeroDivisionError: integer division or modulo by zero\rorder * 2\rTraceback (most recent call last):\rFile \"\", line 1, in NameError: name 'order' is not defined\r1 + [1, 2]\rTraceback (most recent call last):\rFile \"\", line 1, in TypeError: unsupported operand type(s) for +: 'int' and 'list' 它们语法完全正确，但显然，我们不能做除法时让分母��?；也不能使用未定义的变量做运算；而让一个整型和一个列表相加也是不可取的��?\n于是，当程序运行到这些地方时，就抛出了异常，并且终止运行。例子中的ZeroDivisionError NameError和TypeError，就是三种常见的异常类型��?\n当然，Python中还有很多其他异常类型，比如KeyError是指字典中的键找不到；FileNotFoundError是指发送了读取文件的请求，但相应的文件不存在等等，我在此不一一赘述，你可以自行参考相应文档��?\n如何处理异常 link刚刚讲到，如果执行到程序中某处抛出了异常，程序就会被终止并退出。你可能会问，那有没有什么办法可以不终止程序，让其照样运行下去呢？答案当然是肯定的，这也就是我们所说的异常处理，通常使用try和except来解决，比如��?\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r... except ValueError as err:\rprint('Value Error: {}'.format(err))\rprint('continue')\r... 这里默认用户输入以逗号相隔的两个整形数字，将其提取后，做后续的操作（注意input函数会将输入转换为字符串类型）。如果我们输入a,b，程序便会抛出异常invalid literal for int() with base 10: 'a'，然后跳出try这个block��?\n由于程序抛出的异常类型是ValueError，和except block所catch的异常类型相匹配，所以except block便会被执行，最终输出Value Error: invalid literal for int() with base 10: 'a'，并打印出continue��?\nplease enter two numbers separated by comma: a,b\rValue Error: invalid literal for int() with base 10: 'a'\rcontinue 我们知道，except block只接受与它相匹配的异常类型并执行，如果程序抛出的异常并不匹配，那么程序照样会终止并退出��?\n所以，还是刚刚这个例子，如果我们只输入1，程序抛出的异常就是IndexError: list index out of range，与ValueError不匹配，那么except block就不会被执行，程序便会终止并退出（continue不会被打印）��?\nplease enter two numbers separated by comma: 1\rIndexError Traceback (most recent call last)\rIndexError: list index out of range 不过，很显然，这样强调一种类型的写法有很大的局限性。那么，该怎么解决这个问题呢？\n其中一种解决方案，是在except block中加入多种异常的类型，比如下面这样的写法��?\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r...\rexcept (ValueError, IndexError) as err:\rprint('Error: {}'.format(err))\rprint('continue')\r... 或者第二种写法��?\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r...\rexcept ValueError as err:\rprint('Value Error: {}'.format(err))\rexcept IndexError as err:\rprint('Index Error: {}'.format(err))\rprint('continue')\r... 这样，每次程序执行时，except block中只要有一个exception类型与实际匹配即可��?\n不过，很多时候，我们很难保证程序覆盖所有的异常类型，所以，更通常的做法，是在最后一个except block，声明其处理的异常类型是Exception。Exception是其他所有非系统异常的基类，能够匹配任意非系统异常。那么这段代码就可以写成下面这样��?\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r...\rexcept ValueError as err:\rprint('Value Error: {}'.format(err))\rexcept IndexError as err:\rprint('Index Error: {}'.format(err))\rexcept Exception as err:\rprint('Other error: {}'.format(err))\rprint('continue')\r... 或者，你也可以在except后面省略异常类型，这表示与任意异常相匹配（包括系统异常等）：\ntry:\rs = input('please enter two numbers separated by comma: ')\rnum1 = int(s.split(',')[0].strip())\rnum2 = int(s.split(',')[1].strip())\r...\rexcept ValueError as err:\rprint('Value Error: {}'.format(err))\rexcept IndexError as err:\rprint('Index Error: {}'.format(err))\rexcept:\rprint('Other error')\rprint('continue')\r... 需要注意，当程序中存在多个except block时，最多只有一个except block会被执行。换句话说，如果多个except声明的异常类型都与实际相匹配，那么只有最前面的except block会被执行，其他则被忽略��?\n异常处理中，还有一个很常见的用法是finally，经常和try、except放在一起来用。无论发生什么情况，finally block中的语句都会被执行，哪怕前面的try和excep block中使用了return语句��?\n一个常见的应用场景，便是文件的读取��?\nimport sys\rtry:\rf = open('file.txt', 'r')\r.... # some data processing\rexcept OSError as err:\rprint('OS error: {}'.format(err))\rexcept:\rprint('Unexpected error:', sys.exc_info()[0])\rfinally:\rf.close() 这段代码中，try block尝试读取file.txt这个文件，并对其中的数据进行一系列的处理，到最后，无论是读取成功还是读取失败，程序都会执行finally中的语句——关闭这个文件流，确保文件的完整性。因此，在finally中，我们通常会放一��?*无论如何都要执行**的语句��?\n值得一提的是，对于文件的读取，我们也常常使用with open，你也许在前面的例子中已经看到过，with open会在最后自动关闭文件，让语句更加简洁��?\n*用户自定义异��? link前面的例子里充斥了很多Python内置的异常类型，你可能会问，我可以创建自己的异常类型吗？\n答案是肯定是，Python当然允许我们这么做。下面这个例子，我们创建了自定义的异常类型MyInputError，定义并实现了初始化函数和str函数（直接print时调用）��?\nclass MyInputError(Exception):\r\"\"\"Exception raised when there're errors in input\"\"\"\rdef __init__(self, value): # 自定义异常类型的初始��?\rself.value = value\rdef __str__(self): # 自定义异常类型的string表达形式\rreturn (\"{} is invalid input\".format(repr(self.value)))\rtry:\rraise MyInputError(1) # 抛出MyInputError这个异常\rexcept MyInputError as err:\rprint('error: {}'.format(err)) 如果你执行上述代码块并输出，便会得到下面的结果：\nerror: 1 is invalid input 实际工作中，如果内置的异常类型无法满足我们的需求，或者为了让异常更加详细、可读，想增加一些异常类型的其他功能，我们可以自定义所需异常类型。不过，大多数情况下，Python内置的异常类型就足够好了��?\n*异常的使用场景与注意��? link学完了前面的基础知识，接下来我们着重谈一下，异常的使用场景与注意点��?\n通常来说，在程序中，如果我们不确定某段代码能否成功执行，往往这个地方就需要使用异常处理。除了上述文件读取的例子，我可以再举一个例子来说明��?\n大型社交网站的后台，需要针对用户发送的请求返回相应记录。用户记录往往储存在key-value结构的数据库中，每次有请求过来后，我们拿到用户的ID，并用ID查询数据库中此人的记录，就能返回相应的结果��?\n而数据库返回的原始数据，往往是json string的形式，这就需要我们首先对json string进行decode（解码），你可能很容易想到下面的方法��?\nimport json\rraw_data = queryDB(uid) # 根据用户的id，返回相应的信息\rdata = json.loads(raw_data) 这样的代码是不是就足够了呢？\n要知道，在json.loads()函数中，输入的字符串如果不符合其规范，那么便无法解码，就会抛出异常，因此加上异常处理十分必要��?\ntry:\rdata = json.loads(raw_data)\r....\rexcept JSONDecodeError as err:\rprint('JSONDecodeError: {}'.format(err)) 不过，有一点切记，我们不能走向另一个极端——滥用异常处理��?\n比如，当你想要查找字典中某个键对应的值时，绝不能写成下面这种形式��?\nd = {'name': 'jason', 'age': 20}\rtry:\rvalue = d['dob']\r...\rexcept KeyError as err:\rprint('KeyError: {}'.format(err)) 诚然，这样的代码并没有bug，但是让人看了摸不着头脑，也显得很冗余。如果你的代码中充斥着这种写法，无疑对阅读、协作来说都是障碍。因此，对于flow-control（流程控制）的代码逻辑，我们一般不用异常处理��?\n字典这个例子，写成下面这样就很好��?\nif 'dob' in d:\rvalue = d['dob']\r... 总结 link这节课， 我们一起学习了Python的异常处理及其使用场景，你需要重点掌握下面几点��?\n异常，通常是指程序运行的过程中遇到了错误，终止并退出。我们通常使用try except语句去处理异常，这样程序就不会被终止，仍能继续执行��? 处理异常时，如果有必须执行的语句，比如文件打开后必须关闭等等，则可以放在finally block中��? 异常处理，通常用在你不确定某段代码能否成功执行，也无法轻易判断的情况下，比如数据库的连接、读取等等。正常的flow-control逻辑，不要使用异常处理，直接用条件语句解决就可以了��? 思考题 link最后，给你留一个思考题。在异常处理时，如果try block中有多处抛出异常，需要我们使用多个try except block吗？以数据库的连接、读取为例，下面两种写法，你觉得哪种更好呢？\n第一种：\ntry:\rdb = DB.connect('') # 可能会抛出异��?\rraw_data = DB.queryData('') # 可能会抛出异��?\rexcept (DBConnectionError, DBQueryDataError) err:\rprint('Error: {}'.format(err)) 第二种：\ntry:\rdb = DB.connect('') # 可能会抛出异��?\rtry:\rraw_data = DB.queryData('')\rexcept DBQueryDataError as err:\rprint('DB query data error: {}'.format(err))\rexcept DBConnectionError as err:\rprint('DB connection error: {}'.format(err)) 欢迎在留言区写下你的答案，还有你今天学习的心得和疑惑，也欢迎你把这篇文章分享给你的同事、朋友��?\nprint(e) # NameError: name 'e' is not defined 这里为什么会显示e没有被定义呢��?/p\u003e2019-05-27Hoo-Ah 👍��?5��?💬��?��?p\u003e第一种写法更加简洁，易于阅读。而且except后面的错误类型先抛出数据库连接错误，之后才抛出查询错误，实现的异常处理和第二种一样��?/p\u003e2019-05-27liput 👍��?7��?💬��?��?p\u003e想请问老师，在facebook里面开发，对于异常处理有什么规范需要遵循吗？自定义异常、抛异常、捕获异常，粒度一般怎么把控呢？ 与此相应的，我对日志输出也有同样的疑问，希望老师能结合您在大公司里的实战经验多讲讲��?/p\u003e2019-05-27John Si 👍��?��?💬��?��?p\u003e1. 第一種寫法比第二種寫法簡��? 2. 因我對try語法執行流程不太清楚，還是老師跟熟悉該同學多講解一下。但我自己想法是第二種寫法跟巢狀迴圈寫法很像，假設是第二句語法發生錯誤，第二種寫法會多執行一次try 語句，從而增加了程序運行時間��?\n綜上所述，我認為第一種寫法較第二種好2019-05-27小豹��?/span\u003e 👍��?��?💬��?��?p\u003e老师，系统异常，非系统异常能举个例子说明下吗��?/p\u003e2019-05-27Kevin 👍��?��?💬��?��?p\u003e从代码行数看第一种更简洁，第一种中，使用了一个try..expect将异常统一处理，代码简洁， 第二种，代码中有嵌套��?/p\u003e2020-06-17王大��?/span\u003e 👍��?��?💬��?��?p\u003e第一种和第二种效果类似， 都是先检查数据库连接异常，再检查query执行的异常��?\n更喜欢这种写法： try: db = DB.connect('') # 可能会抛出异��? raw_data = DB.queryData('') # 可能会抛出异��? except DBConnectionError as err: print('ConnectionError: {}'.format(err)) except DBQueryDataError as err: print('QueryDataError: {}'.format(err))2020-02-02一��?/span\u003e 👍��?��?💬��?��?p\u003e老师，什么样的代码才是您说的“flow-control��?/p\u003e2020-01-02Geek_David 👍��?��?💬��?��?p\u003e个人觉得这个课还要加上一本python的书，那就天衣无缝了2020-03-29百年 👍��?��?💬��?��?p\u003e老师的课收获比较大，Python基础课也学过，Python核心机制也学过一点，但是一写代码，特别是实时读写文件，总是报一大堆错误，这结课真的是运用上了��?/p\u003e2019-05-29Blackwang 👍��?��?💬��?��?p\u003e第一种更好，不过理由说不上来…��? 另外老师，请问前几天思考题的答案有吗？之前说周末放 github 的？2019-05-27Robert小七 👍��?��?💬��?��?p\u003e为什么不直接用except Exception as err?2019-05-27栾~龟虽寿！ 👍��?��?💬��?��?p\u003e老师，课越听越觉得值，可是大家如何在手机上写代码的？不会是电脑上写好，利用微信，转发给自己手机上，再复制粘贴到留言吧？还有我有些着急，是否能一天播放两课，哈哈，我有基础��?/p\u003e2019-05-27mickle 👍��?��?💬��?��?p\u003e我在开发中用第一种吧，第二种代码冗余，看着难受2019-05-27Geek_b6f316 👍��?5��?💬��?��?p\u003e第一种方法简单明了，是不是少了一个as2019-05-27\n"
            }
        );
    index.add(
            {
                id:  7 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/09---%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0\/",
                title: "09 - 不可或缺的自定义函数",
                description: "你好，我是景霄��?\n实际工作生活中，我曾见到不少初学者编写的Python程序，他们长达几百行的代码中，却没有一个函数，通通按顺序堆到一块儿，不仅让人读起来费时费力，往往也是错误连连��?\n一个规范的值得借鉴的Python程序，除非代码量很少（比��?0行��?0行以下），基本都应该由多个函数组成，这样的代码才更加模块化、规范化��?\n函数是Python程序中不可或缺的一部分。事实上，在前面的学习中，我们已经用到了很多Python的内置函数，比如sorted()表示对一个集合序列排序，len()表示返回一个集合序列的长度大小等等。这节课，我们主要来学习Python的自定义函数��?\n函数基础 link那么，到底什么是函数，如何在Python程序中定义函数呢��?\n说白了，函数就是为了实现某一功能的代码段，只要写好以后，就可以重复利用。我们先来看下面一个简单的例子:\ndef my_func(message):\rprint('Got a message: {}'.format(message))\r# 调用函数 my_func()\rmy_func('Hello World')\r# 输出\rGot a message: Hello World 其中��?\ndef是函数的声明��? my_func是函数的名称��? 括号里面的message则是函数的参数； 而print那行则是函数的主体部分，可以执行相应的语句； 在函数最后，你可以返回调用结果（return或yield），也可以不返回��? 总结一下，大概是下面的这种形式��?\ndef name(param1, param2, ..., paramN):\rstatements\rreturn/yield value # optional 和其他需要编译的语言（比如C语言）不一样的是，def是可执行语句，这意味着函数直到被调用前，都是不存在的。当程序调用函数时，def语句才会创建一个新的函数对象，并赋予其名字��?\n我们一起来看几个例子，加深你对函数的印象：\ndef my_sum(a, b):\rreturn a + b\rresult = my_sum(3, 5)\rprint(result)\r# 输出\r8 这里，我们定义了my_sum()这个函数，它有两个参数a和b，作用是相加；随后，调用my_sum()函数，分别把3��?赋于a和b；最后，返回其相加的值，赋于变量result，并输出得到8��?\n",
                content: "你好，我是景霄��?\n实际工作生活中，我曾见到不少初学者编写的Python程序，他们长达几百行的代码中，却没有一个函数，通通按顺序堆到一块儿，不仅让人读起来费时费力，往往也是错误连连��?\n一个规范的值得借鉴的Python程序，除非代码量很少（比��?0行��?0行以下），基本都应该由多个函数组成，这样的代码才更加模块化、规范化��?\n函数是Python程序中不可或缺的一部分。事实上，在前面的学习中，我们已经用到了很多Python的内置函数，比如sorted()表示对一个集合序列排序，len()表示返回一个集合序列的长度大小等等。这节课，我们主要来学习Python的自定义函数��?\n函数基础 link那么，到底什么是函数，如何在Python程序中定义函数呢��?\n说白了，函数就是为了实现某一功能的代码段，只要写好以后，就可以重复利用。我们先来看下面一个简单的例子:\ndef my_func(message):\rprint('Got a message: {}'.format(message))\r# 调用函数 my_func()\rmy_func('Hello World')\r# 输出\rGot a message: Hello World 其中��?\ndef是函数的声明��? my_func是函数的名称��? 括号里面的message则是函数的参数； 而print那行则是函数的主体部分，可以执行相应的语句； 在函数最后，你可以返回调用结果（return或yield），也可以不返回��? 总结一下，大概是下面的这种形式��?\ndef name(param1, param2, ..., paramN):\rstatements\rreturn/yield value # optional 和其他需要编译的语言（比如C语言）不一样的是，def是可执行语句，这意味着函数直到被调用前，都是不存在的。当程序调用函数时，def语句才会创建一个新的函数对象，并赋予其名字��?\n我们一起来看几个例子，加深你对函数的印象：\ndef my_sum(a, b):\rreturn a + b\rresult = my_sum(3, 5)\rprint(result)\r# 输出\r8 这里，我们定义了my_sum()这个函数，它有两个参数a和b，作用是相加；随后，调用my_sum()函数，分别把3��?赋于a和b；最后，返回其相加的值，赋于变量result，并输出得到8��?\n再来看一个例子：\ndef find_largest_element(l):\rif not isinstance(l, list):\rprint('input is not type of list')\rreturn\rif len(l) == 0:\rprint('empty input')\rreturn\rlargest_element = l[0]\rfor item in l:\rif item \u003e largest_element:\rlargest_element = item\rprint('largest element is: {}'.format(largest_element)) find_largest_element([8, 1,-3, 2, 0])\r# 输出\rlargest element is: 8 这个例子中，我们定义了函数find_largest_element，作用是遍历输入的列表，找出最大的值并打印。因此，当我们调用它，并传递列��?[8, 1, -3, 2, 0] 作为参数时，程序就会输出 largest element is: 8��?\n需要注意，主程序调用函数时，必须保证这个函数此前已经定义过，不然就会报错，比如��?\nmy_func('hello world')\rdef my_func(message):\rprint('Got a message: {}'.format(message))\r# 输出\rNameError: name 'my_func' is not defined 但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为def是可执行语句，函数在调用之前都不存在，我们只需保证调用时，所需的函数都已经声明定义��?\ndef my_func(message):\rmy_sub_func(message) # 调用my_sub_func()在其声明之前不影响程序执��?\rdef my_sub_func(message):\rprint('Got a message: {}'.format(message))\rmy_func('hello world')\r# 输出\rGot a message: hello world 另外，Python函数的参数可以设定默认值，比如下面这样的写法：\ndef func(param = 0):\r... 这样，在调用函数func()时，如果参数param没有传入，则参数默认��?；而如果传入了参数param，其就会覆盖默认值��?\n前面说过，Python和其他语言相比的一大特点是，Python是dynamically typed的，可以接受任何数据类型（整型，浮点，字符串等等）。对函数参数来说，这一点同样适用。比如还是刚刚的my_sum函数，我们也可以把列表作为参数来传递，表示将两个列表相连接��?\nprint(my_sum([1, 2], [3, 4]))\r# 输出\r[1, 2, 3, 4] 同样，也可以把字符串作为参数传递，表示字符串的合并拼接��?\nprint(my_sum('hello ', 'world'))\r# 输出\rhello world 当然，如果两个参数的数据类型不同，比如一个是列表、一个是字符串，两者无法相加，那就会报错：\nprint(my_sum([1, 2], 'hello'))\rTypeError: can only concatenate list (not \"str\") to list 我们可以看到，Python不用考虑输入的数据类型，而是将其交给具体的代码去判断执行，同样的一个函数（比如这边的相加函数my_sum()），可以同时应用在整型、列表、字符串等等的操作中��?\n在编程语言中，我们把这种行为称��?多��?。这也是Python和其他语言，比如Java、C等很大的一个不同点。当然，Python这种方便的特性，在实际使用中也会带来诸多问题。因此，必要时请你在开头加上数据的类型检查��?\nPython函数的另一大特性，是Python支持函数的嵌套。所谓的函数嵌套，就是指函数里面又有函数，比如：\ndef f1():\rprint('hello')\rdef f2():\rprint('world')\rf2()\rf1()\r# 输出\rhello\rworld 这里函数f1()的内部，又定义了函数f2()。在调用函数f1()时，会先打印字符串'hello'，然后f1()内部再调用f2()，打印字符串'world'。你也许会问，为什么需要函数嵌套？这样做有什么好处呢��?\n其实，函数的嵌套，主要有下面两个方面的作用��?\n第一，函数的嵌套能够保证内部函数的隐私。内部函数只能被外部函数所调用和访问，不会暴露在全局作用域，因此，如果你的函数内部有一些隐私数据（比如数据库的用户、密码等），不想暴露在外，那你就可以使用函数的的嵌套，将其封装在内部函数中，只通过外部函数来访问。比如：\ndef connect_DB():\rdef get_DB_configuration():\r...\rreturn host, username, password\rconn = connector.connect(get_DB_configuration())\rreturn conn 这里的函数get_DB_configuration，便是内部函数，它无法在connect_DB()函数以外被单独调用。也就是说，下面这样的外部直接调用是错误的：\nget_DB_configuration()\r# 输出\rNameError: name 'get_DB_configuration' is not defined 我们只能通过调用外部函数connect_DB()来访问它，这样一来，程序的安全性便有了很大的提高��?\n第二，合理的使用函数嵌套，能够提高程序的运行效率。我们来看下面这个例子：\ndef factorial(input):\r# validation check\rif not isinstance(input, int):\rraise Exception('input must be an integer.')\rif input \u003c 0:\rraise Exception('input must be greater or equal to 0' )\r...\rdef inner_factorial(input):\rif input \u003c= 1:\rreturn 1\rreturn input * inner_factorial(input-1)\rreturn inner_factorial(input)\rprint(factorial(5)) 这里，我们使用递归的方式计算一个数的阶乘。因为在计算之前，需要检查输入是否合法，所以我写成了函数嵌套的形式，这样一来，输入是否合法就只用检查一次。而如果我们不使用函数嵌套，那么每调用一次递归便会检查一次，这是没有必要的，也会降低程序的运行效率��?\n实际工作中，如果你遇到相似的情况，输入检查不是很快，还会耗费一定的资源，那么运用函数的嵌套就十分必要了��?\n函数变量作用��? linkPython函数中变量的作用域和其他语言类似。如果变量是在函数内部定义的，就称为局部变量，只在函数内部有效。一旦函数执行完毕，局部变量就会被回收，无法访问，比如下面的例子：\ndef read_text_from_file(file_path):\rwith open(file_path) as file:\r... 我们在函数内部定义了file这个变量，这个变量只在read_text_from_file这个函数里有效，在函数外部则无法访问��?\n相对应的，全局变量则是定义在整个文件层次上的，比如下面这段代码��?\nMIN_VALUE = 1\rMAX_VALUE = 10\rdef validation_check(value):\rif value \u003c MIN_VALUE or value \u003e MAX_VALUE:\rraise Exception('validation check fails') 这里的MIN_VALUE和MAX_VALUE就是全局变量，可以在文件内的任何地方被访问，当然在函数内部也是可以的。不过，我们**不能在函数内部随意改变全局变量的��?*。比如，下面的写法就是错误的��?\nMIN_VALUE = 1\rMAX_VALUE = 10\rdef validation_check(value):\r...\rMIN_VALUE += 1\r...\rvalidation_check(5) 如果运行这段代码，程序便会报错：\nUnboundLocalError: local variable 'MIN_VALUE' referenced before assignment 这是因为，Python的解释器会默认函数内部的变量为局部变量，但是又发现局部变量MIN_VALUE并没有声明，因此就无法执行相关操作。所以，如果我们一定要在函数内部改变全局变量的值，就必须加上global这个声明��?\nMIN_VALUE = 1\rMAX_VALUE = 10\rdef validation_check(value):\rglobal MIN_VALUE\r...\rMIN_VALUE += 1\r...\rvalidation_check(5) 这里的global关键字，并不表示重新创建了一个全局变量MIN_VALUE，而是告诉Python解释器，函数内部的变量MIN_VALUE，就是之前定义的全局变量，并不是新的全局变量，也不是局部变量。这样，程序就可以在函数内部访问全局变量，并修改它的值了��?\n另外，如果遇到函数内部局部变量和全局变量同名的情况，那么在函数内部，局部变量会覆盖全局变量，比如下面这种：\nMIN_VALUE = 1\rMAX_VALUE = 10\rdef validation_check(value):\rMIN_VALUE = 3\r... 在函数validation_check()内部，我们定义了和全局变量同名的局部变量MIN_VALUE，那么，MIN_VALUE在函数内部的值，就应该是3而不��?了��?\n类似的，对于嵌套函数来说，内部函数可以访问外部函数定义的变量，但是无法修改，若要修改，必须加上nonlocal这个关键字：\ndef outer():\rx = \"local\"\rdef inner():\rnonlocal x # nonlocal关键字表示这里的x就是外部函数outer定义的变量x\rx = 'nonlocal'\rprint(\"inner:\", x)\rinner()\rprint(\"outer:\", x)\router()\r# 输出\rinner: nonlocal\router: nonlocal 如果不加上nonlocal这个关键字，而内部函数的变量又和外部函数变量同名，那么同样的，内部函数变量会覆盖外部函数的变量��?\ndef outer():\rx = \"local\"\rdef inner():\rx = 'nonlocal' # 这里的x是inner这个函数的局部变��?\rprint(\"inner:\", x)\rinner()\rprint(\"outer:\", x)\router()\r# 输出\rinner: nonlocal\router: local 闭包 link这节课的第三个重点，我想再来介绍一下闭包（closure）。闭包其实和刚刚讲的嵌套函数类似，不同的是，这里外部函数返回的是一个函数，而不是一个具体的值。返回的函数通常赋于一个变量，这个变量可以在后面被继续执行调用��?\n举个例子你就更容易理解了。比如，我们想计算一个数的n次幂，用闭包可以写成下面的代码：\ndef nth_power(exponent):\rdef exponent_of(base):\rreturn base ** exponent\rreturn exponent_of # 返回值是exponent_of函数\rsquare = nth_power(2) # 计算一个数的平��?\rcube = nth_power(3) # 计算一个数的立��?\rsquare\r# 输出\r"
            }
        );
    index.add(
            {
                id:  8 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/10---%E7%AE%80%E7%BA%A6%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\/",
                title: "10 - 简约不简单的匿名函数",
                description: "你好，我是景霄��?\n上一节，我们一起学习了Python中的“常规”函数，用途十分广泛。不过，除了常规函数，你应该也会在代码中见到一些“非常规”函数，它们往往很简短，就一行，并且有个很酷炫的名字——lambda，没错，这就是匿名函数��?\n匿名函数在实际工作中同样举足轻重，正确地运用匿名函数，能让我们的代码更简洁、易读。这节课，我们继续Python的函数之旅，一起来学习这个简约而不简单的匿名函数��?\n匿名函数基础 link首先，什么是匿名函数呢？以下是匿名函数的格式��?\nlambda argument1, argument2,... argumentN : expression 我们可以看到，匿名函数的关键字是lambda，之后是一系列的参数，然后用冒号隔开，最后则是由这些参数组成的表达式。我们通过几个例子看一下它的用法：\nsquare = lambda x: x**2\rsquare(3)\r9 这里的匿名函数只输入一个参数x，输出则是输入x的平方。因此当输入��?时，输出便是9。如果把这个匿名函数写成常规函数的形式，则是下面这样��?\ndef square(x):\rreturn x**2\rsquare(3)\r9 可以看到，匿名函数lambda和常规函数一样，返回的都是一个函数对象（function object），它们的用法也极其相似，不过还是有下面几点区别��?\n**第一，lambda是一个表达式（expression），并不是一个语句（statement��?*��?\n所谓的表达式，就是用一系列“公式”去表达一个东西，比如x + 2��?x**2等等��? 而所谓的语句，则一定是完成了某些功能，比如赋值语句x = 1完成了赋值，print语句print(x)完成了打印，条件语句 if x \u003c 0:完成了选择功能等等��? 因此，lambda可以用在一些常规函数def不能用的地方，比如，lambda可以用在列表内部，而常规函数却不能��?\n[(lambda x: x*x)(x) for x in range(10)]\r# 输出\r[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 再比如，lambda可以被用作某些函数的参数，而常规函数def也不能：\n",
                content: "你好，我是景霄��?\n上一节，我们一起学习了Python中的“常规”函数，用途十分广泛。不过，除了常规函数，你应该也会在代码中见到一些“非常规”函数，它们往往很简短，就一行，并且有个很酷炫的名字——lambda，没错，这就是匿名函数��?\n匿名函数在实际工作中同样举足轻重，正确地运用匿名函数，能让我们的代码更简洁、易读。这节课，我们继续Python的函数之旅，一起来学习这个简约而不简单的匿名函数��?\n匿名函数基础 link首先，什么是匿名函数呢？以下是匿名函数的格式��?\nlambda argument1, argument2,... argumentN : expression 我们可以看到，匿名函数的关键字是lambda，之后是一系列的参数，然后用冒号隔开，最后则是由这些参数组成的表达式。我们通过几个例子看一下它的用法：\nsquare = lambda x: x**2\rsquare(3)\r9 这里的匿名函数只输入一个参数x，输出则是输入x的平方。因此当输入��?时，输出便是9。如果把这个匿名函数写成常规函数的形式，则是下面这样��?\ndef square(x):\rreturn x**2\rsquare(3)\r9 可以看到，匿名函数lambda和常规函数一样，返回的都是一个函数对象（function object），它们的用法也极其相似，不过还是有下面几点区别��?\n**第一，lambda是一个表达式（expression），并不是一个语句（statement��?*��?\n所谓的表达式，就是用一系列“公式”去表达一个东西，比如x + 2��?x**2等等��? 而所谓的语句，则一定是完成了某些功能，比如赋值语句x = 1完成了赋值，print语句print(x)完成了打印，条件语句 if x \u003c 0:完成了选择功能等等��? 因此，lambda可以用在一些常规函数def不能用的地方，比如，lambda可以用在列表内部，而常规函数却不能��?\n[(lambda x: x*x)(x) for x in range(10)]\r# 输出\r[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 再比如，lambda可以被用作某些函数的参数，而常规函数def也不能：\nl = [(1, 20), (3, 0), (9, 10), (2, -1)]\rl.sort(key=lambda x: x[1]) # 按列表中元组的第二个元素排序\rprint(l)\r# 输出\r[(2, -1), (3, 0), (9, 10), (1, 20)] 常规函数def必须通过其函数名被调用，因此必须首先被定义。但是作为一个表达式的lambda，返回的函数对象就不需要名字了��?\n*第二，lambda的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块��?\n这其实是出于设计的考虑。Python之所以发明lambda，就是为了让它和常规函数各司其职：lambda专注于简单的任务，而常规函数则负责更复杂的多行逻辑。关于这点，Python之父Guido van Rossum曾发了一篇文章解释，你有兴趣的话可以自己阅读��?\n为什么要使用匿名函数��? link理论上来说，Python中有匿名函数的地方，都可以被替换成等价的其他表达形式。一个Python程序是可以不用任何匿名函数的。不过，在一些情况下，使用匿名函数lambda，可以帮助我们大大简化代码的复杂度，提高代码的可读性��?\n通常，我们用函数的目的无非是这么几点��?\n减少代码的重复性； 模块化代码��? 对于第一点，如果你的程序在不同地方包含了相同的代码，那么我们就会把这部分相同的代码写成一个函数，并为它取一个名字，方便在相对应的不同地方调用��?\n对于第二点，如果你的一块儿代码是为了实现一个功能，但内容非常多，写在一起降低了代码的可读性，那么通常我们也会把这部分代码单独写成一个函数，然后加以调用��?\n不过，再试想一下这样的情况。你需要一个函数，但它非常简短，只需要一行就能完成；同时它在程序中只被调用一次而已。那么请问，你还需要像常规函数一样，给它一个定义和名字吗？\n答案当然是否定的。这种情况下，函数就可以是匿名的，你只需要在适当的地方定义并使用，就能让匿名函数发挥作用了��?\n举个例子，如果你想对一个列表中的所有元素做平方操作，而这个操作在你的程序中只需要进行一次，用lambda函数可以表示成下面这样：\nsquared = map(lambda x: x**2, [1, 2, 3, 4, 5]) 如果用常规函数，则表示为这几行代码：\ndef square(x):\rreturn x**2\rsquared = map(square, [1, 2, 3, 4, 5]) 这里我简单解释一下。函数map(function, iterable)的第一个参数是函数对象，第二个参数是一个可以遍历的集合，它表示对iterable的每一个元素，都运用function这个函数。两者一对比，我们很明显地发现，lambda函数让代码更加简洁明了��?\n再举一个例子，在Python的Tkinter GUI应用中，我们想实现这样一个简单的功能：创建显示一个按钮，每当用户点击时，就打印出一段文字。如果使用lambda函数可以表示成下面这样：\nfrom tkinter import Button, mainloop\rbutton = Button(\rtext='This is a button',\rcommand=lambda: print('being pressed')) # 点击时调用lambda函数\rbutton.pack()\rmainloop() 而如果我们用常规函数def，那么需要写更多的代码：\nfrom tkinter import Button, mainloop\rdef print_message():\rprint('being pressed')\rbutton = Button(\rtext='This is a button',\rcommand=print_message) # 点击时调用lambda函数\rbutton.pack()\rmainloop() 显然，运用匿名函数的代码简洁很多，也更加符合Python的编程习惯��?\nPython函数式编��? link最后，我们一起来看一下，Python的函数式编程特性，这与我们今天所讲的匿名函数lambda，有着密切的联系��?\n所谓函数式编程，是指代码中每一块都是不可变的（immutable），都由纯函数（pure function）的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出，没有任何副作用��?\n举个很简单的例子，比如对于一个列表，我想让列表中的元素值都变为原来的两倍，我们可以写成下面的形式：\ndef multiply_2(l):\rfor index in range(0, len(l)):\rl[index] *= 2\rreturn l 这段代码就不是一个纯函数的形式，因为列表中元素的值被改变了，如果我多次调用multiply_2()这个函数，那么每次得到的结果都不一样。要想让它成为一个纯函数的形式，就得写成下面这种形式，重新创建一个新的列表并返回��?\ndef multiply_2_pure(l):\rnew_list = []\rfor item in l:\rnew_list.append(item * 2)\rreturn new_list 函数式编程的优点，主要在于其纯函数和不可变的特性使程序更加健壮，易于调试（debug）和测试；缺点主要在于限制多，难写。当然，Python不同于一些语言（比如Scala），它并不是一门函数式编程语言，不过，Python也提供了一些函数式编程的特性，值得我们了解和学习��?\nPython主要提供了这么几个函数：map()、filter()和reduce()，通常结合匿名函数lambda一起使用。这些都是你需要掌握的东西，接下来我逐一介绍��?\n首先是map(function, iterable)函数，前面的例子提到过，它表示，对iterable中的每个元素，都运用function这个函数，最后返回一个新的可遍历的集合。比如刚才列表的例子，要对列表中的每个元素乘��?，那么用map就可以表示为下面这样��?\nl = [1, 2, 3, 4, 5]\rnew_list = map(lambda x: x * 2, l) # [2��?4��?6��?8��?10] 我们可以以map()函数为例，看一下Python提供的函数式编程接口的性能。还是同样的列表例子，它还可以用for循环和list comprehension（目前没有统一中文叫法，你也可以直译为列表理解等）实现，我们来比较一下它们的速度��?\npython3 -mtimeit -s'xs=range(1000000)' 'map(lambda x: x*2, xs)'\r2000000 loops, best of 5: 171 nsec per loop\rpython3 -mtimeit -s'xs=range(1000000)' '[x * 2 for x in xs]'\r5 loops, best of 5: 62.9 msec per loop\rpython3 -mtimeit -s'xs=range(1000000)' 'l = []' 'for i in xs: l.append(i * 2)'\r5 loops, best of 5: 92.7 msec per loop 你可以看到，map()是最快的。因为map()函数直接由C语言写的，运行时不需要通过Python解释器间接调用，并且内部做了诸多优化，所以运行速度最快��?\n接下来来看filter(function, iterable)函数，它和map函数类似，function同样表示一个函数对象。filter()函数表示对iterable中的每个元素，都使用function判断，并返回True或者False，最后将返回True的元素组成一个新的可遍历的集合��?\n举个例子，比如我要返回一个列表中的所有偶数，可以写成下面这样��?\nl = [1, 2, 3, 4, 5]\rnew_list = filter(lambda x: x % 2 == 0, l) # [2, 4] 最后我们来看reduce(function, iterable)函数，它通常用来对一个集合做一些累积操作��?\nfunction同样是一个函数对象，规定它有两个参数，表示对iterable中的每个元素以及上一次调用后的结果，运用function进行计算，所以最后返回的是一个单独的数值��?\n举个例子，我想要计算某个列表元素的乘积，就可以用reduce()函数来表示：\nl = [1, 2, 3, 4, 5]\rproduct = reduce(lambda x, y: x * y, l) # 1*2*3*4*5 = 120 当然，类似的，filter()和reduce()的功能，也可以用for循环或者list comprehension来实现��?\n通常来说，在我们想对集合中的元素进行一些操作时，如果操作非常简单，比如相加、累积这种，那么我们优先考虑map()、filter()、reduce()这类或者list comprehension的形式。至于这两种方式的选择��?\n在数据量非常多的情况下，比如机器学习的应用，那我们一般更倾向于函数式编程的表示，因为效率更高��? 在数据量不多的情况下，并且你想要程序更加Pythonic的话，那么list comprehension也不失为一个好选择��? 不过，如果你要对集合中的元素，做一些比较复杂的操作，那么，考虑到代码的可读性，我们通常会使用for循环，这样更加清晰明了��?\n总结 link这节课，我们一起学习了Python中的匿名函数lambda，它的主要用途是减少代码的复杂度。需要注意的是lambda是一个表达式，并不是一个语句；它只能写成一行的表达形式，语法上并不支持多行。匿名函数通常的使用场景是：程序中需要使用一个函数完成一个简单的功能，并且该函数只调用一次��?\n其次，我们也入门了Python的函数式编程，主要了解了常见的map()，fiilter()和reduce()三个函数，并比较了它们与其他形式（for循环，comprehension）的性能，显然，它们的性能效率是最优的��?\n思考题 link最后，我想给你留下两道思考题��?\n第一问：如果让你对一个字典，根据值进行由高到底的排序，该怎么做呢？以下面这段代码为例，你可以思考一下��?\nd = {'mike': 10, 'lucy': 2, 'ben': 30} 第二问：在实际工作学习中，你遇到过哪些使用匿名函数的场景呢？\n欢迎在留言区写下你的答案想法，与我讨论，也欢迎你把这篇文章分享给你的同事、朋友��?\n这个地方map生成的是生成器，与后面的2个做比较感觉不大合适，是否更改为测试list(map(lambda x: x*2, xs))更恰当？2019-05-31向南 👍��?��?💬��?��?p\u003e```python sorted(d.items(), key=lambda x: x[1], reverse=True)\nlambda函数在数据清洗的时候，作用很大\n2020-03-07daowuli_chihai 👍��?��?💬��?��?p\u003e下面代码，print(new_list)报错，而改成print(list(new_list))可以输出所有偶数，python3.8版本 和之前版��?不同��?\rl = [1, 2, 3, 4, 5]\rnew_list = filter(lambda x: x % 2 == 0, l) # [2, 4]\n2020-06-12Jackson90 👍��?��?💬��?��?p\u003e # 获得排序的元组，字典\rlist_1 = [item for item in ori_dict.items()]\rlist_1.sort(key=lambda val: val[1], reverse=True)\r# 重新生成字典\rdict_1 = {key: value for key, value in list_1}\n2019-10-14谁谁 👍��?��?💬��?��?p\u003e请问老师，如何理解这一句：\r[(lambda x: x*x)(x) for x in range(10)]\r其中��?lambda x: x*x)(x)，这个lambda函数括起来是代表直接调用��?/p\u003e2019-12-23Kevin 👍��?��?💬��?��?p\u003e第一问：不知道这么写对不对��?\rd = {\u0026#39;mike\u0026#39;: 10, \u0026#39;lucy\u0026#39;: 2, \u0026#39;ben\u0026#39;: 30}\rprint(sorted(d, key=lambda x:x[1], reverse=False))\r输出：[\u0026#39;ben\u0026#39;, \u0026#39;mike\u0026#39;, \u0026#39;lucy\u0026#39;]\n2020-06-18Steve 👍��?��?💬��?��?p\u003e喜欢这种讲解方式，能不能再开一个JavaScript的课��?/p\u003e2020-05-02可乐泡枸��?/span\u003e 👍��?��?💬��?��?p\u003esorted(d.items(), key= lambda x:-x[1])\n2019-06-01Jove 👍��?��?💬��?��?p\u003e思考题答案��?\rd = {\u0026#39;mike\u0026#39;: 10, \u0026#39;lucy\u0026#39;: 2, \u0026#39;ben\u0026#39;: 30}\rsorted(d.items(), key=lambda x:x[1])\n2019-05-31小胖 👍��?��?💬��?��?p\u003esorted(d.items(), key=lambda x :x[1], reverse=True)\n2019-05-31小胖 👍��?��?💬��?��?p\u003esorted(d.items(), key=lambda x :x[1])\n2019-05-31程序员人��?/span\u003e 👍��?��?💬��?��?p\u003e1,\rimport operator\rprint(sorted(d.items(),key=lambda x:x[1],reverse=True))\rprint(sorted(d.items(),key=operator.itemgetter(1),reverse=True))\r2,\r我不是python程序员，所以没有什么工作中例子。：P\r2019-05-31方向 👍��?��?💬��?��?p\u003elist comprehension不是叫列表生成式��?/p\u003e2019-05-31lmingzhi 👍��?��?💬��?��?p\u003e工作中常用到lambda的地方是在pandas的数据列批量处理，一般也是和map结合使用��?\rIn [4]: import pandas as pd In [5]: obj=pd.Series(range(10)) In [6]: obj.map(lambda x: x*x) Out[6]: 0 0\r1 1\r2 4\r3 9\r4 16\r5 25\r6 36\r7 49\r8 64\r9 81\rdtype: int64\n2019-05-31\r"
            }
        );
    index.add(
            {
                id:  9 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/12---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E\/",
                title: "12 - 面向对象（下）：如何实现一个搜索引擎？",
                description: "你好，我是景霄。这节课，我们来实现一��?Python 的搜索引擎（search engine）��?\n承接上文，今天这节课的主要目的是，带你模拟敏捷开发过程中的迭代开发流程，巩固面向对象的程序设计思想��?\n我们将从最简单最直接的搜索做起，一步步优化，这其中，我不会涉及到过多的超纲算法，但不可避免会介绍一些现代搜索引擎中的基础概念，例如语料（corpus）、倒序索引（inverted index）等��?\n如果你对这方面本身有些了解，自然可以轻松理解；即使你之前完全没接触过搜索引擎，也不用过分担心，我会力求简洁清晰，降低学习难度。同时，我希望你把更多的精力放在面向对象的建模思路上��?\n“高大上”的搜索引擎 link引擎一词尤如其名，听起来非常酷炫。搜索引擎，则是新世纪初期互联网发展最重要的入口之一，依托搜索引擎，中国和美国分别诞生了百度、谷歌等巨型公司��?\n搜索引擎极大地方便了互联网生活，也成为上网必不可少的刚需工具。依托搜索引擎发展起来的互联网广告，则成了硅谷和中国巨头的核心商业模式；而搜索本身，也在持续进步着��?Facebook 和微信也一直有意向在自家社交产品架设搜索平台��?\n关于搜索引擎的价值我不必多说了，今天我们主要来看一下搜索引擎的核心构成��?\n听Google的朋友说，他们入职培训的时候，有一门课程叫��?The life of a query，内容是讲用户在浏览器中键入一串文字，按下回车后发生了什么。今天我也按照这个思路，来简单介绍下��?\n我们知道��?一个搜索引擎由搜索器、索引器、检索器和用户接口四个部分组��?��?\n搜索器，通俗来讲就是我们常提到的爬虫（scrawler），它能在互联网上大量爬取各类网站的内容，送给索引器。索引器拿到网页和内容后，会对内容进行处理，形成索引（index），存储于内部的数据库等待检索��?\n最后的用户接口很好理解，是指网页和 App 前端界面，例如百度和谷歌的搜索页面。用户通过用户接口，向搜索引擎发出询问（query），询问解析后送达检索器；检索器高效检索后，再将结果返回给用户��?\n爬虫知识不是我们今天学习的重点，这里我就不做深入介绍了。我们假设搜索样本存在于本地磁盘上��?\n为了方便，我们只提供五个文件的检索，内容我放在了下面这段代码中：\n# 1.txt\rI have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.\r# 2.txt\rI have a dream that one day down in Alabama, with its vicious racists, . . . one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.\r# 3.txt\rI have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.\r# 4.txt\rThis is our hope. . . With this faith we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day. . . .\r# 5.txt\rAnd when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God's children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: \"Free at last! Free at last! Thank God Almighty, we are free at last!\" 我们先来定义 SearchEngineBase 基类。这里我先给出了具体的代码，你不必着急操作，还是那句话，跟着节奏慢慢学，再难的东西也可以啃得下来��?\n",
                content: "你好，我是景霄。这节课，我们来实现一��?Python 的搜索引擎（search engine）��?\n承接上文，今天这节课的主要目的是，带你模拟敏捷开发过程中的迭代开发流程，巩固面向对象的程序设计思想��?\n我们将从最简单最直接的搜索做起，一步步优化，这其中，我不会涉及到过多的超纲算法，但不可避免会介绍一些现代搜索引擎中的基础概念，例如语料（corpus）、倒序索引（inverted index）等��?\n如果你对这方面本身有些了解，自然可以轻松理解；即使你之前完全没接触过搜索引擎，也不用过分担心，我会力求简洁清晰，降低学习难度。同时，我希望你把更多的精力放在面向对象的建模思路上��?\n“高大上”的搜索引擎 link引擎一词尤如其名，听起来非常酷炫。搜索引擎，则是新世纪初期互联网发展最重要的入口之一，依托搜索引擎，中国和美国分别诞生了百度、谷歌等巨型公司��?\n搜索引擎极大地方便了互联网生活，也成为上网必不可少的刚需工具。依托搜索引擎发展起来的互联网广告，则成了硅谷和中国巨头的核心商业模式；而搜索本身，也在持续进步着��?Facebook 和微信也一直有意向在自家社交产品架设搜索平台��?\n关于搜索引擎的价值我不必多说了，今天我们主要来看一下搜索引擎的核心构成��?\n听Google的朋友说，他们入职培训的时候，有一门课程叫��?The life of a query，内容是讲用户在浏览器中键入一串文字，按下回车后发生了什么。今天我也按照这个思路，来简单介绍下��?\n我们知道��?一个搜索引擎由搜索器、索引器、检索器和用户接口四个部分组��?��?\n搜索器，通俗来讲就是我们常提到的爬虫（scrawler），它能在互联网上大量爬取各类网站的内容，送给索引器。索引器拿到网页和内容后，会对内容进行处理，形成索引（index），存储于内部的数据库等待检索��?\n最后的用户接口很好理解，是指网页和 App 前端界面，例如百度和谷歌的搜索页面。用户通过用户接口，向搜索引擎发出询问（query），询问解析后送达检索器；检索器高效检索后，再将结果返回给用户��?\n爬虫知识不是我们今天学习的重点，这里我就不做深入介绍了。我们假设搜索样本存在于本地磁盘上��?\n为了方便，我们只提供五个文件的检索，内容我放在了下面这段代码中：\n# 1.txt\rI have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.\r# 2.txt\rI have a dream that one day down in Alabama, with its vicious racists, . . . one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.\r# 3.txt\rI have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.\r# 4.txt\rThis is our hope. . . With this faith we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day. . . .\r# 5.txt\rAnd when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God's children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: \"Free at last! Free at last! Thank God Almighty, we are free at last!\" 我们先来定义 SearchEngineBase 基类。这里我先给出了具体的代码，你不必着急操作，还是那句话，跟着节奏慢慢学，再难的东西也可以啃得下来��?\nclass SearchEngineBase(object):\rdef __init__(self):\rpass\rdef add_corpus(self, file_path):\rwith open(file_path, 'r') as fin:\rtext = fin.read()\rself.process_corpus(file_path, text)\rdef process_corpus(self, id, text):\rraise Exception('process_corpus not implemented.')\rdef search(self, query):\rraise Exception('search not implemented.')\rdef main(search_engine):\rfor file_path in ['1.txt', '2.txt', '3.txt', '4.txt', '5.txt']:\rsearch_engine.add_corpus(file_path)\rwhile True:\rquery = input()\rresults = search_engine.search(query)\rprint('found {} result(s):'.format(len(results)))\rfor result in results:\rprint(result) SearchEngineBase 可以被继承，继承的类分别代表不同的算法引擎。每一个引擎都应该实现 process_corpus()和search()两个函数，对应我们刚刚提到的索引器和检索器。main()函数提供搜索器和用户接口，于是一个简单的包装界面就有了��?\n具体来看这段代码，其中，\nadd_corpus() 函数负责读取文件内容，将文件路径作为 ID，连同内容一起送到 process_corpus 中��? process_corpus 需要对内容进行处理，然后文件路径为 ID ，将处理后的内容存下来。处理后的内容，就叫做索引（index）��? search 则给定一个询问，处理询问，再通过索引检索，然后返回��? 好，理解这些概念后，接下来，我们实现一个最基本的可以工作的搜索引擎，代码如下：\nclass SimpleEngine(SearchEngineBase):\rdef __init__(self):\rsuper(SimpleEngine, self).__init__()\rself.__id_to_texts = {}\rdef process_corpus(self, id, text):\rself.__id_to_texts[id] = text\rdef search(self, query):\rresults = []\rfor id, text in self.__id_to_texts.items():\rif query in text:\rresults.append(id)\rreturn results\rsearch_engine = SimpleEngine()\rmain(search_engine)\r########## 输出 ##########\rsimple\rfound 0 result(s):\rlittle\rfound 2 result(s):\r1.txt\r2.txt 你可能很惊讶，只需要短短十来行代码居然就可以了吗？\n没错，正是如此，这段代码我们拆开来看一下：\nSimpleEngine 实现了一个继��?SearchEngineBase 的子类，继承并实现了 process_corpus ��?search 接口，同时，也顺手继承了 add_corpus 函数（当然你想重写也是可行的），因此我们可以��?main() 函数中直接调取��?\n在我们新的构造函数中，self.__id_to_texts = {} 初始化了自己的私有变量，也就是这个用来存储文件名到文件内容的字典��?\nprocess_corpus() 函数则非常直白地将文件内容插入到字典中。这里注意，ID 需要是唯一的，不然相同ID的新内容会覆盖掉旧的内容��?\nsearch 直接枚举字典，从中找到要搜索的字符串。如果能够找到，则将 ID 放到结果列表中，最后返回��?\n你看，是不是非常简单呢？这个过程始终贯穿着面向对象的思想，这里我为你梳理成了几个问题，你可以自己思考一下，当成是一个小复习��?\n现在你对父类子类的构造函数调用顺序和方法应该更清楚了吧？ 继承的时候，函数是如何重写的��? 基类是如何充当接口作用的（你可以自行删掉子类中的重写函数，抑或是修改一下函数的参数，看一下会报什么错）？ 方法和变量之间又如何衔接起来的呢��? 好的，我们重新回到搜索引擎这个话题��?\n相信你也能看得出来，这种实现方式简单，但显然是一种很低效的方式：每次索引后需要占用大量空间，因为索引函数并没有做任何事情；每次检索需要占用大量时间，因为所有索引库的文件都要被重新搜索一遍。如果把语料的信息量视为 n，那么这里的时间复杂度和空间复杂度都应该��?O(n) 级别的��?\n而且，还有一个问题：这里��?query 只能是一个词，或者是连起来的几个词。如果你想要搜索多个词，它们又分散在文章的不同位置，我们的简单引擎就无能为力了��?\n这时应该怎么优化呢？\n最直接的一个想法，就是把语料分词，看成一个个的词汇，这样就只需要对每篇文章存储它所有词汇的 set 即可。根据齐夫定律（Zipf’s law，https://en.wikipedia.org/wiki/Zipf%27s_law），在自然语言的语料库里，一个单词出现的频率与它在频率表里的排名成反比，呈现幂律分布。因此，语料分词的做法可以大大提升我们的存储和搜索效率��?\n那具体该如何实现呢？\nBag of Words ��?Inverted Index link我们先来实现一个名��?Bag of Words 的搜索模型。请看下面的代码��?\nimport re\rclass BOWEngine(SearchEngineBase):\rdef __init__(self):\rsuper(BOWEngine, self).__init__()\rself.__id_to_words = {}\rdef process_corpus(self, id, text):\rself.__id_to_words[id] = self.parse_text_to_words(text)\rdef search(self, query):\rquery_words = self.parse_text_to_words(query)\rresults = []\rfor id, words in self.__id_to_words.items():\rif self.query_match(query_words, words):\rresults.append(id)\rreturn results\r@staticmethod\rdef query_match(query_words, words):\rfor query_word in query_words:\rif query_word not in words:\rreturn False\rreturn True\r@staticmethod\rdef parse_text_to_words(text):\r# 使用正则表达式去除标点符号和换行��?\rtext = re.sub(r'[^\\w ]', ' ', text)\r# 转为小写\rtext = text.lower()\r# 生成所有单词的列表\rword_list = text.split(' ')\r# 去除空白单词\rword_list = filter(None, word_list)\r# 返回单词��?set\rreturn set(word_list)\rsearch_engine = BOWEngine()\rmain(search_engine)\r########## 输出 ##########\ri have a dream\rfound 3 result(s):\r1.txt\r2.txt\r3.txt\rfreedom children\rfound 1 result(s):\r5.txt 你应该发现，代码开始变得稍微复杂些了��?\n这里我们先来理解一个概念，BOW Model，即 Bag of Words Model，中文叫做词袋模型。这��?NLP 领域最常见最简单的模型之一��?\n假设一个文本，不考虑语法、句法、段落，也不考虑词汇出现的顺序，只将这个文本看成这些词汇的集合。于是相应的，我们把 id_to_texts 替换��?id_to_words，这样就只需要存这些单词，而不是全部文章，也不需要考虑顺序��?\n其中，process_corpus() 函数调用类静态函��?parse_text_to_words，将文章打碎形成词袋，放��?set 之后再放到字典中��?\nsearch() 函数则稍微复杂一些。这里我们假设，想得到的结果，是所有的搜索关键词都要出现在同一篇文章中。那么，我们需要同样打��?query 得到一��?set，然后把 set 中的每一个词，和我们的索引中每一篇文章进行核对，看一下要找的词是否在其中。而这个过程由静态函��?query_match 负责��?\n你可以回顾一下上节课学到的静态函数，我们看到，这两个函数都是没有状态的，它们不涉及对象的私有变量（没有 self 作为参数），相同的输入能够得到完全相同的输出结果。因此设置为静态，可以方便其他的类来使用��?\n可是，即使这样做，每次查询时依然需要遍历所有ID，虽然比��?Simple 模型已经节约了大量时间，但是互联网上有上亿个页面，每次都全部遍历的代价还是太大了。到这时，又该如何优化呢��?\n你可能想到了，我们每次查询的 query 的单词量不会很多，一般也就几个、最多十几个的样子。那可不可以从这里下手呢��?\n再有，词袋模型并不考虑单词间的顺序，但有些人希望单词按顺序出现，或者希望搜索的单词在文中离得近一些，这种情况下词袋模型现任就无能为力了��?\n针对这两点，我们还能做得更好吗？显然是可以的，请看接下来的这段代码��?\nimport re\rclass BOWInvertedIndexEngine(SearchEngineBase):\rdef __init__(self):\rsuper(BOWInvertedIndexEngine, self).__init__()\rself.inverted_index = {}\rdef process_corpus(self, id, text):\rwords = self.parse_text_to_words(text)\rfor word in words:\rif word not in self.inverted_index:\rself.inverted_index[word] = []\rself.inverted_index[word].append(id)\rdef search(self, query):\rquery_words = list(self.parse_text_to_words(query))\rquery_words_index = list()\rfor query_word in query_words:\rquery_words_index.append(0)\r# 如果某一个查询单词的倒序索引为空，我们就立刻返回\rfor query_word in query_words:\rif query_word not in self.inverted_index:\rreturn []\rresult = []\rwhile True:\r# 首先，获得当前状态下所有倒序索引��?index\rcurrent_ids = []\rfor idx, query_word in enumerate(query_words):\rcurrent_index = query_words_index[idx]\rcurrent_inverted_list = self.inverted_index[query_word]\r# 已经遍历到了某一个倒序索引的末尾，结束 search\rif current_index \u003e= len(current_inverted_list):\rreturn result\rcurrent_ids.append(current_inverted_list[current_index])\r# 然后，如��?current_ids 的所有元素都一样，那么表明这个单词在这个元素对应的文档中都出现��?\rif all(x == current_ids[0] for x in current_ids):\rresult.append(current_ids[0])\rquery_words_index = [x + 1 for x in query_words_index]\rcontinue\r# 如果不是，我们就把最小的元素加一\rmin_val = min(current_ids)\rmin_val_pos = current_ids.index(min_val)\rquery_words_index[min_val_pos] += 1\r@staticmethod\rdef parse_text_to_words(text):\r# 使用正则表达式去除标点符号和换行��?\rtext = re.sub(r'[^\\w ]', ' ', text)\r# 转为小写\rtext = text.lower()\r# 生成所有单词的列表\rword_list = text.split(' ')\r# 去除空白单词\rword_list = filter(None, word_list)\r# 返回单词��?set\rreturn set(word_list)\rsearch_engine = BOWInvertedIndexEngine()\rmain(search_engine)\r########## 输出 ##########\rlittle\rfound 2 result(s):\r1.txt\r2.txt\rlittle vicious\rfound 1 result(s):\r2.txt 首先我要强调一下，这次的算法并不需要你完全理解，这里的实现有一些超出了本章知识点。但希望你不要因此退缩，这个例子会告诉你，面向对象编程是如何把算法复杂性隔离开来，而保留接口和其他的代码不变��?\n我们接着来看这段代码。你可以看到，新模型继续使用之前的接口，仍然只在 __init__()、process_corpus()和search()三个函数进行修改��?\n这其实也是大公司里团队协作的一种方式，**在合理的分层设计后，每一层的逻辑只需要处理好分内的事情即��?*。在迭代升级我们的搜索引擎内核时��?main 函数、用户接口没有任何改变。当然，如果公司招了新的前端工程师，要对用户接口部分进行修改，新人也不需要过分担心后台的事情，只要做好数据交互就可以了��?\n继续看代码，你可能注意到了开头的Inverted Index。Inverted Index Model，即倒序索引，是非常有名的搜索引擎方法，接下来我简单介绍一下��?\n倒序索引，一如其名，也就是说这次反过来，我们保留的是 word -\u003e id 的字典。于是情况就豁然开朗了，在 search 时，我们只需要把想要��?query_word 的几个倒序索引单独拎出来，然后从这几个列表中找共有的元素，那些共有的元素，��?ID，就是我们想要的查询结果。这样，我们就避免了将所有的 index 过一遍的尴尬��?\nprocess_corpus 建立倒序索引。注意，这里的代码都是非常精简的。在工业界领域，需要一��?unique ID 生成器，来对每一篇文章标记上不同��?ID，倒序索引也应该按照这��?unique_id 来进行排序��?\n至于search() 函数，你大概了解它做的事情即可。它会根��?query_words 拿到所有的倒序索引，如果拿不到，就表示有的 query word 不存在于任何文章中，直接返回空；拿到之后，运行一个“合并K个有序数组”的算法，从中拿到我们想要的 ID，并返回��?\n注意，这里用到的算法并不是最优的，最优的写法需要用最小堆来存��?index。这是一道有名的 leetcode hard 题，有兴趣请参考：https://blog.csdn.net/qqxx6661/article/details/77814794��?\n遍历的问题解决了，那第二个问题，如果我们想要实现搜索单词按顺序出现，或者希望搜索的单词在文中离得近一些呢��?\n我们需要在 Inverted Index 上，对于每篇文章也保留单词的位置信息，这样一来，在合并操作的时候处理一下就可以了��?\n倒序索引我就介绍到这里了，如果你感兴趣可以自行查阅资料。还是那句话，我们的重点是面向对象的抽象，别忘了体会这一思想��?\nLRU 和多重继��? link到这一步，终于，你的搜索引擎上线了，有了越来越多的访问量（QPS）。欣喜骄傲的同时，你却发现服务器有些“不堪重负”了。经过一段时间的调研，你发现大量重复性搜索占据了 90% 以上的流量，于是，你想到了一个大杀器——给搜索引擎加一个缓存��?\n所以，最后这部分，我就来讲讲缓存和多重继承的内容��?\nimport pylru\rclass LRUCache(object):\rdef __init__(self, size=32):\rself.cache = pylru.lrucache(size)\rdef has(self, key):\rreturn key in self.cache\rdef get(self, key):\rreturn self.cache[key]\rdef set(self, key, value):\rself.cache[key] = value\rclass BOWInvertedIndexEngineWithCache(BOWInvertedIndexEngine, LRUCache):\rdef __init__(self):\rsuper(BOWInvertedIndexEngineWithCache, self).__init__()\rLRUCache.__init__(self)\rdef search(self, query):\rif self.has(query):\rprint('cache hit!')\rreturn self.get(query)\rresult = super(BOWInvertedIndexEngineWithCache, self).search(query)\rself.set(query, result)\rreturn result\rsearch_engine = BOWInvertedIndexEngineWithCache()\rmain(search_engine)\r########## 输出 ##########\rlittle\rfound 2 result(s):\r1.txt\r2.txt\rlittle\rcache hit!\rfound 2 result(s):\r1.txt\r2.txt 它的代码很简单，LRUCache 定义了一个缓存类，你可以通过继承这个类来调用其方法。LRU 缓存是一种很经典的缓存（同时，LRU的实现也是硅谷大厂常考的算法面试题，这里为了简单，我直接使��?pylru 这个包），它符合自然界的局部性原理，可以保留最近使用过的对象，而逐渐淘汰掉很久没有被用过的对象��?\n因此，这里的缓存使用起来也很简单，调用 has() 函数判断是否在缓存中，如果在，调��?get 函数直接返回结果；如果不在，送入后台计算结果，然后再塞入缓存��?\n我们可以看到，BOWInvertedIndexEngineWithCache 类，多重继承了两个类。首先，你需要注意的是构造函数（上节课的思考题，你思考了吗？）。多重继承有两种初始化方法，我们分别来看一下��?\n第一种方法，用下面这行代码，直接初始化该类的第一个父类：\nsuper(BOWInvertedIndexEngineWithCache, self).__init__() 不过使用这种方法时，要求继承链的最顶层父类必须要继��?object��?\n第二种方法，对于多重继承，如果有多个构造函数需要调用， 我们必须用传统的方法LRUCache.__init__(self) ��?\n其次，你应该注意，search() 函数被子��?BOWInvertedIndexEngineWithCache 再次重载，但是我还需要调��?BOWInvertedIndexEngine ��?search() 函数，这时该怎么办呢？请看下面这行代码：\nsuper(BOWInvertedIndexEngineWithCache, self).search(query) 我们可以强行调用被覆盖的父类的函数��?\n这样一来，我们就简洁地实现了缓存，而且还是在不影响 BOWInvertedIndexEngine 代码的情况下。这部分内容希望你多读几遍，自己揣摩清楚，通过这个例子多多体会继承的优势��?\n总结 link今天这节课是面向对象的实战应用，相比起前面的理论知识，内容其实不那么友好。不过，若你能静下心来，仔细学习，理清楚整个过程的要点，对你理解面向对象必将有所裨益。比如，你可以根据下面两个问题，来检验今天这节课的收获��?\n你能把这节课所有的类的属性和函数抽取出来，自己在纸上画一遍继承关系吗��? 迭代开发流程是怎样的？ 其实于我而言，通过构造搜索引擎这么一个例子来讲面向对象，也是颇费了一番功夫。这其中虽然涉及一些搜索引擎的专业知识和算法，但篇幅有限，也只能算是抛砖引玉，你若有所收获，我便欣然满足��?\n思考题 link最后给你留一道思考题。私有变量能被继承吗？如果不能，你想继承应该怎么去做呢？欢迎留言与我分享、讨论，也欢迎你把这篇文章分享给你的同事、朋友，一起交流与进步��?\nclass B(A): pass\nb = B() print(b._A__a)2019-06-09小侠龙旋��?/span\u003e 👍��?8��?💬��?��?p\u003e和面向对象无关的关键词整理： 1.一个搜索引擎由搜索器、索引器、检索器和用户接口四个部分组成��? 2.Bag of Words Model，词袋模型��? 3.Inverted Index Model，倒序索引��? 4.语料corpus分词，齐夫定律��? 5.合并 K 个有序数组��? 6.LRU缓存��? 难点消化��?��?��? 思考题��? Python并没有真正的私有化支持，但可用下划线得到伪私有： ��?）_xxx \"单下划线 \" 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量，需通过类提供的接口进行访问��? ��?）__xxx 类中的私有变��?#47;方法名，只有类对象自己能访问，连子类对象也不能访问到这个数据��? ��?）xxx 魔法函数，前后均有一个“双下划线��?代表python里特殊方法专用的标识，如 init() 代表类的构造函数��?/p\u003e2019-06-08shiziwen 👍��?1��?💬��?��?p\u003e第二种方法，对于多重继承，如果有多个构造函数需要调用， 我们必须用传统的方法LRUCache.init(self) ��?\n这里的两句话没有很明白，LRUCache为什么必须使用第二种方法��?\nclass B(A): def init(self): print('enter B') super().init() print('leave B')\nclass C(A): def init(self): print('enter C') super().init() print('leave C')\nclass D(B, C): def init(self): print('enter D') super(D,self).init() C.init(self) print('leave D')\nD() 输出结果��? enter D enter B enter C enter A leave A leave C leave B enter C enter A leave A leave C leave D2020-03-22quanxyun 👍��?��?💬��?��?p\u003ePython并没有真正的私有化支持，但可用下划线得到伪私有： ��?）_xxx \"单下划线 \" 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量，需通过类提供的接口进行访问��? ��?）__xxx 类中的私有变��?#47;方法名，只有类对象自己能访问，连子类对象也不能访问到这个数据��? ��?）xxx 魔法函数，前后均有一个“双下划线��?代表python里特殊方法专用的标识，如 init() 代表类的构造函数��?/p\u003e2019-11-14响雨 👍��?��?💬��?��?p\u003e私有属性不可以被继承，但是可以创建一个普通的方法，在方法中操作私有属性。因为普通的方法是可以操作的��?/p\u003e2019-06-25Claywoow 👍��?��?💬��?��?p\u003e老师可以拓展一下元类吗，它是面向对象编程中一个重要的类型吗？2019-06-08益达 👍��?7��?💬��?��?p\u003e看不懂不睡觉2019-06-05Wing·三金 👍��?5��?💬��?��?p\u003e思考题：子类继承父类私有变量的方法\n通过定义 get/set 函数来间接操作私有变��? 通过 实例��?_父类名__私有变量��?来直接调用，所以事实上 python 并不直接私有变量 主要知识��? link 搜索引擎的四个组成部��? 迭代开发的流程 类的继承与父类函数的强行调用 词袋模型 + 逆序索引 + 合并有序数组 = 优化检索速度 + 考虑单词顺序与间��? pylru 的基本用��? 多重继承的初始化规则 搜索引擎 link 搜索器：相当于爬��? 索引器：为每个文��?#47;网页建立唯一的索��? 检索器：高效地检索并返回匹配的文��?#47;网页 用户接口：输入框和结果返回界��? 迭代开发的流程 link 构建一个通用的基本框��? 从最简单的情况考虑起，搭建一个能运行的极简版本 按照实际需要不断对具体的实现过程进行优化：如在本讲的例子中，先考虑了单个搜索词 + 小搜索量的情况，构建��?ver 1；然后考虑了多个搜索词，构建了词袋��?ver 2；再考虑了大搜索量，构建了词��?+ 逆序索引��?ver 3（提��?搜索词排序与间隔 情况下的处理思路）；最后考虑了负载与重复性搜索问题，构建了使��?LRU 缓存策略��?ver 4 如果回过头来看最初的框架，还能发��?add_corpus 的方法并不适用于文件较大的情况，结合前面第六讲的内容可以做些改进；以及 main 函数直接用了 for 循环来找所有的文件，实际使用时用的是诸��?os.walk 的方��?/p\u003e2019-06-05��?/span\u003e 👍��?0��?💬��?��?p\u003e这篇文章就值回票价了��?/p\u003e2019-06-07风居住的��?/span\u003e 👍��?3��?💬��?��?p\u003ePython3.x ��?Python2.x 的一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx2019-06-17chuan_chen 👍��?4��?💬��?��?p\u003e感觉这篇好难。。��?/p\u003e2019-09-04John Si 👍��?0��?💬��?��?p\u003e关于思考题,子类不能继承父类私有属性，只可透过self._Parent__varname去读取该私有属性的值，或在父类创建方法返回私有属性的值，然后子类调用父类方法去取得该私有属性的��? class Animal():\ndef __init__(self, sex, height, weight):\rself.__sex = sex\rself.height = height\rself.weight = weight\rdef say_hello(self):\rraise \u0026#39;say hello not implemented\u0026#39;\rdef get_sex(self):\rprint(\u0026#39;Achieve sex information for parent method: {}\u0026#39;.format(self.__sex))\rclass Person(Animal):\ndef __init__(self,name,age):\rsuper().__init__(\u0026#39;M\u0026#39;,172,70)\rself.name = name\rself.age = age\rdef say_hello(self):\rprint(\u0026#39;Hello, {}, age: {}, weight:{}\u0026#39;.format(self.name, self.age, self.weight))\rprint(\u0026#39;Sex: {}\u0026#39;.format(self._Animal__sex))\rjohn = Person('John',35) john.say_hello() john.get_sex()\n======================== Hello, John, age: 35, weight: 71 Sex: M Achieve sex information for parent method: M\n"
            }
        );
    index.add(
            {
                id:  10 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/14---%E7%AD%94%E7%96%91%E4%B8%80%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\/",
                title: "14 - 答疑（一）：列表和元组的内部实现是怎样的？",
                description: "你好，我是景霄��?\n转眼间，专栏上线已经一个月了，而我们也在不知不觉中完成了第一大章基础篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢��?\n大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很典型的问题，我专门摘录了出来，作为今天的答疑内容，集中回复��?\n问题一：列表和元组的内部实��? link第一个问题，是胡峣同学提出的，有关列表（list）和元组（tuple）的内部实现，想知道里边是linked list 或array，还是把array linked一下这样的方式��?\n关于这个问题，我们可以分别从源码来看��?\n先来��?Python 3.7 的list源码。你可以先自己阅读下面两个链接里的内容��?\nlistobject.h：https://github.com/python/cpython/blob/949fe976d5c62ae63ed505ecf729f815d0baccfc/Include/listobject.h#L23\nlistobject.c: https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/listobject.c#L33\n",
                content: "你好，我是景霄��?\n转眼间，专栏上线已经一个月了，而我们也在不知不觉中完成了第一大章基础篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢��?\n大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很典型的问题，我专门摘录了出来，作为今天的答疑内容，集中回复��?\n问题一：列表和元组的内部实��? link第一个问题，是胡峣同学提出的，有关列表（list）和元组（tuple）的内部实现，想知道里边是linked list 或array，还是把array linked一下这样的方式��?\n关于这个问题，我们可以分别从源码来看��?\n先来��?Python 3.7 的list源码。你可以先自己阅读下面两个链接里的内容��?\nlistobject.h：https://github.com/python/cpython/blob/949fe976d5c62ae63ed505ecf729f815d0baccfc/Include/listobject.h#L23\nlistobject.c: https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/listobject.c#L33\n我把 list的具体结构放在了下面��?\n可以看到，list本质上是一个over-allocate的array。其中，ob_item是一个指针列表，里面的每一个指针都指向列表的元素。��?allocated则存储了这个列表已经被分配的空间大小��?\n需要注意的是，allocated 与列表实际空间大小的区别。列表实际空间大小，是指len(list)返回的结果，即上述代码注释中的ob_size，表示这个列表总共存储了多少个元素。实际情况下，为了优化存储结构，避免每次增加元素都要重新分配内存，列表预分配的空间allocated往往会大于ob_size（详见正文中的例子）��?\n所以，它们的关系为：allocated \u003e= len(list) = ob_size��?\n如果当前列表分配的空间已满（即allocated == len(list)），则会向系统请求更大的内存空间，并把原来的元素全部拷贝过去。列表每次分配空间的大小，遵循下面的模式��?\n0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ... 我们再来分析元组。下面是Python 3.7 的tuple源码，同样的，你可以先自己阅读一下��?\ntupleobject.h��?https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Include/tupleobject.h#L25\ntupleobject.c：https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/tupleobject.c#L16\n同样的，下面为tuple的具体结构：\n你可以看到，它和list相似，本质也是一个array，但是空间大小固定。不同于一般array，Python的tuple做了许多优化，来提升在程序中的效率��?\n举个例子，当tuple的大小不超过20时，Python就会把它缓存在内部的一个free list中。这样，如果你以后需要再去创建同样的tuple，Python就可以直接从缓存中载入，提高了程序运行效率��?\n问题二：为什么在旧哈希表中，元素会越来越稀疏？ link第二个问题，是Hoo同学提出的，为什么在旧哈希表中，元素会越来越稀疏？\n我们可以先来看旧哈希表的示意图：\n--+-------------------------------+\r| 哈希��?(hash) ��?(key) ��?(value)\r--+-------------------------------+\r0 | hash0 key0 value0\r--+-------------------------------+\r1 | hash1 key1 value1\r--+-------------------------------+\r2 | hash2 key2 value2\r--+-------------------------------+\r. | ...\r__+_______________________________+ 你会发现，它是一个over-allocate的array，根据元素键（key）的哈希值，来计算其应该被插入位置的索引��?\n因此，假设我有下面这样一个字典：\n{'name': 'mike', 'dob': '1999-01-01', 'gender': 'male'} 那么这个字典便会存储为类似下面的形式��?\nentries = [\r['--', '--', '--']\r[-230273521, 'dob', '1999-01-01'],\r['--', '--', '--'],\r['--', '--', '--'],\r[1231236123, 'name', 'mike'],\r['--', '--', '--'],\r[9371539127, 'gender', 'male']\r] 这里的��?--‘，表示这个位置没有元素，但是已经分配了内存��?\n我们知道，当哈希表剩余空间小��?/3时，为了保证相关操作的高效性并避免哈希冲突，就会重新分配更大的内存。所以，当哈希表中的元素越来越多时，分配了内存但里面没有元素的位置，也会变得越来越多。这样一来，哈希表便会越来越稀疏��?\n而新哈希表的结构，改变了这一点，也大大提高了空间的利用率。新哈希表的结构如下所示：\nIndices\r----------------------------------------------------\rNone | index | None | None | index | None | index ...\r----------------------------------------------------\rEntries\r--------------------\rhash0 key0 value0\r---------------------\rhash1 key1 value1\r---------------------\rhash2 key2 value2\r---------------------\r...\r--------------------- 你可以看到，它把存储结构分成了Indices和Entries这两个array，而’None‘代表这个位置分配了内存但没有元素��?\n我们同样还用上面这个例子，它在新哈希表中的存储模式，就会变为下面这样��?\nindices = [None, 1, None, None, 0, None, 2]\rentries = [\r[1231236123, 'name', 'mike'],\r[-230273521, 'dob', '1999-01-01'],\r[9371539127, 'gender', 'male']\r] 其中，Indices中元素的值，对应entries中相应的索引。比如indices中的1，就对应着entries[1]，即��?dob': '1999-01-01'‘��?\n对比之下，我们会清晰感受到，新哈希表中的空间利用率，相比于旧哈希表有大大的提升��?\n问题三：有关异常的困��? link第三个问题，是“不瘦到140不改名”同学提出的，对“NameError”异常的困惑。这是很常见的一个错误，我在这里也解释一下��?\n这个问题其实有点tricky，如果你查阅官方文档，会看到这么一句话”When an exception has been assigned using as target, it is cleared at the end of the except clause. ��?\n这句话意思是，如果你在异常处理的except block中，把异常赋予了一个变量，那么这个变量会在except block执行结束时被删除，相当于下面这样的表示：\ne = 1\rtry:\r1 / 0\rexcept ZeroDivisionError as e:\rtry:\rpass\rfinally:\rdel e 这里的e一开始指向整��?，但是在except block结束时被删除了（del e），所以程序执行就会抛出“NameError”的异常��?\n因此，这里提醒我们，在平时写代码时，一定要保证except中异常赋予的变量，在之后的语句中不再被用到��?\n问题四：关于多态和全局变量的修��? link最后的问题来自于farFlight同学，他提了两个问题��?\nPython自己判断类型的多态和子类继承的多态Polymorphism是否相同��? 函数内部不能直接��?=等修改全局变量，但是对于list全局变量，却可以使用append、extend之类修改，这是为什么呢? 我们分别来看这两个问题。对于第一个问题，要搞清楚多态的概念，多态是指有多种不同的形式。因此，判断类型的多态和子类继承的多态，在本质上都是一样的，只不过你可以把它们理解为多态的两种不同表现��?\n再来看第二个问题。当全局变量指向的对象不可变时，比如是整型、字符串等等，如果你尝试在函数内部改变它的值，却不加关键字global，就会抛出异常：\nx = 1\rdef func():\rx += 1\rfunc()\rx\r## 输出\rUnboundLocalError: local variable 'x' referenced before assignment 这是因为，程序默认函数内部的x是局部变量，而你没有为其赋值就直接引用，显然是不可行��?\n不过，如果全局变量指向的对象是可变的，比如是列表、字典等等，你就可以在函数内部修改它了：\nx = [1]\rdef func():\rx.append(2)\rfunc()\rx\r## 输出\r[1, 2] 当然，需要注意的是，这里的x.append(2)，并没有改变变量x，x依然指向原来的列表。事实上，这句话的意思是，访问x指向的列表，并在这个列表的末尾增��?��?\n今天主要回答这些问题，同时也欢迎你继续在留言区写下疑问和感想，我会持续不断地解答。希望每一次的留言和答疑，都能给你带来新的收获和价值��?\n以上，思维比较发散，说得不对还望指出��?/p\u003e2019-06-1318646333118 👍��?��?💬��?��?p\u003e辛苦老师，希望能用更通俗的语言或者例子来帮助我们这帮菜鸟理解哈哈，有的时候感觉老师明白，但是编辑成文字总是差一��?��?/p\u003e2019-06-11xavier 👍��?��?💬��?��?p\u003e对于我这种野生程序员来说，收获颇多。每一篇都是从基础开始，然后循序渐进。感谢老师��?/p\u003e2019-07-11Geek_d848f7 👍��?��?💬��?��?p\u003e 老师，原谅我还是不太理解��?点吧\n列表分配大小时，遵循下面模式��?��?��?…，我看源代码的确这样，但是怎么算都对不上，求指导； 哈希的存储怎么知道是如图形式呢？尤其是无元素位置，这个位置为啥要分配呢��?/p\u003e2019-06-10隰有��?/span\u003e 👍��?��?💬��?��?p\u003e不太明白为什么新哈希表的结构��? Indices None | index | None | None | index | None | Entries 这种形式?\nNone和index的排列有什么规则吗？为什么会有None? 2019-08-23瞳梦 👍��?��?💬��?��?p\u003elist的append()并不是一个赋值操作，不会去定义新的变量。而是会根据LEGB规则去寻找list这个变量��?/p\u003e2019-07-08me 👍��?��?💬��?��?p\u003ex = 1 def func(): x += 1 func() 报错,分析原因: (从两个角度分��? 1\u003e 从右往��? 先要明白赋值操作的一个概��? 被赋��?被引用； 再来看函数体内的 x += 1, 本质上就是x = x + 1 (扩展一��?若x是列��?x+=[1] 等同��?x.extend() 原地改变, 但放在此处依旧会报错, 报错原因��?x+=1同理) 继续分析, x = x + 1，右边的x变量在函数体里没有找��?在函数体里没有定义此变量),就去全局作用域里��? 找到��? 右边的值最终为2.. 重点来了, 记住python在作用域里对变量的赋值操作规��? 在函数体��?若对某一变量未定��?对其赋值视为在函数体里定义了该变量; 在函数体��?若对某一变量已经定义,对其赋值视为修改该变量的��? 这里左边的x变量在函数体里未定义,那么按照规则会定义一个局部变量x,但右边的x是全局变量… 冲突��? 2\u003e 从左往��? 根据报错的角度分��?是因为函数体里无x变量,赋值操作是定义该x变量,而赋值语句中又有还没有定义好的x变量)2022-09-13catshitfive 👍��?��?💬��?��?p\u003e有几个地方不是很懂请老师能否说明一下： (1)python中的list数据结构本质上是array,但是list多用来进行增删改的操作，岂不是没有链表结构时间复杂度低？还是说有什么优化？(2)list中存储的是指��?存储每个不可变元素对象的地址)，我用id()查看了每个指针内存储的地址，发现是连续的，但是地址都相��?2，如何理��?2个这个数字，��?2bytes? list除了存储的是指针，那么它的空间内还存储了指针指向的那些元素吗��?3)指针本身是一块内存，那么指针对应自己本身的地址如何知晓��?/p\u003e2019-06-11KaitoShy 👍��?��?💬��?��?p\u003e怎么得上面的存储方式的？和hash存储有关么？还是python实现的造成的？2019-06-10程序员人��?/span\u003e 👍��?��?💬��?��?p\u003e想问一下Mr King，问��?我在pycharm中执行了一下没报错啊？2019-06-10Geek_145846 👍��?��?💬��?��?p\u003e想学学Python 没想到还要重新拾��?C ++，学海无涯苦作舟的感��?��?/p\u003e2022-04-25\n"
            }
        );
    index.add(
            {
                id:  11 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/17---%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8\/",
                title: "17 - 强大的装饰器",
                description: "你好，我是景霄。这节课，我们一起来学习装饰器��?\n装饰器一直以来都是Python中很有用、很经典的一个feature，在工程中的应用也十分广泛，比如日志、缓存等等的任务都会用到。然而，在平常工作生活中，我发现不少人，尤其是初学者，常常因为其相对复杂的表示，对装饰器望而生畏，认为它“too fancy to learn”，实际并不如此��?\n今天这节课，我会以前面所讲的函数、闭包为切入点，引出装饰器的概念、表达和基本用法，最后，再通过实际工程中的例子，让你再次加深理解��?\n接下来，让我们进入正文一起学习吧��?\n函数-\u003e装饰��? link函数核心回顾 link引入装饰器之前，我们首先一起来复习一下，必须掌握的函数的几个核心概念��?\n第一点，我们要知道，在Python中，函数是一等公民（first-class citizen），函数也是对象。我们可以把函数赋予变量，比如下面这段代码：\ndef func(message):\rprint('Got a message: {}'.format(message))\rsend_message = func\rsend_message('hello world')\r# 输出\rGot a message: hello world 这个例子中，我们把函数func赋予了变量send_message，这样之后你调用send_message，就相当于是调用函数func()��?\n第二点，我们可以把函数当作参数，传入另一个函数中，比如下面这段代码：\ndef get_message(message):\rreturn 'Got a message: ' + message\rdef root_call(func, message):\rprint(func(message))\rroot_call(get_message, 'hello world')\r# 输出\rGot a message: hello world 这个例子中，我们就把函数get_message以参数的形式，传入了函数root_call()中然后调用它��?\n第三点，我们可以在函数里定义函数，也就是函数的嵌套。这里我同样举了一个例子：\n",
                content: "你好，我是景霄。这节课，我们一起来学习装饰器��?\n装饰器一直以来都是Python中很有用、很经典的一个feature，在工程中的应用也十分广泛，比如日志、缓存等等的任务都会用到。然而，在平常工作生活中，我发现不少人，尤其是初学者，常常因为其相对复杂的表示，对装饰器望而生畏，认为它“too fancy to learn”，实际并不如此��?\n今天这节课，我会以前面所讲的函数、闭包为切入点，引出装饰器的概念、表达和基本用法，最后，再通过实际工程中的例子，让你再次加深理解��?\n接下来，让我们进入正文一起学习吧��?\n函数-\u003e装饰��? link函数核心回顾 link引入装饰器之前，我们首先一起来复习一下，必须掌握的函数的几个核心概念��?\n第一点，我们要知道，在Python中，函数是一等公民（first-class citizen），函数也是对象。我们可以把函数赋予变量，比如下面这段代码：\ndef func(message):\rprint('Got a message: {}'.format(message))\rsend_message = func\rsend_message('hello world')\r# 输出\rGot a message: hello world 这个例子中，我们把函数func赋予了变量send_message，这样之后你调用send_message，就相当于是调用函数func()��?\n第二点，我们可以把函数当作参数，传入另一个函数中，比如下面这段代码：\ndef get_message(message):\rreturn 'Got a message: ' + message\rdef root_call(func, message):\rprint(func(message))\rroot_call(get_message, 'hello world')\r# 输出\rGot a message: hello world 这个例子中，我们就把函数get_message以参数的形式，传入了函数root_call()中然后调用它��?\n第三点，我们可以在函数里定义函数，也就是函数的嵌套。这里我同样举了一个例子：\ndef func(message):\rdef get_message(message):\rprint('Got a message: {}'.format(message))\rreturn get_message(message)\rfunc('hello world')\r# 输出\rGot a message: hello world 这段代码中，我们在函数func()里又定义了新的函数get_message()，调用后作为func()的返回值返回��?\n第四点，要知道，函数的返回值也可以是函数对象（闭包），比如下面这个例子��?\ndef func_closure():\rdef get_message(message):\rprint('Got a message: {}'.format(message))\rreturn get_message\rsend_message = func_closure()\rsend_message('hello world')\r# 输出\rGot a message: hello world 这里，函数func_closure()的返回值是函数对象get_message本身，之后，我们将其赋予变量send_message，再调用send_message(‘hello world��?，最后输出了'Got a message: hello world'��?\n简单的装饰��? link简单的复习之后，我们接下来学习今天的新知识——装饰器。按照习惯，我们可以先来看一个装饰器的简单例子：\ndef my_decorator(func):\rdef wrapper():\rprint('wrapper of decorator')\rfunc()\rreturn wrapper\rdef greet():\rprint('hello world')\rgreet = my_decorator(greet)\rgreet()\r# 输出\rwrapper of decorator\rhello world 这段代码中，变量greet指向了内部函数wrapper()，而内部函数wrapper()中又会调用原函数greet()，因此，最后调用greet()时，就会先打印'wrapper of decorator'，然后输出'hello world'��?\n这里的函数my_decorator()就是一个装饰器，它把真正需要执行的函数greet()包裹在其中，并且改变了它的行为，但是原函数greet()不变��?\n事实上，上述代码在Python中有更简单、更优雅的表示：\ndef my_decorator(func):\rdef wrapper():\rprint('wrapper of decorator')\rfunc()\rreturn wrapper\r@my_decorator\rdef greet():\rprint('hello world')\rgreet() 这里的@，我们称之为语法糖，@my_decorator就相当于前面的greet=my_decorator(greet)语句，只不过更加简洁。因此，如果你的程序中有其它函数需要做类似的装饰，你只需在它们的上方加上@decorator就可以了，这样就大大提高了函数的重复利用和程序的可读性��?\n带有参数的装饰器 link你或许会想到，如果原函数greet()中，有参数需要传递给装饰器怎么办？\n一个简单的办法，是可以在对应的装饰器函数wrapper()上，加上相应的参数，比如��?\ndef my_decorator(func):\rdef wrapper(message):\rprint('wrapper of decorator')\rfunc(message)\rreturn wrapper\r@my_decorator\rdef greet(message):\rprint(message)\rgreet('hello world')\r# 输出\rwrapper of decorator\rhello world 不过，新的问题来了。如果我另外还有一个函数，也需要使用my_decorator()装饰器，但是这个新的函数有两个参数，又该怎么办呢？比如：\n@my_decorator\rdef celebrate(name, message):\r... 事实上，通常情况下，我们会把*args和**kwargs，作为装饰器内部函数wrapper()的参数。*args和**kwargs，表示接受任意数量和类型的参数，因此装饰器就可以写成下面的形式：\ndef my_decorator(func):\rdef wrapper(*args, **kwargs):\rprint('wrapper of decorator')\rfunc(*args, **kwargs)\rreturn wrapper 带有自定义参数的装饰��? link其实，装饰器还有更大程度的灵活性。刚刚说了，装饰器可以接受原函数任意类型和数量的参数，除此之外，它还可以接受自己定义的参数��?\n举个例子，比如我想要定义一个参数，来表示装饰器内部函数被执行的次数，那么就可以写成下面这种形式��?\ndef repeat(num):\rdef my_decorator(func):\rdef wrapper(*args, **kwargs):\rfor i in range(num):\rprint('wrapper of decorator')\rfunc(*args, **kwargs)\rreturn wrapper\rreturn my_decorator\r@repeat(4)\rdef greet(message):\rprint(message)\rgreet('hello world')\r# 输出��?\rwrapper of decorator\rhello world\rwrapper of decorator\rhello world\rwrapper of decorator\rhello world\rwrapper of decorator\rhello world 原函数还是原函数吗？ link现在，我们再来看个有趣的现象。还是之前的例子，我们试着打印出greet()函数的一些元信息��?\ngreet.__name__\r## 输出\r'wrapper'\rhelp(greet)\r# 输出\rHelp on function wrapper in module __main__:\rwrapper(*args, **kwargs) 你会发现，greet()函数被装饰以后，它的元信息变了。元信息告诉我们“它不再是以前的那个greet()函数，而是被wrapper()函数取代了”��?\n为了解决这个问题，我们通常使用内置的装饰器@functools.wrap，它会帮助保留原函数的元信息（也就是将原函数的元信息，拷贝到对应的装饰器函数里）��?\nimport functools\rdef my_decorator(func):\r@functools.wraps(func)\rdef wrapper(*args, **kwargs):\rprint('wrapper of decorator')\rfunc(*args, **kwargs)\rreturn wrapper\r@my_decorator\rdef greet(message):\rprint(message)\rgreet.__name__\r# 输出\r'greet' 类装饰器 link前面我们主要讲了函数作为装饰器的用法，实际上，类也可以作为装饰器。类装饰器主要依赖于函数__call__()，每当你调用一个类的示例时，函数__call__()就会被执行一次��?\n我们来看下面这段代码��?\nclass Count:\rdef __init__(self, func):\rself.func = func\rself.num_calls = 0\rdef __call__(self, *args, **kwargs):\rself.num_calls += 1\rprint('num of calls is: {}'.format(self.num_calls))\rreturn self.func(*args, **kwargs)\r@Count\rdef example():\rprint(\"hello world\")\rexample()\r# 输出\rnum of calls is: 1\rhello world\rexample()\r# 输出\rnum of calls is: 2\rhello world\r... 这里，我们定义了类Count，初始化时传入原函数func()，而__call__()函数表示让变量num_calls自增1，然后打印，并且调用原函数。因此，在我们第一次调用函数example()时，num_calls的值是1，而在第二次调用时，它的值变成了2��?\n装饰器的嵌套 link回顾刚刚讲的例子，基本都是一个装饰器的情况，但实际上，Python也支持多个装饰器，比如写成下面这样的形式��?\n@decorator1\r@decorator2\r@decorator3\rdef func():\r... 它的执行顺序从里到外，所以上面的语句也等效于下面这行代码��?\ndecorator1(decorator2(decorator3(func))) 这样，'hello world'这个例子，就可以改写成下面这样：\nimport functools\rdef my_decorator1(func):\r@functools.wraps(func)\rdef wrapper(*args, **kwargs):\rprint('execute decorator1')\rfunc(*args, **kwargs)\rreturn wrapper\rdef my_decorator2(func):\r@functools.wraps(func)\rdef wrapper(*args, **kwargs):\rprint('execute decorator2')\rfunc(*args, **kwargs)\rreturn wrapper\r@my_decorator1\r@my_decorator2\rdef greet(message):\rprint(message)\rgreet('hello world')\r# 输出\rexecute decorator1\rexecute decorator2\rhello world 装饰器用法实��? link到此，装饰器的基本概念及用法我就讲完了，接下来，我将结合实际工作中的几个例子，带你加深对它的理解��?\n身份认证 link首先是最常见的身份认证的应用。这个很容易理解，举个最常见的例子，你登录微信，需要输入用户名密码，然后点击确认，这样，服务器端便会查询你的用户名是否存在、是否和密码匹配等等。如果认证通过，你就可以顺利登录；如果不通过，就抛出异常并提示你登录失败��?\n再比如一些网站，你不登录也可以浏览内容，但如果你想要发布文章或留言，在点击发布时，服务器端便会查询你是否登录。如果没有登录，就不允许这项操作等等��?\n我们来看一个大概的代码示例��?\nimport functools\rdef authenticate(func):\r@functools.wraps(func)\rdef wrapper(*args, **kwargs):\rrequest = args[0]\rif check_user_logged_in(request): # 如果用户处于登录状��?\rreturn func(*args, **kwargs) # 执行函数post_comment() else:\rraise Exception('Authentication failed')\rreturn wrapper\r@authenticate\rdef post_comment(request, ...)\r...\r这段代码中，我们定义了装饰器authenticate；而函数post_comment()，则表示发表用户对某篇文章的评论。每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许��?\n日志记录 link日志记录同样是很常见的一个案例。在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的latency（延迟）增加，所以想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段��?\n我们通常用下面的方法来表示：\nimport time\rimport functools\rdef log_execution_time(func):\r@functools.wraps(func)\rdef wrapper(*args, **kwargs):\rstart = time.perf_counter()\rres = func(*args, **kwargs)\rend = time.perf_counter()\rprint('{} took {} ms'.format(func.__name__, (end - start) * 1000))\rreturn res\rreturn wrapper\r@log_execution_time\rdef calculate_similarity(items):\r... 这里，装饰器log_execution_time记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上@log_execution_time即可��?\n输入合理性检��? link再来看今天要讲的第三个应用，输入合理性检查��?\n在大型公司的机器学习框架中，我们调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的JSON文件）进行合理性检查。这样就可以大大避免，输入不正确对机器造成的巨大开销��?\n它的写法往往是下面的格式��?\nimport functools\rdef validation_check(input):\r@functools.wraps(func)\rdef wrapper(*args, **kwargs): ... # 检查输入是否合��?\r@validation_check\rdef neural_network_training(param1, param2, ...):\r... 其实在工作中，很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现��?\n试想一下，如果没有输入的合理性检查，很容易出现“模型训练了好几个小时后，系统却报错说输入的一个参数不对，成果付之一炬”的现象。这样的“惨案”，大大减缓了开发效率，也对机器资源造成了巨大浪费��?\n缓存 link最后，我们来看缓存方面的应用。关于缓存装饰器的用法，其实十分常见，这里我以Python内置的LRU cache为例来说明（如果你不了解 LRU cache，可以点击链接自行查阅）��?\nLRU cache，在Python中的表示形式是@lru_cache。@lru_cache会缓存进程中的函数参数和结果，当缓存满了以后，会删除least recenly used 的数据��?\n正确使用缓存装饰器，往往能极大地提高程序运行效率。为什么呢？我举一个常见的例子来说明��?\n大型公司服务器端的代码中往往存在很多关于设备的检查，比如你使用的设备是安卓还是iPhone，版本号是多少。这其中的一个原因，就是一些新的feature，往往只在某些特定的手机系统或版本上才有（比如Android v200+）��?\n这样一来，我们通常使用缓存装饰器，来包裹这些检查函数，避免其被反复调用，进而提高程序运行效率，比如写成下面这样��?\n@lru_cache\rdef check(param1, param2, ...) # 检查用户设备类型，版本号等��?\r... 总结 link这节课，我们一起学习了装饰器的概念及用法��?所谓的装饰器，其实就是通过装饰器函数，来修改原函数的一些功能，使得原函数不需要修改��?\nDecorators is to modify the behavior of the function through a wrapper so we don’t have to actually modify the function.\n而实际工作中，装饰器通常运用在身份认证、日志记录、输入合理性检查以及缓存等多个领域中。合理使用装饰器，往往能极大地提高程序的可读性以及运行效率��?\n思考题 link那么，你平时工作中，通常会在哪些情况下使用装饰器呢？欢迎留言和我讨论，也欢迎你把这篇文章分享给你的同事、朋友，一起在交流中进步��?\n我尝试如下会报错��? ��?点：send_message = func() ��?点：send_message = func_closure\n想知道这是哪一个知识点，谢��?/p\u003e2019-06-17吴星 👍��?2��?💬��?2��?p\u003e请教下，为什么count那儿是单例模式吗？为什么二次执行会��?��?/p\u003e2019-06-17被炸的油��?/span\u003e 👍��?��?💬��?��?p\u003e工作当中，如果是二次开发，在原来的需求基础之上做优化，原逻辑不需要修改的情况下，只需增加新的业务场景的时候，感觉用装饰器挺好的。不动原来的逻辑，增加程序的健壮性��?/p\u003e2019-09-22farFlight 👍��?��?💬��?��?p\u003e请问一下，lru cache不是应该删除最久没有访问的内容吗��?/p\u003e2019-06-17🇨🇳 👍��?��?💬��?��?p\u003e1、总结中，倒数第二行发现错别字（程序）不是程度��? 2、类装饰器在实际中有哪些应用场景��?/p\u003e2019-06-17geraltlaush 👍��?��?💬��?��?p\u003e我之前开发过微服务脚手架，跟装饰器模式很像，就是rpc调用之前，把限流，上报，统计耗时统计在前面，每个功能还可以自由选择执行的时机，跟业务功能分离，开发关注于业务研发就行��?/p\u003e2019-11-07enjoylearning 👍��?��?💬��?��?p\u003e还有类装饰器，又长见识了，最近正愁参数校验放哪里，参照本文终于开窍了2019-06-17向南 👍��?��?💬��?��?p\u003e装饰器本质上是一��?Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函��?#47;类对象��? 它经常用于有特定需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计��? 有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能��? 装饰器并没有修改原函数，或者说装饰器并没有修改原函数的功能，而为其新增其他功能��?/p\u003e2020-03-08Hoo-Ah 👍��?��?💬��?��?p\u003e目前工作中使用的是tornado框架，里面依赖tornado.gen.coroutine这个装饰器用来将被装饰的函数变为协程，这样就可以将代码的执行变为异步非阻塞，提高程序的并发量��?/p\u003e2019-06-17Jadm 👍��?��?💬��?��?p\u003e老师能不能多出点课程，讲的太好了🤠🤠2020-06-14Ray 👍��?��?💬��?��?p\u003e老师，类装饰器的那个代码中，example是不是变成了Count类一个对象？ 我通过type(example)，返回的是class 'main.Count'2020-02-22大懒��?/span\u003e 👍��?��?💬��?��?p\u003e终于彻底理解了装饰器，感谢老师😄2020-01-11舍予 👍��?��?💬��?��?p\u003e老师，装饰器的作用是不是也可以用函数封装来实现？2019-12-11Defensor 👍��?��?💬��?��?p\u003e老师 能讲解下warpper函数里的return��?我看前面的案例没有return 但是后面有返回func的有返回func结果��?就有点乱��?如果原函数本身需要返回值呢��?/p\u003e2019-12-05\n"
            }
        );
    index.add(
            {
                id:  12 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/20---%E6%8F%AD%E7%A7%98-python-%E5%8D%8F%E7%A8%8B\/",
                title: "20 - 揭秘 Python 协程",
                description: "你好，我是景霄��?\n上一节课的最后，我们留下一个小小的悬念：生成器��?Python 2 中还扮演了一个重要角色，就是用来实现 Python 协程��?\n那么首先你要明白，什么是协程��?\n协程是实现并发编程的一种方式。一说并发，你肯定想到了多线��?多进程模型，没错，多线程/多进程，正是解决并发问题的经典模型之一。最初的互联网世界，多线��?多进程在服务器并发中，起到举足轻重的作用��?\n随着互联网的快速发展，你逐渐遇到��?C10K 瓶颈，也就是同时连接到服务器的客户达到了一万个。于是很多代码跑崩了，进程上下文切换占用了大量的资源，线程也顶不住如此巨大的压力，这时， NGINX 带着事件循环出来拯救世界了��?\n如果将多进程/多线程类比为起源于唐朝的藩镇割据，那么事件循环，就是宋朝加强的中央集权制。事件循环启动一个统一的调度器，让调度器来决定一个时刻去运行哪个任务，于是省却了多线程中启动线程、管理线程、同步锁等各种开销。同一时期��?NGINX，在高并发下能保持低资源低消耗高性能，相��?Apache 也支持更多的并发连接��?\n再到后来，出现了一个很有名的名词，叫做回调地狱（callback hell），手撸��?JavaScript 的朋友肯定知道我在说什么。我们大家惊喜地发现，这种工具完美地继承了事件循环的优越性，同时还能提供 async / await 语法糖，解决了执行性和可读性共存的难题。于是，协程逐渐被更多人发现并看好，也有越来越多的人尝试��?Node.js 做起了后端开发。（讲个笑话，JavaScript 是一门编程语言。）\n回到我们��?Python。使用生成器，是 Python 2 开头的时代实现协程的老方法了，Python 3.7 提供了新的基��?asyncio ��?async / await 的方法。我们这节课，同样的，跟随时代，抛弃掉不容易理解、也不容易写的旧的基于生成器的方法，直接来讲新方法��?\n我们先从一个爬虫实例出发，用清晰的讲解思路，带你结合实战来搞懂这个不算特别容易理解的概念。之后，我们再由浅入深，直击协程的核心��?\n从一个爬虫说��? link爬虫，就是互联网的蜘蛛，在搜索引擎诞生之时，与其一同来到世上。爬虫每秒钟都会爬取大量的网页，提取关键信息后存储在数据库中，以便日后分析。爬虫有非常简单的 Python 十行代码实现，也��?Google 那样的全球分布式爬虫的上百万行代码，分布在内部上万台服务器上，对全世界的信息进行嗅探��?\n话不多说，我们先看一个简单的爬虫例子��?\nimport time\rdef crawl_page(url):\rprint('crawling {}'.format(url))\rsleep_time = int(url.split('_')[-1])\rtime.sleep(sleep_time)\rprint('OK {}'.format(url))\rdef main(urls):\rfor url in urls:\rcrawl_page(url)\r%time main(['url_1', 'url_2', 'url_3', 'url_4'])\r########## 输出 ##########\rcrawling url_1\rOK url_1\rcrawling url_2\rOK url_2\rcrawling url_3\rOK url_3\rcrawling url_4\rOK url_4\rWall time: 10 s （注意：本节的主要目的是协程的基础概念，因此我们简化爬虫的 scrawl_page 函数为休眠数秒，休眠时间取决��?url 最后的那个数字。）\n",
                content: "你好，我是景霄��?\n上一节课的最后，我们留下一个小小的悬念：生成器��?Python 2 中还扮演了一个重要角色，就是用来实现 Python 协程��?\n那么首先你要明白，什么是协程��?\n协程是实现并发编程的一种方式。一说并发，你肯定想到了多线��?多进程模型，没错，多线程/多进程，正是解决并发问题的经典模型之一。最初的互联网世界，多线��?多进程在服务器并发中，起到举足轻重的作用��?\n随着互联网的快速发展，你逐渐遇到��?C10K 瓶颈，也就是同时连接到服务器的客户达到了一万个。于是很多代码跑崩了，进程上下文切换占用了大量的资源，线程也顶不住如此巨大的压力，这时， NGINX 带着事件循环出来拯救世界了��?\n如果将多进程/多线程类比为起源于唐朝的藩镇割据，那么事件循环，就是宋朝加强的中央集权制。事件循环启动一个统一的调度器，让调度器来决定一个时刻去运行哪个任务，于是省却了多线程中启动线程、管理线程、同步锁等各种开销。同一时期��?NGINX，在高并发下能保持低资源低消耗高性能，相��?Apache 也支持更多的并发连接��?\n再到后来，出现了一个很有名的名词，叫做回调地狱（callback hell），手撸��?JavaScript 的朋友肯定知道我在说什么。我们大家惊喜地发现，这种工具完美地继承了事件循环的优越性，同时还能提供 async / await 语法糖，解决了执行性和可读性共存的难题。于是，协程逐渐被更多人发现并看好，也有越来越多的人尝试��?Node.js 做起了后端开发。（讲个笑话，JavaScript 是一门编程语言。）\n回到我们��?Python。使用生成器，是 Python 2 开头的时代实现协程的老方法了，Python 3.7 提供了新的基��?asyncio ��?async / await 的方法。我们这节课，同样的，跟随时代，抛弃掉不容易理解、也不容易写的旧的基于生成器的方法，直接来讲新方法��?\n我们先从一个爬虫实例出发，用清晰的讲解思路，带你结合实战来搞懂这个不算特别容易理解的概念。之后，我们再由浅入深，直击协程的核心��?\n从一个爬虫说��? link爬虫，就是互联网的蜘蛛，在搜索引擎诞生之时，与其一同来到世上。爬虫每秒钟都会爬取大量的网页，提取关键信息后存储在数据库中，以便日后分析。爬虫有非常简单的 Python 十行代码实现，也��?Google 那样的全球分布式爬虫的上百万行代码，分布在内部上万台服务器上，对全世界的信息进行嗅探��?\n话不多说，我们先看一个简单的爬虫例子��?\nimport time\rdef crawl_page(url):\rprint('crawling {}'.format(url))\rsleep_time = int(url.split('_')[-1])\rtime.sleep(sleep_time)\rprint('OK {}'.format(url))\rdef main(urls):\rfor url in urls:\rcrawl_page(url)\r%time main(['url_1', 'url_2', 'url_3', 'url_4'])\r########## 输出 ##########\rcrawling url_1\rOK url_1\rcrawling url_2\rOK url_2\rcrawling url_3\rOK url_3\rcrawling url_4\rOK url_4\rWall time: 10 s （注意：本节的主要目的是协程的基础概念，因此我们简化爬虫的 scrawl_page 函数为休眠数秒，休眠时间取决��?url 最后的那个数字。）\n这是一个很简单的爬虫，main() 函数执行时，调取 crawl_page() 函数进行网络通信，经过若干秒等待后收到结果，然后执行下一个��?\n看起来很简单，但你仔细一算，它也占用了不少时间，五个页面分别用了 1 秒到 4 秒的时间，加起来一共用��?10 秒。这显然效率低下，该怎么优化呢？\n于是，一个很简单的思路出现了——我们这种爬取操作，完全可以并发化。我们就来看看使用协程怎么写��?\nimport asyncio\rasync def crawl_page(url):\rprint('crawling {}'.format(url))\rsleep_time = int(url.split('_')[-1])\rawait asyncio.sleep(sleep_time)\rprint('OK {}'.format(url))\rasync def main(urls):\rfor url in urls:\rawait crawl_page(url)\r%time asyncio.run(main(['url_1', 'url_2', 'url_3', 'url_4']))\r########## 输出 ##########\rcrawling url_1\rOK url_1\rcrawling url_2\rOK url_2\rcrawling url_3\rOK url_3\rcrawling url_4\rOK url_4\rWall time: 10 s 看到这段代码，你应该发现了，��?Python 3.7 以上版本中，使用协程写异步程序非常简单��?\n首先来看 import asyncio，这个库包含了大部分我们实现协程所需的魔法工具��?\nasync 修饰词声明异步函数，于是，这里的 crawl_page ��?main 都变成了异步函数。而调用异步函数，我们便可得到一个协程对象（coroutine object）��?\n举个例子，如果你 print(crawl_page(''))，便会输出，提示你这是一��?Python 的协程对象，而并不会真正执行这个函数��?\n再来说说协程的执行。执行协程有多种方法，这里我介绍一下常用的三种��?\n首先，我们可以通过 await 来调用。await 执行的效果，��?Python 正常执行是一样的，也就是说程序会阻塞在这里，进入被调用的协程函数，执行完毕返回后再继续，而这也是 await 的字面意思。代码中 await asyncio.sleep(sleep_time) 会在这里休息若干秒，await crawl_page(url) 则会执行 crawl_page() 函数��?\n其次，我们可以通过 asyncio.create_task() 来创建任务，这个我们下节课会详细讲一下，你先简单知道即可��?\n最后，我们需��?asyncio.run 来触发运行。asyncio.run 这个函数��?Python 3.7 之后才有的特性，可以��?Python 的协程接口变得非常简单，你不用去理会事件循环怎么定义和怎么使用的问题（我们会在下面讲）。一个非常好的编程规范是，asyncio.run(main()) 作为主程序的入口函数，在程序运行周期内，只调用一��?asyncio.run��?\n这样，你就大概看懂了协程是怎么用的吧。不妨试着跑一下代码，欸，怎么还是 10 秒？\n10 秒就对了，还记得上面所说的，await 是同步调用，因此��?crawl_page(url) 在当前的调用结束之前，是不会触发下一次调用的。于是，这个代码效果就和上面完全一样了，相当于我们用异步接口写了个同步代码��?\n现在又该怎么办呢��?\n其实很简单，也正是我接下来要讲的协程中的一个重要概念，任务（Task）。老规矩，先看代码��?\nimport asyncio\rasync def crawl_page(url):\rprint('crawling {}'.format(url))\rsleep_time = int(url.split('_')[-1])\rawait asyncio.sleep(sleep_time)\rprint('OK {}'.format(url))\rasync def main(urls):\rtasks = [asyncio.create_task(crawl_page(url)) for url in urls]\rfor task in tasks:\rawait task\r%time asyncio.run(main(['url_1', 'url_2', 'url_3', 'url_4']))\r########## 输出 ##########\rcrawling url_1\rcrawling url_2\rcrawling url_3\rcrawling url_4\rOK url_1\rOK url_2\rOK url_3\rOK url_4\rWall time: 3.99 s 你可以看到，我们有了协程对象后，便可以通过 asyncio.create_task 来创建任务。任务创建后很快就会被调度执行，这样，我们的代码也不会阻塞在任务这里。所以，我们要等所有任务都结束才行，用for task in tasks: await task 即可��?\n这次，你就看到效果了吧，结果显示，运行总时长等于运行时间最长的爬虫��?\n当然，你也可以想一想，这里用多线程应该怎么写？而如果需要爬取的页面有上万个又该怎么办呢？再对比下协程的写法，谁更清晰自是一目了然��?\n其实，对于执��?tasks，还有另一种做法：\nimport asyncio\rasync def crawl_page(url):\rprint('crawling {}'.format(url))\rsleep_time = int(url.split('_')[-1])\rawait asyncio.sleep(sleep_time)\rprint('OK {}'.format(url))\rasync def main(urls):\rtasks = [asyncio.create_task(crawl_page(url)) for url in urls]\rawait asyncio.gather(*tasks)\r%time asyncio.run(main(['url_1', 'url_2', 'url_3', 'url_4']))\r########## 输出 ##########\rcrawling url_1\rcrawling url_2\rcrawling url_3\rcrawling url_4\rOK url_1\rOK url_2\rOK url_3\rOK url_4\rWall time: 4.01 s 这里的代码也很好理解。唯一要注意的是，*tasks 解包列表，将列表变成了函数的参数；与之对应的是， ** dict 将字典变成了函数的参数��?\n另外，asyncio.create_task，asyncio.run 这些函数都是 Python 3.7 以上的版本才提供的，自然，相比于旧接口它们也更容易理解和阅读��?\n解密协程运行��? link说了这么多，现在，我们不妨来深入代码底层看看。有了前面的知识做基础，你应该很容易理解这两段代码��?\nimport asyncio\rasync def worker_1():\rprint('worker_1 start')\rawait asyncio.sleep(1)\rprint('worker_1 done')\rasync def worker_2():\rprint('worker_2 start')\rawait asyncio.sleep(2)\rprint('worker_2 done')\rasync def main():\rprint('before await')\rawait worker_1()\rprint('awaited worker_1')\rawait worker_2()\rprint('awaited worker_2')\r%time asyncio.run(main())\r########## 输出 ##########\rbefore await\rworker_1 start\rworker_1 done\rawaited worker_1\rworker_2 start\rworker_2 done\rawaited worker_2\rWall time: 3 s import asyncio\rasync def worker_1():\rprint('worker_1 start')\rawait asyncio.sleep(1)\rprint('worker_1 done')\rasync def worker_2():\rprint('worker_2 start')\rawait asyncio.sleep(2)\rprint('worker_2 done')\rasync def main():\rtask1 = asyncio.create_task(worker_1())\rtask2 = asyncio.create_task(worker_2())\rprint('before await')\rawait task1\rprint('awaited worker_1')\rawait task2\rprint('awaited worker_2')\r%time asyncio.run(main())\r########## 输出 ##########\rbefore await\rworker_1 start\rworker_2 start\rworker_1 done\rawaited worker_1\rworker_2 done\rawaited worker_2\rWall time: 2.01 s 不过，第二个代码，到底发生了什么呢？为了让你更详细了解到协程和线程的具体区别，这里我详细地分析了整个过程。步骤有点多，别着急，我们慢慢来看��?\nasyncio.run(main())，程序进��?main() 函数，事件循环开启； task1 ��?task2 任务被创建，并进入事件循环等待运行；运行��?print，输��?'before await'��? await task1 执行，用户选择从当前的主任务中切出，事件调度器开始调��?worker_1��? worker_1 开始运行，运行 print 输出'worker_1 start'，然后运行到 await asyncio.sleep(1)��?从当前任务切出，事件调度器开始调��?worker_2��? worker_2 开始运行，运行 print 输出 'worker_2 start'，然后运��?await asyncio.sleep(2) 从当前任务切出； 以上所有事件的运行时间，都应该��?1ms ��?10ms 之间，甚至可能更短，事件调度器从这个时候开始暂停调度； 一秒钟后，worker_1 ��?sleep 完成，事件调度器将控制权重新传给 task_1，输��?'worker_1 done'，task_1 完成任务，从事件循环中退出； await task1 完成，事件调度器将控制器传给主任务，输出 'awaited worker_1'，·然后在 await task2 处继续等待； 两秒钟后，worker_2 ��?sleep 完成，事件调度器将控制权重新传给 task_2，输��?'worker_2 done'，task_2 完成任务，从事件循环中退出； 主任务输��?'awaited worker_2'，协程全任务结束，事件循环结束��? 接下来，我们进阶一下。如果我们想给某些协程任务限定运行时间，一旦超时就取消，又该怎么做呢？再进一步，如果某些协程运行时出现错误，又该怎么处理呢？同样的，来看代码��?\nimport asyncio\rasync def worker_1():\rawait asyncio.sleep(1)\rreturn 1\rasync def worker_2():\rawait asyncio.sleep(2)\rreturn 2 / 0\rasync def worker_3():\rawait asyncio.sleep(3)\rreturn 3\rasync def main():\rtask_1 = asyncio.create_task(worker_1())\rtask_2 = asyncio.create_task(worker_2())\rtask_3 = asyncio.create_task(worker_3())\rawait asyncio.sleep(2)\rtask_3.cancel()\rres = await asyncio.gather(task_1, task_2, task_3, return_exceptions=True)\rprint(res)\r%time asyncio.run(main())\r########## 输出 ##########\r[1, ZeroDivisionError('division by zero'), CancelledError()]\rWall time: 2 s 你可以看到，worker_1 正常运行，worker_2 运行中出现错误，worker_3 执行时间过长被我��?cancel 掉了，这些信息会全部体现在最终的返回结果 res 中��?\n不过要注意return_exceptions=True这行代码。如果不设置这个参数，错误就会完整地 throw 到我们这个执行层，从而需��?try except 来捕捉，这也就意味着其他还没被执行的任务会被全部取消掉。为了避免这个局面，我们��?return_exceptions 设置��?True 即可��?\n到这里，发现了没，线程能实现的，协程都能做到。那就让我们温习一下这些知识点，用协程来实现一个经典的生产者消费者模型吧��?\nimport asyncio\rimport random\rasync def consumer(queue, id):\rwhile True:\rval = await queue.get()\rprint('{} get a val: {}'.format(id, val))\rawait asyncio.sleep(1)\rasync def producer(queue, id):\rfor i in range(5):\rval = random.randint(1, 10)\rawait queue.put(val)\rprint('{} put a val: {}'.format(id, val))\rawait asyncio.sleep(1)\rasync def main():\rqueue = asyncio.Queue()\rconsumer_1 = asyncio.create_task(consumer(queue, 'consumer_1'))\rconsumer_2 = asyncio.create_task(consumer(queue, 'consumer_2'))\rproducer_1 = asyncio.create_task(producer(queue, 'producer_1'))\rproducer_2 = asyncio.create_task(producer(queue, 'producer_2'))\rawait asyncio.sleep(10)\rconsumer_1.cancel()\rconsumer_2.cancel()\rawait asyncio.gather(consumer_1, consumer_2, producer_1, producer_2, return_exceptions=True)\r%time asyncio.run(main())\r########## 输出 ##########\rproducer_1 put a val: 5\rproducer_2 put a val: 3\rconsumer_1 get a val: 5\rconsumer_2 get a val: 3\rproducer_1 put a val: 1\rproducer_2 put a val: 3\rconsumer_2 get a val: 1\rconsumer_1 get a val: 3\rproducer_1 put a val: 6\rproducer_2 put a val: 10\rconsumer_1 get a val: 6\rconsumer_2 get a val: 10\rproducer_1 put a val: 4\rproducer_2 put a val: 5\rconsumer_2 get a val: 4\rconsumer_1 get a val: 5\rproducer_1 put a val: 2\rproducer_2 put a val: 8\rconsumer_1 get a val: 2\rconsumer_2 get a val: 8\rWall time: 10 s 实战：豆瓣近日推荐电影爬��? link最后，进入今天的实战环节——实现一个完整的协程爬虫��?\n任务描述：https://movie.douban.com/cinema/later/beijing/ 这个页面描述了北京最近上映的电影，你能否通过 Python 得到这些电影的名称、上映时间和海报呢？这个页面的海报是缩小版的，我希望你能从具体的电影描述页面中抓取到海报��?\n听起来难度不是很大吧？我在下面给出了同步版本的代码和协程版本的代码，通过运行时间和代码写法的对比，希望你能对协程有更深的了解。（注意：为了突出重点、简化代码，这里我省略了异常处理。）\n不过，在参考我给出的代码之前，你是不是可以自己先动手写一下、跑一下呢��?\nimport requests\rfrom bs4 import BeautifulSoup\rdef main():\rurl = \"https://movie.douban.com/cinema/later/beijing/\"\rinit_page = requests.get(url).content\rinit_soup = BeautifulSoup(init_page, 'lxml')\rall_movies = init_soup.find('div', id=\"showing-soon\")\rfor each_movie in all_movies.find_all('div', class_=\"item\"):\rall_a_tag = each_movie.find_all('a')\rall_li_tag = each_movie.find_all('li')\rmovie_name = all_a_tag[1].text\rurl_to_fetch = all_a_tag[1]['href']\rmovie_date = all_li_tag[0].text\rresponse_item = requests.get(url_to_fetch).content\rsoup_item = BeautifulSoup(response_item, 'lxml')\rimg_tag = soup_item.find('img')\rprint('{} {} {}'.format(movie_name, movie_date, img_tag['src']))\r%time main()\r########## 输出 ##########\r阿拉��?05��?4��?https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2553992741.jpg\r龙珠超：布罗��?05��?4��?https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2557371503.jpg\r五月天人生无限公��?05��?4��?https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2554324453.jpg\r... ...\r直播攻略 06��?4��?https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2555957974.jpg\rWall time: 56.6 s import asyncio\rimport aiohttp\rfrom bs4 import BeautifulSoup\rasync def fetch_content(url):\rasync with aiohttp.ClientSession(\rheaders=header, connector=aiohttp.TCPConnector(ssl=False)\r) as session:\rasync with session.get(url) as response:\rreturn await response.text()\rasync def main():\rurl = \"https://movie.douban.com/cinema/later/beijing/\"\rinit_page = await fetch_content(url)\rinit_soup = BeautifulSoup(init_page, 'lxml')\rmovie_names, urls_to_fetch, movie_dates = [], [], []\rall_movies = init_soup.find('div', id=\"showing-soon\")\rfor each_movie in all_movies.find_all('div', class_=\"item\"):\rall_a_tag = each_movie.find_all('a')\rall_li_tag = each_movie.find_all('li')\rmovie_names.append(all_a_tag[1].text)\rurls_to_fetch.append(all_a_tag[1]['href'])\rmovie_dates.append(all_li_tag[0].text)\rtasks = [fetch_content(url) for url in urls_to_fetch]\rpages = await asyncio.gather(*tasks)\rfor movie_name, movie_date, page in zip(movie_names, movie_dates, pages):\rsoup_item = BeautifulSoup(page, 'lxml')\rimg_tag = soup_item.find('img')\rprint('{} {} {}'.format(movie_name, movie_date, img_tag['src']))\r%time asyncio.run(main())\r########## 输出 ##########\r阿拉��?05��?4��?https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2553992741.jpg\r龙珠超：布罗��?05��?4��?https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2557371503.jpg\r五月天人生无限公��?05��?4��?https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2554324453.jpg\r... ...\r直播攻略 06��?4��?https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2555957974.jpg\rWall time: 4.98 s 总结 link到这里，今天的主要内容就讲完了。今天我用了较长的篇幅，从一个简单的爬虫开始，到一个真正的爬虫结束，在中间穿插讲解��?Python 协程最新的基本概念和用法。这里带你简单复习一下��?\n协程和多线程的区别，主要在于两点，一是协程为单线程；二是协程由用户决定，在哪些地方交出控制权，切换到下一个任务��? 协程的写法更加简洁清晰，把async / await 语法��?create_task 结合来用，对于中小级别的并发需求已经毫无压力��? 写协程程序的时候，你的脑海中要有清晰的事件循环概念，知道程序在什么时候需要暂停、等��?I/O，什么时候需要一并执行到底��? 最后的最后，请一定不要轻易炫技。多线程模型也一定有其优点，一个真正牛逼的程序员，应该懂得，在什么时候用什么模型能达到工程上的最优，而不是自觉某个技术非常牛逼，所有项目创造条件也要上。技术是工程，而工程则是时间、资源、人力等纷繁复杂的事情的折衷��?\n思考题 link最后给你留一个思考题。协程怎么实现回调函数呢？欢迎留言和我讨论，也欢迎你把这篇文章分享给你的同事朋友，我们一起交流，一起进步��?\n��?python 3.7 及以上的版本中，我们��?task 对象调用 add_done_callback() 函数，即可绑定特定回调函数。回调函数接受一��?future 对象，可以通过 future.result() 来获取协程函数的返回值��?\n示例如下��?\nimport asyncio\nasync def crawl_page(url): print('crawling {}'.format(url)) sleep_time = int(url.split('_')[-1]) await asyncio.sleep(sleep_time) return 'OK {}'.format(url)\nasync def main(urls): tasks = [asyncio.create_task(crawl_page(url)) for url in urls] for task in tasks: task.add_done_callback(lambda future: print('result: ', future.result())) await asyncio.gather(*tasks)\n%time asyncio.run(main(['url_1', 'url_2', 'url_3', 'url_4']))\n输出��?\ncrawling url_1 crawling url_2 crawling url_3 crawling url_4 result: OK url_1 result: OK url_2 result: OK url_3 result: OK url_4 Wall time: 4 s2019-07-01Jingxiao 👍��?7��?💬��?0��?p\u003e发现评论区好多朋友说无法运行，在这里统一解释下：\n%time ��?jupyter notebook 自带的语法糖，用来统计一行命令的运行时间；如果你的运行时是纯粹的命令��?python，或��?pycharm，那么请��?%time 删掉，自己用传统的时间戳方法来记录时间也可以；或者使��?jupyter notebook 我的本地解释器是 Anaconda Python 3.7.3，亲��?windows / ubuntu 均可正常运行，如无法执行可以试试 pip install nest-asyncio，依然无法解决请尝试安装 Anaconda Python 这次代码因为使用了较新的 API，所以需要较新的版本号，但是朋友们依然出现了一些运行时问题，这里先表示下歉意；同时也想说明的是，在提问之前自己经过充分搜索，尝试后解决问题，带来的快感，和能力的提升，相应也是很大的，一门工程最需要的��?hands on dirty work（动手做脏活），才能让自己的能力得到本质的提升，加油��?/p\u003e2019-06-25Airnm.��?/span\u003e 👍��?��?💬��?��?p\u003e豆瓣那个发现requests.get(url).content/text返回都为空，然后打了下status_code发现��?18，网上找418的解释，一般是网站反爬虫基础机制，需要加请求头模仿浏览器就可跳过，改为下面的样子就可通过：url = \"https://movie.douban.com/cinema/later/beijing/\" head={ 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.113 Safari/537.36', 'Referer':'https://time.geekbang.org/column/article/101855', 'Connection':'keep-alive'} res = requests.get(url,headers=head)2020-04-18jackstraw 👍��?��?💬��?��?p\u003e有点没明白，前面说任务创建后立马就开始执行了么？怎么后面在解密底层运行过程的时候，说任务创建后等待执行？到底是哪一个呀��?/p\u003e2020-01-14长期规划 👍��?��?💬��?��?p\u003e老师，在最后那个协程例子中为何没用requests库呢？是因为它不支持协程��?/p\u003e2019-12-20一��?/span\u003e 👍��?��?💬��?��?p\u003e协程是单线程怎么理解？所有的协程都是��?/p\u003e2020-06-18苹果 👍��?��?💬��?��?p\u003easyncio.run() cannot be called from a running event loop 这个问题是如何解决， 其中的await asyncio.sleep(2)是否可以理解为在切出当前程序��?秒后再继续执行print('worker_2 done')代码��? 那么如果我有个耗时任务 def xxx(): …，那么该如何用await asyncio来让这个xxx函数运行并切出当前程序呢��?/p\u003e2019-11-28扶幽 👍��?��?💬��?��?p\u003e请问下有木有相关的书籍，来进行这块的学习呢！有些原理性的东西还是没办法深入理解，谢谢��?/p\u003e2019-10-12cotter 👍��?��?💬��?��?p\u003e受教了，第一次听说这个高级功能！ 我在工作中遇到一个需要并发的问题，用python在后台并发执行shell ,并发数量用时间范围控制，要不停的改时间分多次串行，方法比较笨拙。协程可以简化我的代码��? 老师，并发很多事件应该也是需要消耗很多资源，协程改如何控制并发数量？2019-06-24SUN 👍��?��?💬��?��?p\u003eJupyter 中运��?%time asyncio.run(main(['url_1', 'url_2', 'url_3', 'url_4'])) 会报错： RuntimeError: asyncio.run() cannot be called from a running event loop Python、Anaconda、Jupyter都安装了��? 话说：Jupyter不就是为了消除个人本地开发环境差异性而诞生的吗？这个结果有点反讽��? 各位学员的留言都看了，没人解决了此问题…��?\n综合下前面的留言和个人的学习，总结��?py 3.6 版本��?asyncio 的主要不同： 1、没��?run(), create_task()，可以用 asyncio.get_even_loop().run_until_complete() 来代��?run()，用 ensure_future() 来代��?create_task()��? 2、可能会出现 RuntimeError: This event loop is already running，解决方案一：pip install nest_asyncio; import nest_asyncio; nest_asyncio.apply()；解决方案二：有些友人说��?tornado 5.x 起的版本才有此问题，可考虑将其版本降至 4.x（不推荐）； 3��?time ��?%%time 的主要区别：%time func()（必须是同一行）��?%time 必须放在单元格的开头，强烈建议单独一��?+ 不要��?import、def 相关的语句放在同个单元格��? 4、爬虫中��?aiohttp.ClientSession(headers=header, connector=aiohttp.TCPConnector(ssl=False)) 提及未声明的 header，要么将 headers=header 部分去掉使用默认参数，要么用诸如 header={\"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Safari/537.36\"} 来显式声明； 5、tasks = [asyncio.create_task(crawl_page(url)) for url in urls]; await asyncio.gather(*tasks); 约等��? tasks = [crawl_page(url) for url in urls]; asyncio.get_even_loop().run_until_complete(asyncio.wait(tasks)); ��? tasks = [asyncio.ensure_future(crawl_page(url)) for url in urls]; await asyncio.gather(*tasks);2019-06-27\n"
            }
        );
    index.add(
            {
                id:  13 ,
                href: "\/docs\/python\/",
                title: "Python",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  14 ,
                href: "\/docs\/",
                title: "Stay Hungry , Stay Foolish",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  15 ,
                href: "\/docs\/python\/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98\/",
                title: "Python核心技术与实战",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  16 ,
                href: "\/docs\/ai\/",
                title: "AI 实践",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  17 ,
                href: "\/docs\/ai\/mcp-%E5%88%9D%E8%AF%95%E9%AA%8C\/",
                title: "MCP 初试验",
                description: "Where are we?（我们现在在哪？） link现在已经拥有了数据分析平台，拥有的基本的数据查询和数据分析能力。\nWhere are we going?（我们要到哪⼉去？） link但是我们的分析平台想和AI进行结合，能够拥有更灵活，更简单，更智能的查询方式，能够通过自然语言去执行对应的查询和分析工作，不再依赖一板一眼的面板操作\nHow can we get there?（我们如何到达那⾥？） link增加MCP服务，衔接后端服务和智能体客户端（可以是Cursor，Trae这样的，也可以是自己开发的）\n示例 link MCP实现方式并不拘泥于某种编程语言，本文以Java实现。\nSystem requirements 系统要求 linkJava 17 或更高版本已安装。 Spring Boot 3.3.x 或更高版本\n依赖选择 link通过 SpringBoot 项目初始化之后，再额外添加以下依赖\norg.springframework.ai\rspring-ai-starter-mcp-server\rorg.springframework\rspring-web\rBest Practices 最佳实践 link 作者提示： 这里虽说是最佳实践，我以为是必须要严格执行的。后文中的属性配置，其实就是这里要求的具体实现。\nUse a logging library that writes to stderr or files. 使用将日志写入 stderr 或文件的日志库。 Ensure any configured logging library will not write to STDOUT 确保任何配置的日志库不会将日志写入 STDOUT 程序属性配置 link spring.main.bannerMode=off\rlogging.pattern.console= 或者习惯yaml的话\n",
                content: "Where are we?（我们现在在哪？） link现在已经拥有了数据分析平台，拥有的基本的数据查询和数据分析能力。\nWhere are we going?（我们要到哪⼉去？） link但是我们的分析平台想和AI进行结合，能够拥有更灵活，更简单，更智能的查询方式，能够通过自然语言去执行对应的查询和分析工作，不再依赖一板一眼的面板操作\nHow can we get there?（我们如何到达那⾥？） link增加MCP服务，衔接后端服务和智能体客户端（可以是Cursor，Trae这样的，也可以是自己开发的）\n示例 link MCP实现方式并不拘泥于某种编程语言，本文以Java实现。\nSystem requirements 系统要求 linkJava 17 或更高版本已安装。 Spring Boot 3.3.x 或更高版本\n依赖选择 link通过 SpringBoot 项目初始化之后，再额外添加以下依赖\norg.springframework.ai\rspring-ai-starter-mcp-server\rorg.springframework\rspring-web\rBest Practices 最佳实践 link 作者提示： 这里虽说是最佳实践，我以为是必须要严格执行的。后文中的属性配置，其实就是这里要求的具体实现。\nUse a logging library that writes to stderr or files. 使用将日志写入 stderr 或文件的日志库。 Ensure any configured logging library will not write to STDOUT 确保任何配置的日志库不会将日志写入 STDOUT 程序属性配置 link spring.main.bannerMode=off\rlogging.pattern.console= 或者习惯yaml的话\nlogging:\rpattern:\rconsole:\rspring:\rmain:\rbanner-mode: off 相关的配置全集 ： 点击查看\n编写Service link官方文档内容如下：\n@Service 注解会自动将服务注册到应用程序上下文中。Spring AI @Tool 注解，使得创建和维护 MCP 工具变得非常容易。The auto-configuration will automatically register these tools with the MCP server. 自动配置会自动将这些工具注册到 MCP 服务器上。\n作者按： 看起来与平常编写sevice，并无二异。但其中暗藏玄机\n和前面提到的一样， 编码过程不要出现任何打印输出的内容，如果非要打印，以err的形式打印 Sysout.err.println(); @Tool 注解会将对应的方法 注册到MCP服务器上作为工具使用 package com.xmic.mcp.data.analysis.service;\rimport com.fasterxml.jackson.databind.ObjectMapper;\rimport com.xmic.mcp.data.analysis.common.Constants;\rimport com.xmic.mcp.data.analysis.common.R;\rimport com.xmic.mcp.data.analysis.common.ResponseData;\rimport com.xmic.mcp.data.analysis.dto.DataQueryDTO;\rimport com.xmic.mcp.data.analysis.dto.ItemDTO;\rimport com.xmic.mcp.data.analysis.utils.JsonUtils;\rimport org.springframework.ai.tool.annotation.Tool;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.web.client.RestClient;\rimport java.util.HashMap;\rimport java.util.List;\rimport java.util.Map;\rimport java.util.Objects;\r@Service\rpublic class DataQueryService {\r@Autowired\rprivate ObjectMapper objectMapper;\rprivate static final String BASE_URL = \"http://192.168.15.172/api\";\rprivate RestClient restClient;\rpublic DataQueryService() {\rthis.restClient = RestClient.builder()\r.baseUrl(BASE_URL)\r.defaultHeader(\"Accept\", \"*/*\")\r.defaultHeader(\"Content-Type\", \"application/json\")\r.defaultHeader(\"User-Agent\", \"WeatherApiClient/1.0 (zxt@xmic.com)\")\r.defaultHeader(\"Authorization\", Constants.TOKEN_NEVER_EXPIRE)\r.build();\r}\r@Tool(description = \"依据工作面code和设备因子名称查询对应的历史数据，包含 最大值，平均值，和最小值\")\rpublic String queryHistoryDataOnFaceCode(DataQueryDTO query) {\r// 判断query中 faceCode ,factorCode 不能为空\rif (Objects.isNull(query.getFaceCode()) || Objects.isNull(query.getFactorCodes())) {\rreturn \"faceCode 和 factorCode 不能为空\";\r}\rMap result = new HashMap\u003c\u003e();\rR response = restClient.post()\r.uri(\"/data/history/chart/figure2D\")\r.body(query)\r.retrieve()\r.body(R.class);\rif (Objects.isNull(response)) {\rresult.put(\"msg\", \"查询失败了\");\rreturn JsonUtils.toJson(result);\r}\rif (Objects.equals(response.getStatus(), R.OK)) {\rResponseData responseData = objectMapper.convertValue(response.getData(), ResponseData.class);\rMap"
            }
        );
    search.addEventListener('input', show_results, true);

    function show_results(){
        const maxResult =  5 ;
        const minlength =  0 ;
        var searchQuery = sanitizeHTML(this.value);
        var results = index.search(searchQuery, {limit: maxResult, enrich: true});

        
        const flatResults = new Map(); 
        for (const result of results.flatMap(r => r.result)) {
        if (flatResults.has(result.doc.href)) continue;
        flatResults.set(result.doc.href, result.doc);
        }

        suggestions.innerHTML = "";
        suggestions.classList.remove('d-none');

        
        if (searchQuery.length < minlength) {
            const minCharMessage = document.createElement('div')
            minCharMessage.innerHTML = `Please type at least <strong>${minlength}</strong> characters`
            minCharMessage.classList.add("suggestion__no-results");
            suggestions.appendChild(minCharMessage);
            return;
        } else {
            
            if (flatResults.size === 0 && searchQuery) {
                const noResultsMessage = document.createElement('div')
                noResultsMessage.innerHTML = "No results for" + ` "<strong>${searchQuery}</strong>"`
                noResultsMessage.classList.add("suggestion__no-results");
                suggestions.appendChild(noResultsMessage);
                return;
            }
        }

        
        for(const [href, doc] of flatResults) {
            const entry = document.createElement('div');
            suggestions.appendChild(entry);

            const a = document.createElement('a');
            a.href = href;
            entry.appendChild(a);

            const title = document.createElement('span');
            title.textContent = doc.title;
            title.classList.add("suggestion__title");
            a.appendChild(title);

            const description = document.createElement('span');
            description.textContent = doc.description;
            description.classList.add("suggestion__description");
            a.appendChild(description);

            suggestions.appendChild(entry);

            if(suggestions.childElementCount == maxResult) break;
        }
    }
    }());
</script>
        
    </body>
</html>
