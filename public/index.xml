<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>别人打药我拽管</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on 别人打药我拽管</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 04 Aug 2025 11:25:06 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MCP 初试验</title>
      <link>http://localhost:1313/docs/ai/mcp-%E5%88%9D%E8%AF%95%E9%AA%8C/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/ai/mcp-%E5%88%9D%E8%AF%95%E9%AA%8C/</guid>
      <description>&lt;h2 id=&#34;where-are-we我们现在在哪&#34;&gt;Where are we?（我们现在在哪？） &lt;a href=&#34;#where-are-we%e6%88%91%e4%bb%ac%e7%8e%b0%e5%9c%a8%e5%9c%a8%e5%93%aa&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;现在已经拥有了数据分析平台，拥有的基本的数据查询和数据分析能力。&lt;/p&gt;&#xA;&lt;h2 id=&#34;where-are-we-going我们要到哪去&#34;&gt;Where are we going?（我们要到哪⼉去？） &lt;a href=&#34;#where-are-we-going%e6%88%91%e4%bb%ac%e8%a6%81%e5%88%b0%e5%93%aa%e5%8e%bb&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;但是我们的分析平台想和AI进行结合，能够拥有更灵活，更简单，更智能的查询方式，能够通过自然语言去执行对应的查询和分析工作，不再依赖一板一眼的面板操作&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-can-we-get-there我们如何到达那&#34;&gt;How can we get there?（我们如何到达那⾥？） &lt;a href=&#34;#how-can-we-get-there%e6%88%91%e4%bb%ac%e5%a6%82%e4%bd%95%e5%88%b0%e8%be%be%e9%82%a3&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;增加MCP服务，衔接后端服务和智能体客户端（可以是Cursor，Trae这样的，也可以是自己开发的）&lt;/p&gt;&#xA;&lt;h2 id=&#34;示例&#34;&gt;示例 &lt;a href=&#34;#%e7%a4%ba%e4%be%8b&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;MCP实现方式并不拘泥于某种编程语言，本文以Java实现。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;system-requirements--系统要求&#34;&gt;System requirements  系统要求 &lt;a href=&#34;#system-requirements--%e7%b3%bb%e7%bb%9f%e8%a6%81%e6%b1%82&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Java 17 或更高版本已安装。&#xA;Spring Boot 3.3.x 或更高版本&lt;/p&gt;&#xA;&lt;h3 id=&#34;依赖选择&#34;&gt;依赖选择 &lt;a href=&#34;#%e4%be%9d%e8%b5%96%e9%80%89%e6%8b%a9&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;通过 SpringBoot 项目初始化之后，再额外添加以下依赖&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;cdfbd36&#34; class=&#34;language-xml &#34;&gt;&#xA;  &lt;code&gt;&amp;lt;dependencies&amp;gt;&#xD;&#xA;      &amp;lt;dependency&amp;gt;&#xD;&#xA;          &amp;lt;groupId&amp;gt;org.springframework.ai&amp;lt;/groupId&amp;gt;&#xD;&#xA;          &amp;lt;artifactId&amp;gt;spring-ai-starter-mcp-server&amp;lt;/artifactId&amp;gt;&#xD;&#xA;      &amp;lt;/dependency&amp;gt;&#xD;&#xA;&#xD;&#xA;      &amp;lt;dependency&amp;gt;&#xD;&#xA;          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&#xD;&#xA;          &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;&#xD;&#xA;      &amp;lt;/dependency&amp;gt;&#xD;&#xA;&amp;lt;/dependencies&amp;gt;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;h3 id=&#34;best-practices-最佳实践&#34;&gt;Best Practices 最佳实践 &lt;a href=&#34;#best-practices-%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;作者提示： 这里虽说是最佳实践，我以为是必须要严格执行的。后文中的属性配置，其实就是这里要求的具体实现。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Use a logging library that writes to stderr or files.&#xA;使用将日志写入 stderr 或文件的日志库。&lt;/li&gt;&#xA;&lt;li&gt;Ensure any configured logging library will not write to STDOUT&#xA;确保任何配置的日志库不会将日志写入 STDOUT&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;程序属性配置&#34;&gt;程序属性配置 &lt;a href=&#34;#%e7%a8%8b%e5%ba%8f%e5%b1%9e%e6%80%a7%e9%85%8d%e7%bd%ae&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;bb11669&#34; class=&#34;language-properties &#34;&gt;&#xA;  &lt;code&gt;spring.main.bannerMode=off&#xD;&#xA;logging.pattern.console=&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;或者习惯yaml的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python核心技术与实战</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;h2 id=&#34;课程介绍&#34;&gt;课程介绍 &lt;a href=&#34;#%e8%af%be%e7%a8%8b%e4%bb%8b%e7%bb%8d&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;人工智能时代下，Python毫无疑问是最热的编程语言。有人夸它功能强大还上手轻松，有人说它学习曲线不那么陡峭，但是更多的人，在推开Python的大门后却发现，Python入门容易但精通却不易。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;你是否也曾傻傻分不清“列表”“元组”“字典”“集合”等的用法，甚至试图在集合中采用索引方式？&lt;/li&gt;&#xA;&lt;li&gt;你是否也曾苦苦钻研面向对象的理念，却在被要求设计一个稍复杂点的系统时束手无策？&lt;/li&gt;&#xA;&lt;li&gt;你是否也曾羡慕别人能巧用装饰器、生成器等高级操作，可自己在写代码时，却连异常抛出、内存不足等边界条件都战战兢兢搞不定呢？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;由此可见，想要精通这门语言，必须真正理解知识概念，比如适当从源码层面深化认知，然后熟悉实际的工程应用，独立完成项目开发。这样，你才能成为真正的语言高手。&lt;/p&gt;&#xA;&lt;p&gt;在这个专栏里，景霄会从工程的角度，带你学习Python。专栏基于Python最新的3.7版本，以语言知识结合工程应用为主线，其中包含了大量的独家解读和实际工作案例。内容难易兼顾，既可以带你巩固核心基础，更会教你各种高级进阶操作，让你循序渐进、系统掌握Python这门语言。&lt;/p&gt;&#xA;&lt;p&gt;专栏按照&lt;strong&gt;进阶难度&lt;/strong&gt;分为4个模块。&lt;/p&gt;&#xA;&lt;p&gt;前两部分主要是&lt;strong&gt;Python的基础篇和进阶篇。除去必要的概念、操作讲解，基础篇和进阶篇都着重强调了学习中的重难点和易错点&lt;/strong&gt;，并从性能分析、实际应用举例等不同维度出发，让你轻松理解和掌握它们。&lt;/p&gt;&#xA;&lt;p&gt;第三部分是&lt;strong&gt;规范篇&lt;/strong&gt;，通过讲解合理分解代码、运用assert、写单元测试等具体编程技巧，教你写出高质量的Python程序。&lt;/p&gt;&#xA;&lt;p&gt;第四部分则是&lt;strong&gt;实战篇，这部分会通过量化交易系统项目的开发，带你串联起前面所学的Python知识&lt;/strong&gt;，并加入大量的实战经验和技巧，让你在独立项目开发中获得质的提高。&lt;/p&gt;&#xA;&lt;p&gt;课程的练习代码：&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/zwdnet/PythonPractice&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;https://github.com/zwdnet/PythonPractice&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;开篇词&#34;&gt;开篇词 &lt;a href=&#34;#%e5%bc%80%e7%af%87%e8%af%8d&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;我是Facebook的一名全栈工程师，目前从事机器学习的相关工作，主要工作领域是人工智能的推荐排序系统与算法。工作期间，我曾领导多个上亿用户级产品的开发与落地，有丰富的工程与实战经验。&lt;/p&gt;&#xA;&lt;p&gt;一听机器学习，很多人第一反应可能是“好难呀、厉害呀”。可事实上，我的编程之路并非一路高光。&lt;/p&gt;&#xA;&lt;p&gt;不同于大城市长大或竞赛出身、十一二岁接触编程的人，在刚上大学时，我的编程基础几乎为零。大一上的C语言，便是我出生起学到的第一门编程语言。初识计算机语言的世界，很有趣也很吸引我，这也是我成为程序员的最初动力。&lt;/p&gt;&#xA;&lt;p&gt;和很多对编程感兴趣的人一样，哪怕老师只是在讲台上，照本宣科地读着N年前的课件，我也会竖起耳朵认真听讲、认真做笔记。并且，私下里我还买了不少厚重的大块头书，在网上查了不少博客、帖子，照着上面的例子一行行地敲代码。很多内容我并不理解，比如指针、递归这类抽象的概念，查了一堆资料也没看明白。但靠着死记硬背，考试基本可以过关，虽然这个过程比较痛苦，也比较累。&lt;/p&gt;&#xA;&lt;p&gt;后来，为了更深入了解计算机，我去了哥伦比亚大学攻读计算机硕士学位，又陆续学到不少新的编程语言，比如Node.js、Python、PHP、Scala等等。这个阶段，我边学习，边做项目，却发现轻松了很多。&lt;/p&gt;&#xA;&lt;p&gt;这两个学习阶段，收获和感受天差地别，难道仅仅是因为“万事入门难”吗？我不止一次反思过这个问题，终于发现，问题出在了&lt;strong&gt;资料本身&lt;/strong&gt;上。&lt;/p&gt;&#xA;&lt;p&gt;为什么这么说呢？一是因为书上或网上的很多东西，非常理论化，实例少之又少，单凭死记硬背很难真正掌握；二是这些内容中，原创的观点和经验更少，大多互相抄袭，内容雷同且不实用，远离实际工程，毫无借鉴价值。&lt;/p&gt;&#xA;&lt;p&gt;但显然，市面上的资料问题，我们个人是很难解决的。我们能做的，便是克服常见资料的弊端，另辟蹊径来学习。这其中，最重要的一点就是，从工程的角度思考学习，以实用为出发点，多练习、多阅读、多做项目，这样才能有质的提高。&lt;/p&gt;&#xA;&lt;p&gt;在Facebook工作的这么多年，也验证了我的观点。我身边的新手，他们学习新的语言总是只会啃书练习，还难以上手；而有经验的同事则不同，他们能花很短的时间看完基础语法，然后找行家去了解一些重难点、易错点，最后亲自动手完成一个项目，达到融会贯通的效果。这样下来，可能几周时间就掌握得差不多了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>告别代码工人</title>
      <link>http://localhost:1313/docs/%E6%97%A5%E5%B8%B8/%E5%91%8A%E5%88%AB%E4%BB%A3%E7%A0%81%E5%B7%A5%E4%BA%BA/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/%E6%97%A5%E5%B8%B8/%E5%91%8A%E5%88%AB%E4%BB%A3%E7%A0%81%E5%B7%A5%E4%BA%BA/</guid>
      <description>&lt;p&gt;过去 25 年，从互联网到移动互联网的浪潮，创造了海量的工程需求，软件工程师也因此成为了时代的宠儿。但现在，这波巨大的增长红利期已经结束。&lt;/p&gt;&#xA;&lt;p&gt;那下一个浪潮是什么？文章给出了答案：&lt;strong&gt;Agentic AI (智能体 AI)&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;这不仅仅是一个新技术，它将彻底重塑我们的工作方式，重写“软件工程师”这个岗位的核心要求。这不是一次普通的更新，这是一场彻底的进化。&lt;/p&gt;&#xA;&lt;h2 id=&#34;告别代码工人拥抱智能体工程师&#34;&gt;告别“代码工人”，拥抱“智能体工程师” &lt;a href=&#34;#%e5%91%8a%e5%88%ab%e4%bb%a3%e7%a0%81%e5%b7%a5%e4%ba%ba%e6%8b%a5%e6%8a%b1%e6%99%ba%e8%83%bd%e4%bd%93%e5%b7%a5%e7%a8%8b%e5%b8%88&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;文章预言，软件工程师不会被淘汰，而是将进化，去“驾驭”这波新的 AI 浪潮。我们将成为所谓的 &lt;strong&gt;“智能体软件工程师” (Agentic Software Engineer)&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;在这个新角色下，我们的工作不再是整天埋头编写成千上万行代码。AI Agent 可以比我们更快、更不知疲倦地完成这项任务。我们的核心职责，将转变为：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;一个指挥、协调、审查和运维 AI Agent 军团的专家。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;我们从亲自下场比赛的“运动员”，变成了运筹帷幄的“教练”。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ai-时代的生存指南你的技能升级清单&#34;&gt;AI 时代的生存指南：你的技能升级清单 &lt;a href=&#34;#ai-%e6%97%b6%e4%bb%a3%e7%9a%84%e7%94%9f%e5%ad%98%e6%8c%87%e5%8d%97%e4%bd%a0%e7%9a%84%e6%8a%80%e8%83%bd%e5%8d%87%e7%ba%a7%e6%b8%85%e5%8d%95&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;那么，要成为一名合格的“智能体软件工程师”，我们需要点亮哪些新的技能树？文章为我们梳理了一份极其宝贵的“技能升值/贬值清单”。&lt;/p&gt;&#xA;&lt;h3 id=&#34;技能升值-skills这-6-项能力将是你未来的护城河&#34;&gt;技能升值 (Skills++)：这 6 项能力将是你未来的护城河 &lt;a href=&#34;#%e6%8a%80%e8%83%bd%e5%8d%87%e5%80%bc-skills%e8%bf%99-6-%e9%a1%b9%e8%83%bd%e5%8a%9b%e5%b0%86%e6%98%af%e4%bd%a0%e6%9c%aa%e6%9d%a5%e7%9a%84%e6%8a%a4%e5%9f%8e%e6%b2%b3&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;版本控制 (Version Control)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Git 不再仅仅是你个人的代码管理工具，它将成为&lt;strong&gt;协调你与成百上千个“AI 码农”协同工作的核心骨干&lt;/strong&gt;。你需要用它来管理 Agent 的并行工作流、审查 Agent 提交的 PR、以及在 Agent 犯错时进行回滚。精通 Git 模型，将是从业基础。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;产品思维 (“Product”)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;AI Agent 擅长执行，但前提是指令必须清晰。&lt;strong&gt;任务分解、需求定义、接口设计&lt;/strong&gt;等产品经理的核心技能，将成为每个工程师的必备能力。如果你无法将一个模糊的想法拆解成 Agent 可以处理的、足够小的任务块，你将无法与 Agent 高效协作。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代码审查 (Code Review)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这是未来我们耗时最多的日常工作。当 Agent 可以在 10 分钟内生成 500 行复杂的代码时，你的价值就体现在审查这些代码的正确性、可维护性和安全性上。&lt;strong&gt;接受吧，你正在从一个 Code Writer 变成一个 Code Editor。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python</title>
      <link>http://localhost:1313/docs/python/python/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;笔者为 Javaer 所以仅记录和Java语言的不同之处，方便快速学习&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;基础数据类型&#34;&gt;基础数据类型 &lt;a href=&#34;#%e5%9f%ba%e7%a1%80%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;&#xA;&lt;li&gt;数字&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;bool（布尔型）：True | False&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;笔者按： 布尔值要驼峰命令&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;complex （复数），如 1 + 2j、 1.1 + 2.2j。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;笔者按： 已经忘记复数这个数学概念啦~&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;字符串&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;索引&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;字符串的组成元素为字符，每个字符在字符串中有对应的索引。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;和java不同的是，不光有正序索引，还有倒序索引&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/image-20250725122701207_6890670413197233091.png&#34; alt=&#34;image-20250725122701207&#34; width=&#34;931&#34; height=&#34;443&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;截取&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;字符串的截取，都是 前闭后开 或者 叫 含头不含尾&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;python字符串的截取和索引强相关；&lt;/p&gt;&#xA;&lt;p&gt;但又因为有正序和倒序，两排索引，所以截取时非常灵活，使用时也要谨慎&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/image-20250725124333658_17956901840035152325.png&#34; alt=&#34;image-20250725124333658&#34; width=&#34;955&#34; height=&#34;777&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;图片来自网络，倒数第二个例子有点奇怪： 描述和结果都不对；要实现输出结果ab，可通过如下方式&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;912ff5e&#34; class=&#34;language-python &#34;&gt;&#xA;  &lt;code&gt;print(str[:2]) # ab&#xD;&#xA;print(str[:-5]) # ab&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&lt;/blockquote&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;784e231&#34; class=&#34;language-python &#34;&gt;&#xA;  &lt;code&gt;str=&amp;#34;abcdefg&amp;#34;&#xD;&#xA;print(str[1:]) # bcdefg&#xD;&#xA;print(str[:5]) # abcde&#xD;&#xA;print(str[1:5]) # bcde&#xD;&#xA;print(str[-4:]) # defg&#xD;&#xA;print(str[-2:-6]) # 空字符串 是 &amp;#39;&amp;#39; 不是None&#xD;&#xA;print(str[-6:-2]) #bcde&#xD;&#xA;print(str[::-1]) # 字符串反转  gfedcba&#xD;&#xA;print(str[:2]) # ab&#xD;&#xA;print(str[:-5]) # ab&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;列表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;笔者按： 和Java中的数组特点一样； 最大最大的区别是 一个数组可以有不同类型的元素；&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何逐步突破，成为Python高手？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/01---%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E7%AA%81%E7%A0%B4%E6%88%90%E4%B8%BApython%E9%AB%98%E6%89%8B/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/01---%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E7%AA%81%E7%A0%B4%E6%88%90%E4%B8%BApython%E9%AB%98%E6%89%8B/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;工作中，我总听到很多程序员抱怨，说现在的计算机编程语言太多了，学不过来了。一些人Java用了很多年，但是最近的项目突然需要用Python，就会不知所措，压力很大。&lt;/p&gt;&#xA;&lt;p&gt;众所周知，Facebook的主流语言是Hack（PHP的进化版本）。不过，我敢拍着胸脯说，就刚入职的工程师而言，100个里至少有95个，以前都从未用过Hack或者PHP。但是，这些人上手都特别快，基本上一两周后，日常编程便毫无压力了。&lt;/p&gt;&#xA;&lt;p&gt;他们是怎么做到的呢？&lt;/p&gt;&#xA;&lt;p&gt;事实上，他们遵循的，正是我在开篇词中提到的方法，也是本专栏学习的中心观点：“从工程的角度去学习Python”。那么具体来说，到底要怎么学，学习的过程中又要特别注意哪些地方呢？&lt;/p&gt;&#xA;&lt;h2 id=&#34;不同语言需融会贯通&#34;&gt;不同语言，需融会贯通 &lt;a href=&#34;#%e4%b8%8d%e5%90%8c%e8%af%ad%e8%a8%80%e9%9c%80%e8%9e%8d%e4%bc%9a%e8%b4%af%e9%80%9a&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;其实，如果你在学一门语言的时候多阅读、多练习、多思考，你就会发现，不同语言都是类似的。编程语言本就是人类控制计算机的指令，语法规则等方面自然大同小异。&lt;/p&gt;&#xA;&lt;p&gt;而在原有基础上，学习一门新的编程语言，其实也没有那么难，你首先要做到的是明确区分。比如，在学习Python的条件与循环语句时，多回忆一下其他语言的语法是怎样的。再如，遇到Python中的字符串相加时，你能分析出它的复杂度吗？再联想到其他语言，比如Java中字符串相加的复杂度，它们之间有什么相同点、又有什么区别呢？&lt;/p&gt;&#xA;&lt;p&gt;除了能够明确区分语言的不同点，我们还要能联系起来灵活运用。比如，最典型的“编程语言两问”：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;你了解你学过的每种编程语言的特点吗？&lt;/li&gt;&#xA;&lt;li&gt;你能根据不同的产品需求，选用合适的编程语言吗？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;举个例子，Python的优点之一是特别擅长数据分析，所以广泛应用于人工智能、机器学习等领域，如机器学习中TensorFlow的框架，就是用Python写的。但是涉及到底层的矩阵运算等等，还是要依赖于C++完成，因为C++的速度快，运行效率更高。&lt;/p&gt;&#xA;&lt;p&gt;事实上，很多公司都是这样，服务器端开发基于Python，但底层的基础架构依赖于C++。这就是典型的“不同需求选用不同语言”。毕竟，你要明白，哪怕只是几十到几百毫秒的速度差距，对于公司、对于用户体验来说都是决定性的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;唯一语言可循序渐进&#34;&gt;唯一语言，可循序渐进 &lt;a href=&#34;#%e5%94%af%e4%b8%80%e8%af%ad%e8%a8%80%e5%8f%af%e5%be%aa%e5%ba%8f%e6%b8%90%e8%bf%9b&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;当然，如果Python是你学的第一门编程语言，那也不必担心。我们知道，虽然同为人机交互的桥梁，Python语言比起C++、Java等主流语言，语法更简洁，也更接近英语，对编程世界的新人还是很友好的，这也是其显著优点。这种情况下，你要做的就是专注于Python这一门语言，明确学习的重点，把握好节奏循序渐进地学习。&lt;/p&gt;&#xA;&lt;p&gt;根据我多年的学习工作经验，我把编程语言的学习重点，总结成了下面这三步，无论你是否有其他语言的基础，都可以对照来做，稳步进阶。&lt;/p&gt;&#xA;&lt;h2 id=&#34;第一步大厦之基勤加练习&#34;&gt;第一步：大厦之基，勤加练习 &lt;a href=&#34;#%e7%ac%ac%e4%b8%80%e6%ad%a5%e5%a4%a7%e5%8e%a6%e4%b9%8b%e5%9f%ba%e5%8b%a4%e5%8a%a0%e7%bb%83%e4%b9%a0&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;任何一门编程语言，其覆盖范围都是相当广泛的，从基本的变量赋值、条件循环，到并发编程、Web开发等等，我想市面上几乎没有任何一本书能够罗列完全。&lt;/p&gt;&#xA;&lt;p&gt;所以，我建议你，在掌握必要的基础时，就得多上手操作了。千万不要等到把教材上所有东西都学完了才开始，因为到那时候你会发现，前面好不容易记住的一堆东西似乎又忘记了。计算机科学是一门十分讲究实战的学科，因此越早上手练习，练得越多越勤，就越好。&lt;/p&gt;&#xA;&lt;p&gt;不过，到底什么叫做必要的基础呢？以Python为例，如果你能够理解变量间的赋值、基本的数据类型、条件与循环语句、函数的用法，那么你就达到了第一步的底线标准，应该开始在课下多多练习了。&lt;/p&gt;&#xA;&lt;p&gt;比方说，你可以自己动手编程做一个简易的计算器，这应该也是大多数程序员实操的第一个小项目。用户输入数字和运算符后，你的程序能够检查输入是否合法并且返回正确的结果吗？&lt;/p&gt;&#xA;&lt;p&gt;在做这个小项目的过程中，你可能会遇到不少问题。我的建议是，遇到不懂的问题时，多去&lt;a href=&#34;https://stackoverflow.com/&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;Stack Overflow&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;上查询，这样你还能阅读别人优秀的代码，借鉴别人的思路，对于你的学习肯定大有帮助。当然，实在解决不了的问题，也可以写在留言区，我们一起来解决。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Jupyter Notebook为什么是现代Python的必学技术？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/02---jupyter-notebook%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%B0%E4%BB%A3python%E7%9A%84%E5%BF%85%E5%AD%A6%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/02---jupyter-notebook%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%B0%E4%BB%A3python%E7%9A%84%E5%BF%85%E5%AD%A6%E6%8A%80%E6%9C%AF/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;Stack Overflow 曾在2017年底，发布了在该站上各种语言的提问流量。其中，Python已经超过了JavaScript成为了流量最高的语言，预测在2020年前会远远甩开JavaScript。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/5c3daf49453370c3aa7ddf3bb36cab2d_8804524239381135015.png&#34; alt=&#34;&#34; width=&#34;1400&#34; height=&#34;1200&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;可能你已经知道，Python在14年后的“崛起”，得益于机器学习和数学统计应用的兴起。那为什么Python如此适合数学统计和机器学习呢？作为“老司机”的我可以肯定地告诉你，Jupyter Notebook （&lt;a href=&#34;https://jupyter.org/&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;https://jupyter.org/&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;）功不可没。&lt;/p&gt;&#xA;&lt;p&gt;毫不夸张地说，根据我对Facebook等硅谷一线大厂的了解，一个Python工程师如果现在还不会使用Jupyter Notebook的话，可能就真的太落伍了。&lt;/p&gt;&#xA;&lt;p&gt;磨刀不误砍柴工，高效的工具让我们的编程事半功倍。这一节课，我就来带你学习一下Jupyter Notebook，为后面的Python学习打下必备基础。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是jupyter-notebook&#34;&gt;什么是Jupyter Notebook？ &lt;a href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afjupyter-notebook&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;说了这么多，到底什么是Jupyter Notebook？按照Jupyter 创始人 Fernando Pérez的说法，他最初的梦想是做一个综合 Ju （Julia）、Py （Python）和 R 三种科学运算语言的计算工具平台，所以将其命名为Ju-Py-te-R。发展到现在，Jupyter 已经成为一个几乎支持所有语言，能够把&lt;strong&gt;软件代码、计算输出、解释文档、多媒体资源&lt;/strong&gt;整合在一起的多功能科学运算平台。&lt;/p&gt;</description>
    </item>
    <item>
      <title>列表和元组</title>
      <link>http://localhost:1313/docs/python/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/</guid>
      <description>&lt;h2 id=&#34;一列表和元组&#34;&gt;一、列表和元组 &lt;a href=&#34;#%e4%b8%80%e5%88%97%e8%a1%a8%e5%92%8c%e5%85%83%e7%bb%84&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;共同点&#34;&gt;共同点 &lt;a href=&#34;#%e5%85%b1%e5%90%8c%e7%82%b9&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;任意数据类型&lt;/strong&gt;的&lt;strong&gt;有序&lt;/strong&gt;集合&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;都⽀持负数索引&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;都⽀持切⽚操作&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以随意嵌套（其实就是任意数据类型的一种表现）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;通过list()和tuple()函数相互转换&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;不同点&#34;&gt;不同点 &lt;a href=&#34;#%e4%b8%8d%e5%90%8c%e7%82%b9&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;列表&lt;/th&gt;&#xA;          &lt;th&gt;元组&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;动态&lt;/td&gt;&#xA;          &lt;td&gt;静态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;list.reverse() 倒转列表&lt;!-- raw HTML omitted --&gt;list.sort() 排序&lt;/td&gt;&#xA;          &lt;td&gt;没有内置的这两个函数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;存储空间可变&lt;!-- raw HTML omitted --&gt;包含以下内容：&lt;!-- raw HTML omitted --&gt;- 指针&lt;!-- raw HTML omitted --&gt;- 已分配内容&lt;!-- raw HTML omitted --&gt;- 元素内容&lt;/td&gt;&#xA;          &lt;td&gt;存储空间固定&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;各有千秋&#34;&gt;各有千秋 &lt;a href=&#34;#%e5%90%84%e6%9c%89%e5%8d%83%e7%a7%8b&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;占用空间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;集合元素少，空间差异可忽略；&lt;/p&gt;&#xA;&lt;p&gt;集合元素数量级大，空间差异明显 ，列表空间明显大于元组；&lt;/p&gt;&#xA;&lt;p&gt;可用作选择 列表和元组的参考因素&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;性能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;元组性能略优&lt;/p&gt;&#xA;&lt;p&gt;原因如下：&lt;/p&gt;&#xA;&lt;p&gt;python优化静态数据-&amp;gt;资源缓存；&lt;/p&gt;&#xA;&lt;p&gt;元组属于静态数据，会被缓存，资源重复利用率高；&lt;/p&gt;&#xA;&lt;p&gt;在初始化方面，元组性能高于列表；&lt;/p&gt;&#xA;&lt;h2 id=&#34;二字典和集合&#34;&gt;二、字典和集合 &lt;a href=&#34;#%e4%ba%8c%e5%ad%97%e5%85%b8%e5%92%8c%e9%9b%86%e5%90%88&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>列表和元组，到底用哪一个？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/03---%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E5%88%B0%E5%BA%95%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/03---%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E5%88%B0%E5%BA%95%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;前面的课程，我们讲解了Python语言的学习方法，并且带你了解了Python必知的常用工具——Jupyter。那么从这节课开始，我们将正式学习Python的具体知识。&lt;/p&gt;&#xA;&lt;p&gt;对于每一门编程语言来说，数据结构都是其根基。了解掌握Python的基本数据结构，对于学好这门语言至关重要。今天我们就一起来学习，Python中最常见的两种数据结构：列表（list）和元组（tuple）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;列表和元组基础&#34;&gt;列表和元组基础 &lt;a href=&#34;#%e5%88%97%e8%a1%a8%e5%92%8c%e5%85%83%e7%bb%84%e5%9f%ba%e7%a1%80&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;首先，我们需要弄清楚最基本的概念，什么是列表和元组呢？&lt;/p&gt;&#xA;&lt;p&gt;实际上，列表和元组，都是&lt;strong&gt;一个可以放置任意数据类型的有序集合&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;在绝大多数编程语言中，集合的数据类型必须一致。不过，对于Python的列表和元组来说，并无此要求：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;f6e6a1d&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;l = [1, 2, &amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;] # 列表中同时含有int和string类型的元素&#xD;&#xA;l&#xD;&#xA;[1, 2, &amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;]&#xD;&#xA;&#xD;&#xA;tup = (&amp;#39;jason&amp;#39;, 22) # 元组中同时含有int和string类型的元素&#xD;&#xA;tup&#xD;&#xA;(&amp;#39;jason&amp;#39;, 22)&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;其次，我们必须掌握它们的区别。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;列表是动态的&lt;/strong&gt;，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;而元组是静态的&lt;/strong&gt;，长度大小固定，无法增加删减或者改变（immutable）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;下面的例子中，我们分别创建了一个列表与元组。你可以看到，对于列表，我们可以很轻松地让其最后一个元素，由4变为40；但是，如果你对元组采取相同的操作，Python 就会报错，原因就是元组是不可变的。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;e0b001b&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;l = [1, 2, 3, 4]&#xD;&#xA;l[3] = 40 # 和很多语言类似，python中索引同样从0开始，l[3]表示访问列表的第四个元素&#xD;&#xA;l&#xD;&#xA;[1, 2, 3, 40]&#xD;&#xA;&#xD;&#xA;tup = (1, 2, 3, 4)&#xD;&#xA;tup[3] = 40&#xD;&#xA;Traceback (most recent call last):&#xD;&#xA;  File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt;&#xD;&#xA;TypeError: &amp;#39;tuple&amp;#39; object does not support item assignment&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;可是，如果你想对已有的元组做任何&amp;quot;改变&amp;quot;，该怎么办呢？那就只能重新开辟一块内存，创建新的元组了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字典、集合，你真的了解吗？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/04---%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/04---%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;前面的课程，我们学习了Python中的列表和元组，了解了他们的基本操作和性能比较。这节课，我们再来学习两个同样很常见并且很有用的数据结构：字典（dict）和集合（set）。字典和集合在Python被广泛使用，并且性能进行了高度优化，其重要性不言而喻。&lt;/p&gt;&#xA;&lt;h2 id=&#34;字典和集合基础&#34;&gt;字典和集合基础 &lt;a href=&#34;#%e5%ad%97%e5%85%b8%e5%92%8c%e9%9b%86%e5%90%88%e5%9f%ba%e7%a1%80&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;那究竟什么是字典，什么是集合呢？字典是一系列由键（key）和值（value）配对组成的元素的集合，在Python3.7+，字典被确定为有序（注意：在3.6中，字典有序是一个implementation detail，在3.7才正式成为语言特性，因此3.6中无法100%确保其有序性），而3.6之前是无序的，其长度大小可变，元素可以任意地删减和改变。&lt;/p&gt;&#xA;&lt;p&gt;相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。&lt;/p&gt;&#xA;&lt;p&gt;而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。&lt;/p&gt;&#xA;&lt;p&gt;首先我们来看字典和集合的创建，通常有下面这几种方式：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;e7ff0fb&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;d1 = {&amp;#39;name&amp;#39;: &amp;#39;jason&amp;#39;, &amp;#39;age&amp;#39;: 20, &amp;#39;gender&amp;#39;: &amp;#39;male&amp;#39;}&#xD;&#xA;d2 = dict({&amp;#39;name&amp;#39;: &amp;#39;jason&amp;#39;, &amp;#39;age&amp;#39;: 20, &amp;#39;gender&amp;#39;: &amp;#39;male&amp;#39;})&#xD;&#xA;d3 = dict([(&amp;#39;name&amp;#39;, &amp;#39;jason&amp;#39;), (&amp;#39;age&amp;#39;, 20), (&amp;#39;gender&amp;#39;, &amp;#39;male&amp;#39;)])&#xD;&#xA;d4 = dict(name=&amp;#39;jason&amp;#39;, age=20, gender=&amp;#39;male&amp;#39;) &#xD;&#xA;d1 == d2 == d3 ==d4&#xD;&#xA;True&#xD;&#xA;&#xD;&#xA;s1 = {1, 2, 3}&#xD;&#xA;s2 = set([1, 2, 3])&#xD;&#xA;s1 == s2&#xD;&#xA;True&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里注意，Python中字典和集合，无论是键还是值，都可以是混合类型。比如下面这个例子，我创建了一个元素为&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;&#39;hello&#39;&lt;/code&gt;，&lt;code&gt;5.0&lt;/code&gt;的集合：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;42670bc&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;s = {1, &amp;#39;hello&amp;#39;, 5.0}&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;再来看元素访问的问题。字典访问可以直接索引键，如果不存在，就会抛出异常：&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入浅出字符串</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/05---%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/05---%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;Python的程序中充满了字符串（string），在平常阅读代码时也屡见不鲜。字符串同样是Python中很常见的一种数据类型，比如日志的打印、程序中函数的注释、数据库的访问、变量的基本操作等等，都用到了字符串。&lt;/p&gt;&#xA;&lt;p&gt;当然，我相信你本身对字符串已经有所了解。今天这节课，我主要带你回顾一下字符串的常用操作，并对其中的一些小tricks详细地加以解释。&lt;/p&gt;&#xA;&lt;h2 id=&#34;字符串基础&#34;&gt;字符串基础 &lt;a href=&#34;#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%9f%ba%e7%a1%80&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;什么是字符串呢？字符串是由独立字符组成的一个序列，通常包含在单引号（&lt;code&gt;&#39;&#39;&lt;/code&gt;）双引号（&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;）或者三引号之中（&lt;code&gt;&#39;&#39;&#39; &#39;&#39;&#39;&lt;/code&gt;或&lt;code&gt;&amp;quot;&amp;quot;&amp;quot; &amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;，两者一样），比如下面几种写法。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;de8c86e&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;name = &amp;#39;jason&amp;#39;&#xD;&#xA;city = &amp;#39;beijing&amp;#39;&#xD;&#xA;text = &amp;#34;welcome to jike shijian&amp;#34;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里定义了name、city和text三个变量，都是字符串类型。我们知道，Python中单引号、双引号和三引号的字符串是一模一样的，没有区别，比如下面这个例子中的s1、s2、s3完全一样。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;d9bedfe&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;s1 = &amp;#39;hello&amp;#39;&#xD;&#xA;s2 = &amp;#34;hello&amp;#34;&#xD;&#xA;s3 = &amp;#34;&amp;#34;&amp;#34;hello&amp;#34;&amp;#34;&amp;#34;&#xD;&#xA;s1 == s2 == s3&#xD;&#xA;True&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;Python同时支持这三种表达方式，很重要的一个原因就是，这样方便你在字符串中，内嵌带引号的字符串。比如：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;4ceddcc&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;&amp;#34;I&amp;#39;m a student&amp;#34;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;Python的三引号字符串，则主要应用于多行字符串的情境，比如函数的注释等等。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;21bba73&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;def calculate_similarity(item1, item2):&#xD;&#xA;    &amp;#34;&amp;#34;&amp;#34;&#xD;&#xA;    Calculate similarity between two items&#xD;&#xA;    Args:&#xD;&#xA;        item1: 1st item&#xD;&#xA;        item2: 2nd item&#xD;&#xA;    Returns:&#xD;&#xA;      similarity score between item1 and item2&#xD;&#xA;    &amp;#34;&amp;#34;&amp;#34;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;同时，Python也支持转义字符。所谓的转义字符，就是用反斜杠开头的字符串，来表示一些特定意义的字符。我把常见的的转义字符，总结成了下面这张表格。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python “黑箱”：输入与输出</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/06---python-%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/06---python-%E9%BB%91%E7%AE%B1%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;世纪之交的论坛上曾有一句流行语：在互联网上，没人知道你是一条狗。互联网刚刚兴起时，一根网线链接到你家，信息通过这条高速线缆直达你的屏幕，你通过键盘飞速回应朋友的消息，信息再次通过网线飞入错综复杂的虚拟世界，再进入朋友家。抽象来看，一台台的电脑就是一个个黑箱，黑箱有了输入和输出，就拥有了图灵机运作的必要条件。&lt;/p&gt;&#xA;&lt;p&gt;Python 程序也是一个黑箱：通过输入流将数据送达，通过输出流将处理后的数据送出，可能 Python 解释器后面藏了一个人，还是一个史莱哲林？No one cares。&lt;/p&gt;&#xA;&lt;p&gt;好了废话不多说，今天我们就由浅及深讲讲 Python 的输入和输出。&lt;/p&gt;&#xA;&lt;h2 id=&#34;输入输出基础&#34;&gt;输入输出基础 &lt;a href=&#34;#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e5%9f%ba%e7%a1%80&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;最简单直接的输入来自键盘操作，比如下面这个例子。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;b156b7e&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;name = input(&amp;#39;your name:&amp;#39;)&#xD;&#xA;gender = input(&amp;#39;you are a boy?(y/n)&amp;#39;)&#xD;&#xA;&#xD;&#xA;###### 输入 ######&#xD;&#xA;your name:Jack&#xD;&#xA;you are a boy?&#xD;&#xA;&#xD;&#xA;welcome_str = &amp;#39;Welcome to the matrix {prefix} {name}.&amp;#39;&#xD;&#xA;welcome_dic = {&#xD;&#xA;    &amp;#39;prefix&amp;#39;: &amp;#39;Mr.&amp;#39; if gender == &amp;#39;y&amp;#39; else &amp;#39;Mrs&amp;#39;,&#xD;&#xA;    &amp;#39;name&amp;#39;: name&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;print(&amp;#39;authorizing...&amp;#39;)&#xD;&#xA;print(welcome_str.format(**welcome_dic))&#xD;&#xA;&#xD;&#xA;########## 输出 ##########&#xD;&#xA;authorizing...&#xD;&#xA;Welcome to the matrix Mr. Jack.&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;input() 函数暂停程序运行，同时等待键盘输入；直到回车被按下，函数的参数即为提示语，输入的类型永远是字符串型（str）。注意，初学者在这里很容易犯错，下面的例子我会讲到。print() 函数则接受字符串、数字、字典、列表甚至一些自定义类的输出。&lt;/p&gt;</description>
    </item>
    <item>
      <title>修炼基本功：条件与循环</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/07---%E4%BF%AE%E7%82%BC%E5%9F%BA%E6%9C%AC%E5%8A%9F%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/07---%E4%BF%AE%E7%82%BC%E5%9F%BA%E6%9C%AC%E5%8A%9F%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;前面几节，我们一起学习了列表、元组、字典、集合和字符串等一系列Python的基本数据类型。但是，如何把这一个个基本的数据结构类型串接起来，组成一手漂亮的代码呢？这就是我们今天所要讨论的“条件与循环”。&lt;/p&gt;&#xA;&lt;p&gt;我习惯把“条件与循环”，叫做编程中的基本功。为什么称它为基本功呢？因为它控制着代码的逻辑，可以说是程序的中枢系统。如果把写程序比作盖楼房，那么条件与循环就是楼房的根基，其他所有东西都是在此基础上构建而成。&lt;/p&gt;&#xA;&lt;p&gt;毫不夸张地说，写一手简洁易读的条件与循环代码，对提高程序整体的质量至关重要。&lt;/p&gt;&#xA;&lt;h2 id=&#34;条件语句&#34;&gt;条件语句 &lt;a href=&#34;#%e6%9d%a1%e4%bb%b6%e8%af%ad%e5%8f%a5&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;首先，我们一起来看一下Python的条件语句，用法很简单。比如，我想要表示y=|x|这个函数，那么相应的代码便是：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;8df625d&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;# y = |x|&#xD;&#xA;if x &amp;lt; 0:&#xD;&#xA;    y = -x&#xD;&#xA;else:&#xD;&#xA;    y = x&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;和其他语言不一样，我们不能在条件语句中加括号，写成下面这样的格式。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;5dee4e9&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;if (x &amp;lt; 0)&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;但需要注意的是，在条件语句的末尾必须加上冒号（:），这是Python特定的语法规范。&lt;/p&gt;&#xA;&lt;p&gt;由于Python不支持switch语句，因此，当存在多个条件判断时，我们需要用else if来实现，这在Python中的表达是&lt;strong&gt;elif&lt;/strong&gt;。语法如下：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;fdb5887&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;if condition_1:&#xD;&#xA;    statement_1&#xD;&#xA;elif condition_2:&#xD;&#xA;    statement_2&#xD;&#xA;...&#xD;&#xA;elif condition_i:&#xD;&#xA;    statement_i&#xD;&#xA;else:&#xD;&#xA;    statement_n&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;整个条件语句是顺序执行的，如果遇到一个条件满足，比如condition_i满足时，在执行完statement_i后，便会退出整个if、elif、else条件语句，而不会继续向下执行。这个语句在工作中很常用，比如下面的这个例子。&lt;/p&gt;&#xA;&lt;p&gt;实际工作中，我们经常用ID表示一个事物的属性，然后进行条件判断并且输出。比如，在integrity的工作中，通常用0、1、2分别表示一部电影的色情暴力程度。其中，0的程度最高，是red级别；1其次，是yellow级别；2代表没有质量问题，属于green。&lt;/p&gt;&#xA;&lt;p&gt;如果给定一个ID，要求输出某部电影的质量评级，则代码如下：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;b79c0d7&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;if id == 0:&#xD;&#xA;    print(&amp;#39;red&amp;#39;)&#xD;&#xA;elif id == 1:&#xD;&#xA;    print(&amp;#39;yellow&amp;#39;)&#xD;&#xA;else:&#xD;&#xA;    print(&amp;#39;green&amp;#39;)  &lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;不过要注意，if语句是可以单独使用的，但elif、else都必须和if成对使用。&lt;/p&gt;&#xA;&lt;p&gt;另外，在我们进行条件判断时， 不少人喜欢省略判断的条件，比如写成下面这样：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;9c97bb5&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;if s: # s is a string&#xD;&#xA;    ...&#xD;&#xA;if l: # l is a list&#xD;&#xA;    ...&#xD;&#xA;if i: # i is an int&#xD;&#xA;    ...&#xD;&#xA;... &lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;关于省略判断条件的常见用法，我大概总结了一下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>异常处理：如何提高程序的稳定性？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/08---%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/08---%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;今天这节课，我想和你聊聊Python的异常处理。和其他语言一样，异常处理是Python中一种很常见，并且很重要的机制与代码规范。&lt;/p&gt;&#xA;&lt;p&gt;我在实际工作中，见过很多次这样的情况：一位工程师提交了代码，不过代码某处忘记了异常处理。碰巧这种异常发生的频率不低，所以在代码push到线上后没多久，就会收到紧急通知——服务器崩溃了。&lt;/p&gt;&#xA;&lt;p&gt;如果事情严重，对用户的影响也很大，这位工程师还得去专门的会议上做自我检讨，可以说是很惨了。这类事件层出不穷，也告诉我们，正确理解和处理程序中的异常尤为关键。&lt;/p&gt;&#xA;&lt;h2 id=&#34;错误与异常&#34;&gt;&lt;strong&gt;错误与异常&lt;/strong&gt; &lt;a href=&#34;#%e9%94%99%e8%af%af%e4%b8%8e%e5%bc%82%e5%b8%b8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;首先要了解，Python中的错误和异常是什么？两者之间又有什么联系和区别呢？&lt;/p&gt;&#xA;&lt;p&gt;通常来说，程序中的错误至少包括两种，一种是语法错误，另一种则是异常。&lt;/p&gt;&#xA;&lt;p&gt;所谓语法错误，你应该很清楚，也就是你写的代码不符合编程规范，无法被识别与执行，比如下面这个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;13071a6&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;if name is not None&#xD;&#xA;    print(name)&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;If语句漏掉了冒号，不符合Python的语法规范，所以程序就会报错&lt;code&gt;invalid syntax&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;而异常则是指程序的语法正确，也可以被执行，但在执行过程中遇到了错误，抛出了异常，比如下面的3个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;288da6e&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;10 / 0&#xD;&#xA;Traceback (most recent call last):&#xD;&#xA;  File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt;&#xD;&#xA;ZeroDivisionError: integer division or modulo by zero&#xD;&#xA;&#xD;&#xA;order * 2&#xD;&#xA;Traceback (most recent call last):&#xD;&#xA;  File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt;&#xD;&#xA;NameError: name &amp;#39;order&amp;#39; is not defined&#xD;&#xA;&#xD;&#xA;1 &amp;#43; [1, 2]&#xD;&#xA;Traceback (most recent call last):&#xD;&#xA;  File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt;&#xD;&#xA;TypeError: unsupported operand type(s) for &amp;#43;: &amp;#39;int&amp;#39; and &amp;#39;list&amp;#39;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;它们语法完全正确，但显然，我们不能做除法时让分母为0；也不能使用未定义的变量做运算；而让一个整型和一个列表相加也是不可取的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>不可或缺的自定义函数</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/09---%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/09---%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;实际工作生活中，我曾见到不少初学者编写的Python程序，他们长达几百行的代码中，却没有一个函数，通通按顺序堆到一块儿，不仅让人读起来费时费力，往往也是错误连连。&lt;/p&gt;&#xA;&lt;p&gt;一个规范的值得借鉴的Python程序，除非代码量很少（比如10行、20行以下），基本都应该由多个函数组成，这样的代码才更加模块化、规范化。&lt;/p&gt;&#xA;&lt;p&gt;函数是Python程序中不可或缺的一部分。事实上，在前面的学习中，我们已经用到了很多Python的内置函数，比如sorted()表示对一个集合序列排序，len()表示返回一个集合序列的长度大小等等。这节课，我们主要来学习Python的自定义函数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;函数基础&#34;&gt;函数基础 &lt;a href=&#34;#%e5%87%bd%e6%95%b0%e5%9f%ba%e7%a1%80&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;那么，到底什么是函数，如何在Python程序中定义函数呢？&lt;/p&gt;&#xA;&lt;p&gt;说白了，函数就是为了实现某一功能的代码段，只要写好以后，就可以重复利用。我们先来看下面一个简单的例子:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;d073150&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;def my_func(message):&#xD;&#xA;    print(&amp;#39;Got a message: {}&amp;#39;.format(message))&#xD;&#xA;&#xD;&#xA;# 调用函数 my_func()&#xD;&#xA;my_func(&amp;#39;Hello World&amp;#39;)&#xD;&#xA;# 输出&#xD;&#xA;Got a message: Hello World&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;def是函数的声明；&lt;/li&gt;&#xA;&lt;li&gt;my_func是函数的名称；&lt;/li&gt;&#xA;&lt;li&gt;括号里面的message则是函数的参数；&lt;/li&gt;&#xA;&lt;li&gt;而print那行则是函数的主体部分，可以执行相应的语句；&lt;/li&gt;&#xA;&lt;li&gt;在函数最后，你可以返回调用结果（return或yield），也可以不返回。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;总结一下，大概是下面的这种形式：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;ef23ca2&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;def name(param1, param2, ..., paramN):&#xD;&#xA;    statements&#xD;&#xA;    return/yield value # optional&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;和其他需要编译的语言（比如C语言）不一样的是，def是可执行语句，这意味着函数直到被调用前，都是不存在的。当程序调用函数时，def语句才会创建一个新的函数对象，并赋予其名字。&lt;/p&gt;&#xA;&lt;p&gt;我们一起来看几个例子，加深你对函数的印象：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;0c1c0ba&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;def my_sum(a, b):&#xD;&#xA;    return a &amp;#43; b&#xD;&#xA;&#xD;&#xA;result = my_sum(3, 5)&#xD;&#xA;print(result)&#xD;&#xA;&#xD;&#xA;# 输出&#xD;&#xA;8&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里，我们定义了my_sum()这个函数，它有两个参数a和b，作用是相加；随后，调用my_sum()函数，分别把3和5赋于a和b；最后，返回其相加的值，赋于变量result，并输出得到8。&lt;/p&gt;&#xA;&lt;p&gt;再来看一个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;b337b7c&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;def find_largest_element(l):&#xD;&#xA;    if not isinstance(l, list):&#xD;&#xA;        print(&amp;#39;input is not type of list&amp;#39;)&#xD;&#xA;        return&#xD;&#xA;    if len(l) == 0:&#xD;&#xA;        print(&amp;#39;empty input&amp;#39;)&#xD;&#xA;        return&#xD;&#xA;    largest_element = l[0]&#xD;&#xA;    for item in l:&#xD;&#xA;        if item &amp;gt; largest_element:&#xD;&#xA;            largest_element = item&#xD;&#xA;    print(&amp;#39;largest element is: {}&amp;#39;.format(largest_element)) &#xD;&#xA;      &#xD;&#xA;find_largest_element([8, 1,-3, 2, 0])&#xD;&#xA;&#xD;&#xA;# 输出&#xD;&#xA;largest element is: 8&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这个例子中，我们定义了函数find_largest_element，作用是遍历输入的列表，找出最大的值并打印。因此，当我们调用它，并传递列表 [8, 1, -3, 2, 0] 作为参数时，程序就会输出 &lt;code&gt;largest element is: 8&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>简约不简单的匿名函数</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/10---%E7%AE%80%E7%BA%A6%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/10---%E7%AE%80%E7%BA%A6%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;上一节，我们一起学习了Python中的“常规”函数，用途十分广泛。不过，除了常规函数，你应该也会在代码中见到一些“非常规”函数，它们往往很简短，就一行，并且有个很酷炫的名字——lambda，没错，这就是匿名函数。&lt;/p&gt;&#xA;&lt;p&gt;匿名函数在实际工作中同样举足轻重，正确地运用匿名函数，能让我们的代码更简洁、易读。这节课，我们继续Python的函数之旅，一起来学习这个简约而不简单的匿名函数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;匿名函数基础&#34;&gt;匿名函数基础 &lt;a href=&#34;#%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0%e5%9f%ba%e7%a1%80&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;首先，什么是匿名函数呢？以下是匿名函数的格式：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;c3fccdd&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;lambda argument1, argument2,... argumentN : expression&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;我们可以看到，匿名函数的关键字是lambda，之后是一系列的参数，然后用冒号隔开，最后则是由这些参数组成的表达式。我们通过几个例子看一下它的用法：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;2edc004&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;square = lambda x: x**2&#xD;&#xA;square(3)&#xD;&#xA;&#xD;&#xA;9&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里的匿名函数只输入一个参数x，输出则是输入x的平方。因此当输入是3时，输出便是9。如果把这个匿名函数写成常规函数的形式，则是下面这样：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;49b5315&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;def square(x):&#xD;&#xA;    return x**2&#xD;&#xA;square(3)&#xD;&#xA; &#xD;&#xA;9&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;可以看到，匿名函数lambda和常规函数一样，返回的都是一个函数对象（function object），它们的用法也极其相似，不过还是有下面几点区别。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;第一，lambda是一个表达式（expression），并不是一个语句（statement）&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所谓的表达式，就是用一系列“公式”去表达一个东西，比如&lt;code&gt;x + 2&lt;/code&gt;、 &lt;code&gt;x**2&lt;/code&gt;等等；&lt;/li&gt;&#xA;&lt;li&gt;而所谓的语句，则一定是完成了某些功能，比如赋值语句&lt;code&gt;x = 1&lt;/code&gt;完成了赋值，print语句&lt;code&gt;print(x)&lt;/code&gt;完成了打印，条件语句 &lt;code&gt;if x &amp;lt; 0:&lt;/code&gt;完成了选择功能等等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;因此，lambda可以用在一些常规函数def不能用的地方，比如，lambda可以用在列表内部，而常规函数却不能：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;c5717c9&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;[(lambda x: x*x)(x) for x in range(10)]&#xD;&#xA;# 输出&#xD;&#xA;[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;再比如，lambda可以被用作某些函数的参数，而常规函数def也不能：&lt;/p&gt;</description>
    </item>
    <item>
      <title>面向对象（上）：从生活中的类比说起</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/11---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A%E4%BB%8E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%AF%94%E8%AF%B4%E8%B5%B7/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/11---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A%E4%BB%8E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%AF%94%E8%AF%B4%E8%B5%B7/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;很多朋友最开始学编程的时候，是从 C++ 或者 JAVA 语言入手的。他们好不容易磕磕绊绊地搞懂了最基本的数据类型、赋值判断和循环，却又迎面撞上了 OOP (object oriented programming) 的大墙，一头扎进公有私有保护、多重继承、多态派生、纯函数、抽象类、友元函数等一堆专有名词的汪洋大海中找不到彼岸，于是就放弃了进阶之路。&lt;/p&gt;&#xA;&lt;p&gt;相比之下，Python 是一门相对友好的语言，它在创立之初就鼓励命令交互式的轻量级编程。理论上，Python 的命令式语言是&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;图灵完备&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;的, 也就是说命令式语言，理论上可以做到其他任何语言能够做到的所有的事情，甚至进一步，仅仅依靠汇编语言的 MOV 指令，就能实现&lt;a href=&#34;http://stedolan.net/research/mov.pdf&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;图灵完备编程&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>面向对象（下）：如何实现一个搜索引擎？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/12---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/12---%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</guid>
      <description>&lt;p&gt;你好，我是景霄。这节课，我们来实现一个 Python 的搜索引擎（search engine）。&lt;/p&gt;&#xA;&lt;p&gt;承接上文，今天这节课的主要目的是，带你模拟敏捷开发过程中的迭代开发流程，巩固面向对象的程序设计思想。&lt;/p&gt;&#xA;&lt;p&gt;我们将从最简单最直接的搜索做起，一步步优化，这其中，我不会涉及到过多的超纲算法，但不可避免会介绍一些现代搜索引擎中的基础概念，例如语料（corpus）、倒序索引（inverted index）等。&lt;/p&gt;&#xA;&lt;p&gt;如果你对这方面本身有些了解，自然可以轻松理解；即使你之前完全没接触过搜索引擎，也不用过分担心，我会力求简洁清晰，降低学习难度。同时，我希望你把更多的精力放在面向对象的建模思路上。&lt;/p&gt;&#xA;&lt;h2 id=&#34;高大上的搜索引擎&#34;&gt;“高大上”的搜索引擎 &lt;a href=&#34;#%e9%ab%98%e5%a4%a7%e4%b8%8a%e7%9a%84%e6%90%9c%e7%b4%a2%e5%bc%95%e6%93%8e&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;引擎一词尤如其名，听起来非常酷炫。搜索引擎，则是新世纪初期互联网发展最重要的入口之一，依托搜索引擎，中国和美国分别诞生了百度、谷歌等巨型公司。&lt;/p&gt;&#xA;&lt;p&gt;搜索引擎极大地方便了互联网生活，也成为上网必不可少的刚需工具。依托搜索引擎发展起来的互联网广告，则成了硅谷和中国巨头的核心商业模式；而搜索本身，也在持续进步着， Facebook 和微信也一直有意向在自家社交产品架设搜索平台。&lt;/p&gt;&#xA;&lt;p&gt;关于搜索引擎的价值我不必多说了，今天我们主要来看一下搜索引擎的核心构成。&lt;/p&gt;&#xA;&lt;p&gt;听Google的朋友说，他们入职培训的时候，有一门课程叫做 The life of a query，内容是讲用户在浏览器中键入一串文字，按下回车后发生了什么。今天我也按照这个思路，来简单介绍下。&lt;/p&gt;&#xA;&lt;p&gt;我们知道，&lt;strong&gt;一个搜索引擎由搜索器、索引器、检索器和用户接口四个部分组成&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;搜索器，通俗来讲就是我们常提到的爬虫（scrawler），它能在互联网上大量爬取各类网站的内容，送给索引器。索引器拿到网页和内容后，会对内容进行处理，形成索引（index），存储于内部的数据库等待检索。&lt;/p&gt;&#xA;&lt;p&gt;最后的用户接口很好理解，是指网页和 App 前端界面，例如百度和谷歌的搜索页面。用户通过用户接口，向搜索引擎发出询问（query），询问解析后送达检索器；检索器高效检索后，再将结果返回给用户。&lt;/p&gt;&#xA;&lt;p&gt;爬虫知识不是我们今天学习的重点，这里我就不做深入介绍了。我们假设搜索样本存在于本地磁盘上。&lt;/p&gt;&#xA;&lt;p&gt;为了方便，我们只提供五个文件的检索，内容我放在了下面这段代码中：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;857ec3b&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;# 1.txt&#xD;&#xA;I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character. I have a dream today.&#xD;&#xA;&#xD;&#xA;# 2.txt&#xD;&#xA;I have a dream that one day down in Alabama, with its vicious racists, . . . one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers. I have a dream today.&#xD;&#xA;&#xD;&#xA;# 3.txt&#xD;&#xA;I have a dream that one day every valley shall be exalted, every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight, and the glory of the Lord shall be revealed, and all flesh shall see it together.&#xD;&#xA;&#xD;&#xA;# 4.txt&#xD;&#xA;This is our hope. . . With this faith we will be able to hew out of the mountain of despair a stone of hope. With this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day. . . .&#xD;&#xA;&#xD;&#xA;# 5.txt&#xD;&#xA;And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God&amp;#39;s children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual: &amp;#34;Free at last! Free at last! Thank God Almighty, we are free at last!&amp;#34;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;我们先来定义 SearchEngineBase 基类。这里我先给出了具体的代码，你不必着急操作，还是那句话，跟着节奏慢慢学，再难的东西也可以啃得下来。&lt;/p&gt;</description>
    </item>
    <item>
      <title>搭建积木：Python 模块化</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/13---%E6%90%AD%E5%BB%BA%E7%A7%AF%E6%9C%A8python-%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/13---%E6%90%AD%E5%BB%BA%E7%A7%AF%E6%9C%A8python-%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;这是基础版块的最后一节。到目前为止，你已经掌握了 Python 这一门当代武功的基本招式和套路，走出了新手村，看到了更远的世界，有了和这个世界过过招的冲动。&lt;/p&gt;&#xA;&lt;p&gt;于是，你可能开始尝试写一些不那么简单的系统性工程，或者代码量较大的应用程序。这时候，简单的一个 py 文件已经过于臃肿，无法承担一个重量级软件开发的重任。&lt;/p&gt;&#xA;&lt;p&gt;今天这节课的主要目的，就是化繁为简，将功能模块化、文件化，从而可以像搭积木一样，将不同的功能，组件在大型工程中搭建起来。&lt;/p&gt;&#xA;&lt;h2 id=&#34;简单模块化&#34;&gt;简单模块化 &lt;a href=&#34;#%e7%ae%80%e5%8d%95%e6%a8%a1%e5%9d%97%e5%8c%96&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;说到最简单的模块化方式，你可以把函数、类、常量拆分到不同的文件，把它们放在同一个文件夹，然后使用 &lt;code&gt;from your_file import function_name, class_name&lt;/code&gt; 的方式调用。之后，这些函数和类就可以在文件内直接使用了。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;202de5e&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;# utils.py&#xD;&#xA;&#xD;&#xA;def get_sum(a, b):&#xD;&#xA;    return a &amp;#43; b&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;ce9c99d&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;# class_utils.py&#xD;&#xA;&#xD;&#xA;class Encoder(object):&#xD;&#xA;    def encode(self, s):&#xD;&#xA;        return s[::-1]&#xD;&#xA;&#xD;&#xA;class Decoder(object):&#xD;&#xA;    def decode(self, s):&#xD;&#xA;        return &amp;#39;&amp;#39;.join(reversed(list(s)))&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;902a16d&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;# main.py&#xD;&#xA;&#xD;&#xA;from utils import get_sum&#xD;&#xA;from class_utils import *&#xD;&#xA;&#xD;&#xA;print(get_sum(1, 2))&#xD;&#xA;&#xD;&#xA;encoder = Encoder()&#xD;&#xA;decoder = Decoder()&#xD;&#xA;&#xD;&#xA;print(encoder.encode(&amp;#39;abcde&amp;#39;))&#xD;&#xA;print(decoder.decode(&amp;#39;edcba&amp;#39;))&#xD;&#xA;&#xD;&#xA;########## 输出 ##########&#xD;&#xA;&#xD;&#xA;3&#xD;&#xA;edcba&#xD;&#xA;abcde&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;我们来看这种方式的代码：get_sum() 函数定义在 utils.py，Encoder 和 Decoder 类则在 class_utils.py，我们在 main 函数直接调用 from import ，就可以将我们需要的东西 import 过来。&lt;/p&gt;</description>
    </item>
    <item>
      <title>答疑（一）：列表和元组的内部实现是怎样的？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/14---%E7%AD%94%E7%96%91%E4%B8%80%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/14---%E7%AD%94%E7%96%91%E4%B8%80%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;转眼间，专栏上线已经一个月了，而我们也在不知不觉中完成了第一大章基础篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。&lt;/p&gt;&#xA;&lt;p&gt;大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很典型的问题，我专门摘录了出来，作为今天的答疑内容，集中回复。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题一列表和元组的内部实现&#34;&gt;问题一：列表和元组的内部实现 &lt;a href=&#34;#%e9%97%ae%e9%a2%98%e4%b8%80%e5%88%97%e8%a1%a8%e5%92%8c%e5%85%83%e7%bb%84%e7%9a%84%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;第一个问题，是胡峣同学提出的，有关列表（list）和元组（tuple）的内部实现，想知道里边是linked list 或array，还是把array linked一下这样的方式？&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/8fb9cf6bf14357104c88454eefaaeca2_4043703205532930496.png&#34; alt=&#34;&#34; width=&#34;1404&#34; height=&#34;162&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;关于这个问题，我们可以分别从源码来看。&lt;/p&gt;&#xA;&lt;p&gt;先来看 Python 3.7 的list源码。你可以先自己阅读下面两个链接里的内容。&lt;/p&gt;&#xA;&lt;p&gt;listobject.h：&lt;a href=&#34;https://github.com/python/cpython/blob/949fe976d5c62ae63ed505ecf729f815d0baccfc/Include/listobject.h#L23&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;https://github.com/python/cpython/blob/949fe976d5c62ae63ed505ecf729f815d0baccfc/Include/listobject.h#L23&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;listobject.c: &lt;a href=&#34;https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/listobject.c#L33&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;https://github.com/python/cpython/blob/3d75bd15ac82575967db367c517d7e6e703a6de3/Objects/listobject.c#L33&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python对象的比较、拷贝</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/15---python%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/15---python%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E6%8B%B7%E8%B4%9D/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;在前面的学习中，我们其实已经接触到了很多 Python对象比较和复制的例子，比如下面这个，判断a和b是否相等的if语句：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;959b506&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;if a == b:&#xD;&#xA;    ...&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;再比如第二个例子，这里l2就是l1的拷贝。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;82d97ee&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;l1 = [1, 2, 3]&#xD;&#xA;l2 = list(l1)&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;但你可能并不清楚，这些语句的背后发生了什么。比如，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;l2是l1的浅拷贝（shallow copy）还是深度拷贝（deep copy）呢？&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;a == b&lt;/code&gt;是比较两个对象的值相等，还是两个对象完全相等呢？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;关于这些的种种知识，我希望通过这节课的学习，让你有个全面的了解。&lt;/p&gt;&#xA;&lt;h2 id=&#34;-vs-is&#34;&gt;&lt;code&gt;&#39;==&#39;&lt;/code&gt; VS &lt;code&gt;&#39;is&#39;&lt;/code&gt; &lt;a href=&#34;#-vs-is&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;等于（==）和is是Python中对象比较常用的两种方式。简单来说，&lt;code&gt;&#39;==&#39;&lt;/code&gt;操作符比较对象之间的值是否相等，比如下面的例子，表示比较变量a和b所指向的值是否相等。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;ee38652&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;a == b&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;而&lt;code&gt;&#39;is&#39;&lt;/code&gt;操作符比较的是对象的身份标识是否相等，即它们是否是同一个对象，是否指向同一个内存地址。&lt;/p&gt;&#xA;&lt;p&gt;在Python中，每个对象的身份标识，都能通过函数id(object)获得。因此，&lt;code&gt;&#39;is&#39;&lt;/code&gt;操作符，相当于比较对象之间的ID是否相等，我们来看下面的例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;3d10b42&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;a = 10&#xD;&#xA;b = 10&#xD;&#xA;&#xD;&#xA;a == b&#xD;&#xA;True&#xD;&#xA;&#xD;&#xA;id(a)&#xD;&#xA;4427562448&#xD;&#xA;&#xD;&#xA;id(b)&#xD;&#xA;4427562448&#xD;&#xA;&#xD;&#xA;a is b&#xD;&#xA;True&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里，首先Python会为10这个值开辟一块内存，然后变量a和b同时指向这块内存区域，即a和b都是指向10这个变量，因此a和b的值相等，id也相等，&lt;code&gt;a == b&lt;/code&gt;和&lt;code&gt;a is b&lt;/code&gt;都返回True。&lt;/p&gt;&#xA;&lt;p&gt;不过，需要注意，对于整型数字来说，以上&lt;code&gt;a is b&lt;/code&gt;为True的结论，只适用于-5到256范围内的数字。比如下面这个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;2b6ef9c&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;a = 257&#xD;&#xA;b = 257&#xD;&#xA;&#xD;&#xA;a == b&#xD;&#xA;True&#xD;&#xA;&#xD;&#xA;id(a)&#xD;&#xA;4473417552&#xD;&#xA;&#xD;&#xA;id(b)&#xD;&#xA;4473417584&#xD;&#xA;&#xD;&#xA;a is b&#xD;&#xA;False&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里我们把257同时赋值给了a和b，可以看到&lt;code&gt;a == b&lt;/code&gt;仍然返回True，因为a和b指向的值相等。但奇怪的是，&lt;code&gt;a is b&lt;/code&gt;返回了false，并且我们发现，a和b的ID不一样了，这是为什么呢？&lt;/p&gt;</description>
    </item>
    <item>
      <title>值传递，引用传递or其他，Python里参数是如何传递的？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/16---%E5%80%BC%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92or%E5%85%B6%E4%BB%96python%E9%87%8C%E5%8F%82%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%9A%84/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/16---%E5%80%BC%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92or%E5%85%B6%E4%BB%96python%E9%87%8C%E5%8F%82%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%9A%84/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;在前面的第一大章节中，我们一起学习了Python的函数基础及其应用。我们大致明白了，所谓的传参，就是把一些参数从一个函数传递到另一个函数，从而使其执行相应的任务。但是你有没有想过，参数传递的底层是如何工作的，原理又是怎样的呢？&lt;/p&gt;&#xA;&lt;p&gt;实际工作中，很多人会遇到这样的场景：写完了代码，一测试，发现结果和自己期望的不一样，于是开始一层层地debug。花了很多时间，可到最后才发现，是传参过程中数据结构的改变，导致了程序的“出错”。&lt;/p&gt;&#xA;&lt;p&gt;比如，我将一个列表作为参数传入另一个函数，期望列表在函数运行结束后不变，但是往往“事与愿违”，由于某些操作，它的值改变了，那就很有可能带来后续程序一系列的错误。&lt;/p&gt;&#xA;&lt;p&gt;因此，了解Python中参数的传递机制，具有十分重要的意义，这往往能让我们写代码时少犯错误，提高效率。今天我们就一起来学习一下，Python中参数是如何传递的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是值传递和引用传递&#34;&gt;&lt;strong&gt;什么是值传递和引用传递&lt;/strong&gt; &lt;a href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e5%80%bc%e4%bc%a0%e9%80%92%e5%92%8c%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;如果你接触过其他的编程语言，比如C/C++，很容易想到，常见的参数传递有2种：&lt;strong&gt;值传递&lt;/strong&gt;和&lt;strong&gt;引用传递&lt;/strong&gt;。所谓值传递，通常就是拷贝参数的值，然后传递给函数里的新变量。这样，原变量和新变量之间互相独立，互不影响。&lt;/p&gt;&#xA;&lt;p&gt;比如，我们来看下面的一段C++代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;1339eb7&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;#include &amp;lt;iostream&amp;gt;&#xD;&#xA;using namespace std;&#xD;&#xA; &#xD;&#xA;// 交换2个变量的值&#xD;&#xA;void swap(int x, int y) {&#xD;&#xA;int temp;&#xD;&#xA;temp = x; // 交换x和y的值&#xD;&#xA; x = y;&#xD;&#xA; y = temp;&#xD;&#xA; return;&#xD;&#xA;}&#xD;&#xA;int main () {&#xD;&#xA; int a = 1;&#xD;&#xA; int b = 2;&#xD;&#xA; cout &amp;lt;&amp;lt; &amp;#34;Before swap, value of a :&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;&#xD;&#xA; cout &amp;lt;&amp;lt; &amp;#34;Before swap, value of b :&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;&#xD;&#xA; swap(a, b); &#xD;&#xA; cout &amp;lt;&amp;lt; &amp;#34;After swap, value of a :&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;&#xD;&#xA; cout &amp;lt;&amp;lt; &amp;#34;After swap, value of b :&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;&#xD;&#xA; return 0;&#xD;&#xA;}&#xD;&#xA;Before swap, value of a :1&#xD;&#xA;Before swap, value of b :2&#xD;&#xA;After swap, value of a :1&#xD;&#xA;After swap, value of b :2&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里的swap()函数，把a和b的值拷贝给了x和y，然后再交换x和y的值。这样一来，x和y的值发生了改变，但是a和b不受其影响，所以值不变。这种方式，就是我们所说的值传递。&lt;/p&gt;</description>
    </item>
    <item>
      <title>强大的装饰器</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/17---%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/17---%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>&lt;p&gt;你好，我是景霄。这节课，我们一起来学习装饰器。&lt;/p&gt;&#xA;&lt;p&gt;装饰器一直以来都是Python中很有用、很经典的一个feature，在工程中的应用也十分广泛，比如日志、缓存等等的任务都会用到。然而，在平常工作生活中，我发现不少人，尤其是初学者，常常因为其相对复杂的表示，对装饰器望而生畏，认为它“too fancy to learn”，实际并不如此。&lt;/p&gt;&#xA;&lt;p&gt;今天这节课，我会以前面所讲的函数、闭包为切入点，引出装饰器的概念、表达和基本用法，最后，再通过实际工程中的例子，让你再次加深理解。&lt;/p&gt;&#xA;&lt;p&gt;接下来，让我们进入正文一起学习吧！&lt;/p&gt;&#xA;&lt;h2 id=&#34;函数-装饰器&#34;&gt;函数-&amp;gt;装饰器 &lt;a href=&#34;#%e5%87%bd%e6%95%b0-%e8%a3%85%e9%a5%b0%e5%99%a8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;函数核心回顾&#34;&gt;函数核心回顾 &lt;a href=&#34;#%e5%87%bd%e6%95%b0%e6%a0%b8%e5%bf%83%e5%9b%9e%e9%a1%be&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;引入装饰器之前，我们首先一起来复习一下，必须掌握的函数的几个核心概念。&lt;/p&gt;&#xA;&lt;p&gt;第一点，我们要知道，在Python中，函数是一等公民（first-class citizen），函数也是对象。我们可以把函数赋予变量，比如下面这段代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;35d5fb3&#34; class=&#34;language-python &#34;&gt;&#xA;  &lt;code&gt;def func(message):&#xD;&#xA;    print(&amp;#39;Got a message: {}&amp;#39;.format(message))&#xD;&#xA;    &#xD;&#xA;send_message = func&#xD;&#xA;send_message(&amp;#39;hello world&amp;#39;)&#xD;&#xA;&#xD;&#xA;# 输出&#xD;&#xA;Got a message: hello world&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这个例子中，我们把函数func赋予了变量send_message，这样之后你调用send_message，就相当于是调用函数func()。&lt;/p&gt;&#xA;&lt;p&gt;第二点，我们可以把函数当作参数，传入另一个函数中，比如下面这段代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;b613169&#34; class=&#34;language-python &#34;&gt;&#xA;  &lt;code&gt;def get_message(message):&#xD;&#xA;    return &amp;#39;Got a message: &amp;#39; &amp;#43; message&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;def root_call(func, message):&#xD;&#xA;    print(func(message))&#xD;&#xA;    &#xD;&#xA;root_call(get_message, &amp;#39;hello world&amp;#39;)&#xD;&#xA;&#xD;&#xA;# 输出&#xD;&#xA;Got a message: hello world&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这个例子中，我们就把函数get_message以参数的形式，传入了函数root_call()中然后调用它。&lt;/p&gt;&#xA;&lt;p&gt;第三点，我们可以在函数里定义函数，也就是函数的嵌套。这里我同样举了一个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;c7ff8eb&#34; class=&#34;language-python &#34;&gt;&#xA;  &lt;code&gt;def func(message):&#xD;&#xA;    def get_message(message):&#xD;&#xA;        print(&amp;#39;Got a message: {}&amp;#39;.format(message))&#xD;&#xA;    return get_message(message)&#xD;&#xA;&#xD;&#xA;func(&amp;#39;hello world&amp;#39;)&#xD;&#xA;&#xD;&#xA;# 输出&#xD;&#xA;Got a message: hello world&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这段代码中，我们在函数func()里又定义了新的函数get_message()，调用后作为func()的返回值返回。&lt;/p&gt;</description>
    </item>
    <item>
      <title>metaclass，是潘多拉魔盒还是阿拉丁神灯？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/18---metaclass%E6%98%AF%E6%BD%98%E5%A4%9A%E6%8B%89%E9%AD%94%E7%9B%92%E8%BF%98%E6%98%AF%E9%98%BF%E6%8B%89%E4%B8%81%E7%A5%9E%E7%81%AF/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/18---metaclass%E6%98%AF%E6%BD%98%E5%A4%9A%E6%8B%89%E9%AD%94%E7%9B%92%E8%BF%98%E6%98%AF%E9%98%BF%E6%8B%89%E4%B8%81%E7%A5%9E%E7%81%AF/</guid>
      <description>&lt;p&gt;你好，我是蔡元楠，极客时间《大规模数据处理实战》专栏的作者。今天我想和你分享的主题是：metaclass，是潘多拉魔盒还是阿拉丁神灯？&lt;/p&gt;&#xA;&lt;p&gt;Python中有很多黑魔法，比如今天我将分享的metaclass。我认识许多人，对于这些语言特性有两种极端的观点。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一种人觉得这些语言特性太牛逼了，简直是无所不能的阿拉丁神灯，必须找机会用上才能显示自己的Python实力。&lt;/li&gt;&#xA;&lt;li&gt;另一种观点则是认为这些语言特性太危险了，会蛊惑人心去滥用，一旦打开就会释放“恶魔”，让整个代码库变得难以维护。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其实这两种看法都有道理，却又都浅尝辄止。今天，我就带你来看看，metaclass到底是潘多拉魔盒还是阿拉丁神灯？&lt;/p&gt;&#xA;&lt;p&gt;市面上的很多中文书，都把metaclass译为“元类”。我一直认为这个翻译很糟糕，所以也不想在这里称metaclass为元类。因为如果仅从字面理解，“元”是“本源”“基本”的意思，“元类”会让人以为是“基本类”。难道Python的metaclass，指的是Python 2的Object吗？这就让人一头雾水了。&lt;/p&gt;&#xA;&lt;p&gt;事实上，meta-class的meta这个词根，起源于希腊语词汇meta，包含下面两种意思：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;“Beyond”，例如技术词汇metadata，意思是描述数据的超越数据；&lt;/li&gt;&#xA;&lt;li&gt;“Change”，例如技术词汇metamorphosis，意思是改变的形态。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;metaclass，一如其名，实际上同时包含了“超越类”和“变形类”的含义，完全不是“基本类”的意思。所以，要深入理解metaclass，我们就要围绕它的&lt;strong&gt;超越变形&lt;/strong&gt;特性。接下来，我将为你展开metaclass的超越变形能力，讲清楚metaclass究竟有什么用？怎么应用？Python语言设计层面是如何实现metaclass的 ？以及使用metaclass的风险。&lt;/p&gt;&#xA;&lt;h2 id=&#34;metaclass的超越变形特性有什么用&#34;&gt;metaclass的超越变形特性有什么用？ &lt;a href=&#34;#metaclass%e7%9a%84%e8%b6%85%e8%b6%8a%e5%8f%98%e5%bd%a2%e7%89%b9%e6%80%a7%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://pyyaml.org/wiki/PyYAMLDocumentation&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;YAML&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;是一个家喻户晓的Python工具，可以方便地序列化/逆序列化结构数据。YAMLObject的一个&lt;strong&gt;超越变形能力&lt;/strong&gt;，就是它的任意子类支持序列化和反序列化（serialization &amp;amp; deserialization）。比如说下面这段代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;358bbb0&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;class Monster(yaml.YAMLObject):&#xD;&#xA;  yaml_tag = u&amp;#39;!Monster&amp;#39;&#xD;&#xA;  def __init__(self, name, hp, ac, attacks):&#xD;&#xA;    self.name = name&#xD;&#xA;    self.hp = hp&#xD;&#xA;    self.ac = ac&#xD;&#xA;    self.attacks = attacks&#xD;&#xA;  def __repr__(self):&#xD;&#xA;    return &amp;#34;%s(name=%r, hp=%r, ac=%r, attacks=%r)&amp;#34; % (&#xD;&#xA;       self.__class__.__name__, self.name, self.hp, self.ac,      &#xD;&#xA;       self.attacks)&#xD;&#xA;&#xD;&#xA;yaml.load(&amp;#34;&amp;#34;&amp;#34;&#xD;&#xA;--- !Monster&#xD;&#xA;name: Cave spider&#xD;&#xA;hp: [2,6]    # 2d6&#xD;&#xA;ac: 16&#xD;&#xA;attacks: [BITE, HURT]&#xD;&#xA;&amp;#34;&amp;#34;&amp;#34;)&#xD;&#xA;&#xD;&#xA;Monster(name=&amp;#39;Cave spider&amp;#39;, hp=[2, 6], ac=16, attacks=[&amp;#39;BITE&amp;#39;, &amp;#39;HURT&amp;#39;])&#xD;&#xA;&#xD;&#xA;print yaml.dump(Monster(&#xD;&#xA;    name=&amp;#39;Cave lizard&amp;#39;, hp=[3,6], ac=16, attacks=[&amp;#39;BITE&amp;#39;,&amp;#39;HURT&amp;#39;]))&#xD;&#xA;&#xD;&#xA;# 输出&#xD;&#xA;!Monster&#xD;&#xA;ac: 16&#xD;&#xA;attacks: [BITE, HURT]&#xD;&#xA;hp: [3, 6]&#xD;&#xA;name: Cave lizard&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里YAMLObject的特异功能体现在哪里呢？&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入理解迭代器和生成器</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/19---%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/19---%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;在第一次接触 Python 的时候，你可能写过类似 &lt;code&gt;for i in [2, 3, 5, 7, 11, 13]: print(i)&lt;/code&gt; 这样的语句。for in 语句理解起来很直观形象，比起 C++ 和 java 早期的 &lt;code&gt;for (int i = 0; i &amp;lt; n; i ++) printf(&amp;quot;%d\n&amp;quot;, a[i])&lt;/code&gt; 这样的语句，不知道简洁清晰到哪里去了。&lt;/p&gt;&#xA;&lt;p&gt;但是，你想过 Python 在处理 for in 语句的时候，具体发生了什么吗？什么样的对象可以被 for in 来枚举呢？&lt;/p&gt;&#xA;&lt;p&gt;这一节课，我们深入到 Python 的容器类型实现底层去走走，了解一种叫做迭代器和生成器的东西。&lt;/p&gt;&#xA;&lt;h2 id=&#34;你肯定用过的容器可迭代对象和迭代器&#34;&gt;你肯定用过的容器、可迭代对象和迭代器 &lt;a href=&#34;#%e4%bd%a0%e8%82%af%e5%ae%9a%e7%94%a8%e8%bf%87%e7%9a%84%e5%ae%b9%e5%99%a8%e5%8f%af%e8%bf%ad%e4%bb%a3%e5%af%b9%e8%b1%a1%e5%92%8c%e8%bf%ad%e4%bb%a3%e5%99%a8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;容器这个概念非常好理解。我们说过，在Python 中一切皆对象，对象的抽象就是类，而对象的集合就是容器。&lt;/p&gt;&#xA;&lt;p&gt;列表（list: [0, 1, 2]），元组（tuple: (0, 1, 2)），字典（dict: {0:0, 1:1, 2:2}），集合（set: set([0, 1, 2])）都是容器。对于容器，你可以很直观地想象成多个元素在一起的单元；而不同容器的区别，正是在于内部数据结构的实现方法。然后，你就可以针对不同场景，选择不同时间和空间复杂度的容器。&lt;/p&gt;&#xA;&lt;p&gt;所有的容器都是可迭代的（iterable）。这里的迭代，和枚举不完全一样。迭代可以想象成是你去买苹果，卖家并不告诉你他有多少库存。这样，每次你都需要告诉卖家，你要一个苹果，然后卖家采取行为：要么给你拿一个苹果；要么告诉你，苹果已经卖完了。你并不需要知道，卖家在仓库是怎么摆放苹果的。&lt;/p&gt;&#xA;&lt;p&gt;严谨地说，迭代器（iterator）提供了一个 next 的方法。调用这个方法后，你要么得到这个容器的下一个对象，要么得到一个 StopIteration 的错误（苹果卖完了）。你不需要像列表一样指定元素的索引，因为字典和集合这样的容器并没有索引一说。比如，字典采用哈希表实现，那么你就只需要知道，next 函数可以不重复不遗漏地一个一个拿到所有元素即可。&lt;/p&gt;</description>
    </item>
    <item>
      <title>揭秘 Python 协程</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/20---%E6%8F%AD%E7%A7%98-python-%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/20---%E6%8F%AD%E7%A7%98-python-%E5%8D%8F%E7%A8%8B/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;上一节课的最后，我们留下一个小小的悬念：生成器在 Python 2 中还扮演了一个重要角色，就是用来实现 Python 协程。&lt;/p&gt;&#xA;&lt;p&gt;那么首先你要明白，什么是协程？&lt;/p&gt;&#xA;&lt;p&gt;协程是实现并发编程的一种方式。一说并发，你肯定想到了多线程/多进程模型，没错，多线程/多进程，正是解决并发问题的经典模型之一。最初的互联网世界，多线程/多进程在服务器并发中，起到举足轻重的作用。&lt;/p&gt;&#xA;&lt;p&gt;随着互联网的快速发展，你逐渐遇到了 C10K 瓶颈，也就是同时连接到服务器的客户达到了一万个。于是很多代码跑崩了，进程上下文切换占用了大量的资源，线程也顶不住如此巨大的压力，这时， NGINX 带着事件循环出来拯救世界了。&lt;/p&gt;&#xA;&lt;p&gt;如果将多进程/多线程类比为起源于唐朝的藩镇割据，那么事件循环，就是宋朝加强的中央集权制。事件循环启动一个统一的调度器，让调度器来决定一个时刻去运行哪个任务，于是省却了多线程中启动线程、管理线程、同步锁等各种开销。同一时期的 NGINX，在高并发下能保持低资源低消耗高性能，相比 Apache 也支持更多的并发连接。&lt;/p&gt;&#xA;&lt;p&gt;再到后来，出现了一个很有名的名词，叫做回调地狱（callback hell），手撸过 JavaScript 的朋友肯定知道我在说什么。我们大家惊喜地发现，这种工具完美地继承了事件循环的优越性，同时还能提供 async / await 语法糖，解决了执行性和可读性共存的难题。于是，协程逐渐被更多人发现并看好，也有越来越多的人尝试用 Node.js 做起了后端开发。（讲个笑话，JavaScript 是一门编程语言。）&lt;/p&gt;&#xA;&lt;p&gt;回到我们的 Python。使用生成器，是 Python 2 开头的时代实现协程的老方法了，Python 3.7 提供了新的基于 asyncio 和 async / await 的方法。我们这节课，同样的，跟随时代，抛弃掉不容易理解、也不容易写的旧的基于生成器的方法，直接来讲新方法。&lt;/p&gt;&#xA;&lt;p&gt;我们先从一个爬虫实例出发，用清晰的讲解思路，带你结合实战来搞懂这个不算特别容易理解的概念。之后，我们再由浅入深，直击协程的核心。&lt;/p&gt;&#xA;&lt;h2 id=&#34;从一个爬虫说起&#34;&gt;从一个爬虫说起 &lt;a href=&#34;#%e4%bb%8e%e4%b8%80%e4%b8%aa%e7%88%ac%e8%99%ab%e8%af%b4%e8%b5%b7&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;爬虫，就是互联网的蜘蛛，在搜索引擎诞生之时，与其一同来到世上。爬虫每秒钟都会爬取大量的网页，提取关键信息后存储在数据库中，以便日后分析。爬虫有非常简单的 Python 十行代码实现，也有 Google 那样的全球分布式爬虫的上百万行代码，分布在内部上万台服务器上，对全世界的信息进行嗅探。&lt;/p&gt;&#xA;&lt;p&gt;话不多说，我们先看一个简单的爬虫例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;45f9878&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;import time&#xD;&#xA;&#xD;&#xA;def crawl_page(url):&#xD;&#xA;    print(&amp;#39;crawling {}&amp;#39;.format(url))&#xD;&#xA;    sleep_time = int(url.split(&amp;#39;_&amp;#39;)[-1])&#xD;&#xA;    time.sleep(sleep_time)&#xD;&#xA;    print(&amp;#39;OK {}&amp;#39;.format(url))&#xD;&#xA;&#xD;&#xA;def main(urls):&#xD;&#xA;    for url in urls:&#xD;&#xA;        crawl_page(url)&#xD;&#xA;&#xD;&#xA;%time main([&amp;#39;url_1&amp;#39;, &amp;#39;url_2&amp;#39;, &amp;#39;url_3&amp;#39;, &amp;#39;url_4&amp;#39;])&#xD;&#xA;&#xD;&#xA;########## 输出 ##########&#xD;&#xA;&#xD;&#xA;crawling url_1&#xD;&#xA;OK url_1&#xD;&#xA;crawling url_2&#xD;&#xA;OK url_2&#xD;&#xA;crawling url_3&#xD;&#xA;OK url_3&#xD;&#xA;crawling url_4&#xD;&#xA;OK url_4&#xD;&#xA;Wall time: 10 s&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;（注意：本节的主要目的是协程的基础概念，因此我们简化爬虫的 scrawl_page 函数为休眠数秒，休眠时间取决于 url 最后的那个数字。）&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python并发编程之Futures</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/21---python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bfutures/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/21---python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bfutures/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;无论对于哪门语言，并发编程都是一项很常用很重要的技巧。比如我们上节课所讲的很常见的爬虫，就被广泛应用在工业界的各个领域。我们每天在各个网站、各个App上获取的新闻信息，很大一部分便是通过并发编程版的爬虫获得。&lt;/p&gt;&#xA;&lt;p&gt;正确合理地使用并发编程，无疑会给我们的程序带来极大的性能提升。今天这节课，我就带你一起来学习理解、运用Python中的并发编程——Futures。&lt;/p&gt;&#xA;&lt;h2 id=&#34;区分并发和并行&#34;&gt;区分并发和并行 &lt;a href=&#34;#%e5%8c%ba%e5%88%86%e5%b9%b6%e5%8f%91%e5%92%8c%e5%b9%b6%e8%a1%8c&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在我们学习并发编程时，常常同时听到并发（Concurrency）和并行（Parallelism）这两个术语，这两者经常一起使用，导致很多人以为它们是一个意思，其实不然。&lt;/p&gt;&#xA;&lt;p&gt;首先你要辨别一个误区，在Python中，并发并不是指同一时刻有多个操作（thread、task）同时进行。相反，某个特定的时刻，它只允许有一个操作发生，只不过线程/任务之间会互相切换，直到完成。我们来看下面这张图：&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/37cbce0eb67909990d83f21642fb863f_12244711751784259465.png&#34; alt=&#34;&#34; width=&#34;1620&#34; height=&#34;524&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;图中出现了thread和task两种切换顺序的不同方式，分别对应Python中并发的两种形式——threading和asyncio。&lt;/p&gt;&#xA;&lt;p&gt;对于threading，操作系统知道每个线程的所有信息，因此它会做主在适当的时候做线程切换。很显然，这样的好处是代码容易书写，因为程序员不需要做任何切换操作的处理；但是切换线程的操作，也有可能出现在一个语句执行的过程中（比如 x += 1），这样就容易出现race condition的情况。&lt;/p&gt;&#xA;&lt;p&gt;而对于asyncio，主程序想要切换任务时，必须得到此任务可以被切换的通知，这样一来也就可以避免刚刚提到的 race condition的情况。&lt;/p&gt;&#xA;&lt;p&gt;至于所谓的并行，指的才是同一时刻、同时发生。Python中的multi-processing便是这个意思，对于multi-processing，你可以简单地这么理解：比如你的电脑是6核处理器，那么在运行程序时，就可以强制Python开6个进程，同时执行，以加快运行速度，它的原理示意图如下：&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/f6b4009c8a8589e8ec1a2bb10d4e183c_1155577536727580088.png&#34; alt=&#34;&#34; width=&#34;1590&#34; height=&#34;566&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;对比来看，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;并发通常应用于I/O操作频繁的场景，比如你要从网站上下载多个文件，I/O操作的时间可能会比CPU运行处理的时间长得多。&lt;/li&gt;&#xA;&lt;li&gt;而并行则更多应用于CPU heavy的场景，比如MapReduce中的并行计算，为了加快运行速度，一般会用多台机器、多个处理器来完成。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;并发编程之futures&#34;&gt;并发编程之Futures &lt;a href=&#34;#%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e4%b9%8bfutures&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;单线程与多线程性能比较&#34;&gt;单线程与多线程性能比较 &lt;a href=&#34;#%e5%8d%95%e7%ba%bf%e7%a8%8b%e4%b8%8e%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%80%a7%e8%83%bd%e6%af%94%e8%be%83&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;接下来，我们一起通过具体的实例，从代码的角度来理解并发编程中的Futures，并进一步来比较其与单线程的性能区别。&lt;/p&gt;&#xA;&lt;p&gt;假设我们有一个任务，是下载一些网站的内容并打印。如果用单线程的方式，它的代码实现如下所示（为了简化代码，突出主题，此处我忽略了异常处理）：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;25f1f1f&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;import requests&#xD;&#xA;import time&#xD;&#xA;&#xD;&#xA;def download_one(url):&#xD;&#xA;    resp = requests.get(url)&#xD;&#xA;    print(&amp;#39;Read {} from {}&amp;#39;.format(len(resp.content), url))&#xD;&#xA;    &#xD;&#xA;def download_all(sites):&#xD;&#xA;    for site in sites:&#xD;&#xA;        download_one(site)&#xD;&#xA;&#xD;&#xA;def main():&#xD;&#xA;    sites = [&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Arts&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:History&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Society&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Biography&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Mathematics&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Technology&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Geography&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Science&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Computer_science&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Python_(programming_language)&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Java_(programming_language)&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/PHP&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Node.js&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/The_C_Programming_Language&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Go_(programming_language)&amp;#39;&#xD;&#xA;    ]&#xD;&#xA;    start_time = time.perf_counter()&#xD;&#xA;    download_all(sites)&#xD;&#xA;    end_time = time.perf_counter()&#xD;&#xA;    print(&amp;#39;Download {} sites in {} seconds&amp;#39;.format(len(sites), end_time - start_time))&#xD;&#xA;    &#xD;&#xA;if __name__ == &amp;#39;__main__&amp;#39;:&#xD;&#xA;    main()&#xD;&#xA;&#xD;&#xA;# 输出&#xD;&#xA;Read 129886 from https://en.wikipedia.org/wiki/Portal:Arts&#xD;&#xA;Read 184343 from https://en.wikipedia.org/wiki/Portal:History&#xD;&#xA;Read 224118 from https://en.wikipedia.org/wiki/Portal:Society&#xD;&#xA;Read 107637 from https://en.wikipedia.org/wiki/Portal:Biography&#xD;&#xA;Read 151021 from https://en.wikipedia.org/wiki/Portal:Mathematics&#xD;&#xA;Read 157811 from https://en.wikipedia.org/wiki/Portal:Technology&#xD;&#xA;Read 167923 from https://en.wikipedia.org/wiki/Portal:Geography&#xD;&#xA;Read 93347 from https://en.wikipedia.org/wiki/Portal:Science&#xD;&#xA;Read 321352 from https://en.wikipedia.org/wiki/Computer_science&#xD;&#xA;Read 391905 from https://en.wikipedia.org/wiki/Python_(programming_language)&#xD;&#xA;Read 321417 from https://en.wikipedia.org/wiki/Java_(programming_language)&#xD;&#xA;Read 468461 from https://en.wikipedia.org/wiki/PHP&#xD;&#xA;Read 180298 from https://en.wikipedia.org/wiki/Node.js&#xD;&#xA;Read 56765 from https://en.wikipedia.org/wiki/The_C_Programming_Language&#xD;&#xA;Read 324039 from https://en.wikipedia.org/wiki/Go_(programming_language)&#xD;&#xA;Download 15 sites in 2.464231112999869 seconds&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这种方式应该是最直接也最简单的：&lt;/p&gt;</description>
    </item>
    <item>
      <title>并发编程之Asyncio</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/22---%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Basyncio/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/22---%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Basyncio/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;上节课，我们一起学习了Python并发编程的一种实现——多线程。今天这节课，我们继续学习Python并发编程的另一种实现方式——Asyncio。不同于协程那章，这节课我们更注重原理的理解。&lt;/p&gt;&#xA;&lt;p&gt;通过上节课的学习，我们知道，在处理I/O操作时，使用多线程与普通的单线程相比，效率得到了极大的提高。你可能会想，既然这样，为什么还需要Asyncio？&lt;/p&gt;&#xA;&lt;p&gt;诚然，多线程有诸多优点且应用广泛，但也存在一定的局限性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;比如，多线程运行过程容易被打断，因此有可能出现race condition的情况；&lt;/li&gt;&#xA;&lt;li&gt;再如，线程切换本身存在一定的损耗，线程数不能无限增加，因此，如果你的 I/O操作非常heavy，多线程很有可能满足不了高效率、高质量的需求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;正是为了解决这些问题，Asyncio应运而生。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是asyncio&#34;&gt;什么是Asyncio &lt;a href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afasyncio&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;sync-vs-async&#34;&gt;Sync VS Async &lt;a href=&#34;#sync-vs-async&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;我们首先来区分一下Sync（同步）和Async（异步）的概念。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所谓Sync，是指操作一个接一个地执行，下一个操作必须等上一个操作完成后才能执行。&lt;/li&gt;&#xA;&lt;li&gt;而Async是指不同操作间可以相互交替执行，如果其中的某个操作被block了，程序并不会等待，而是会找出可执行的操作继续执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;举个简单的例子，你的老板让你做一份这个季度的报表，并且邮件发给他。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果按照Sync的方式，你会先向软件输入这个季度的各项数据，接下来等待5min，等报表明细生成后，再写邮件发给他。&lt;/li&gt;&#xA;&lt;li&gt;但如果按照Async的方式，再你输完这个季度的各项数据后，便会开始写邮件。等报表明细生成后，你会暂停邮件，先去查看报表，确认后继续写邮件直到发送完毕。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;asyncio工作原理&#34;&gt;Asyncio工作原理 &lt;a href=&#34;#asyncio%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;明白了Sync 和Async，回到我们今天的主题，到底什么是Asyncio呢？&lt;/p&gt;&#xA;&lt;p&gt;事实上，Asyncio和其他Python程序一样，是单线程的，它只有一个主线程，但是可以进行多个不同的任务（task），这里的任务，就是特殊的future对象。这些不同的任务，被一个叫做event loop的对象所控制。你可以把这里的任务，类比成多线程版本里的多个线程。&lt;/p&gt;&#xA;&lt;p&gt;为了简化讲解这个问题，我们可以假设任务只有两个状态：一是预备状态；二是等待状态。所谓的预备状态，是指任务目前空闲，但随时待命准备运行。而等待状态，是指任务已经运行，但正在等待外部的操作完成，比如I/O操作。&lt;/p&gt;&#xA;&lt;p&gt;在这种情况下，event loop会维护两个任务列表，分别对应这两种状态；并且选取预备状态的一个任务（具体选取哪个任务，和其等待的时间长短、占用的资源等等相关），使其运行，一直到这个任务把控制权交还给event loop为止。&lt;/p&gt;&#xA;&lt;p&gt;当任务把控制权交还给event loop时，event loop会根据其是否完成，把任务放到预备或等待状态的列表，然后遍历等待状态列表的任务，查看他们是否完成。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果完成，则将其放到预备状态的列表；&lt;/li&gt;&#xA;&lt;li&gt;如果未完成，则继续放在等待状态的列表。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;而原先在预备状态列表的任务位置仍旧不变，因为它们还未运行。&lt;/p&gt;&#xA;&lt;p&gt;这样，当所有任务被重新放置在合适的列表后，新一轮的循环又开始了：event loop继续从预备状态的列表中选取一个任务使其执行…如此周而复始，直到所有任务完成。&lt;/p&gt;&#xA;&lt;p&gt;值得一提的是，对于Asyncio来说，它的任务在运行时不会被外部的一些因素打断，因此Asyncio内的操作不会出现race condition的情况，这样你就不需要担心线程安全的问题了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;asyncio用法&#34;&gt;Asyncio用法 &lt;a href=&#34;#asyncio%e7%94%a8%e6%b3%95&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;讲完了Asyncio的原理，我们结合具体的代码来看一下它的用法。还是以上节课下载网站内容为例，用Asyncio的写法我放在了下面代码中（省略了异常处理的一些操作），接下来我们一起来看：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;249835b&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;import asyncio&#xD;&#xA;import aiohttp&#xD;&#xA;import time&#xD;&#xA;&#xD;&#xA;async def download_one(url):&#xD;&#xA;    async with aiohttp.ClientSession() as session:&#xD;&#xA;        async with session.get(url) as resp:&#xD;&#xA;            print(&amp;#39;Read {} from {}&amp;#39;.format(resp.content_length, url))&#xD;&#xA;&#xD;&#xA;async def download_all(sites):&#xD;&#xA;    tasks = [asyncio.create_task(download_one(site)) for site in sites]&#xD;&#xA;    await asyncio.gather(*tasks)&#xD;&#xA;&#xD;&#xA;def main():&#xD;&#xA;    sites = [&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Arts&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:History&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Society&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Biography&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Mathematics&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Technology&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Geography&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Portal:Science&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Computer_science&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Python_(programming_language)&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Java_(programming_language)&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/PHP&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Node.js&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/The_C_Programming_Language&amp;#39;,&#xD;&#xA;        &amp;#39;https://en.wikipedia.org/wiki/Go_(programming_language)&amp;#39;&#xD;&#xA;    ]&#xD;&#xA;    start_time = time.perf_counter()&#xD;&#xA;    asyncio.run(download_all(sites))&#xD;&#xA;    end_time = time.perf_counter()&#xD;&#xA;    print(&amp;#39;Download {} sites in {} seconds&amp;#39;.format(len(sites), end_time - start_time))&#xD;&#xA;    &#xD;&#xA;if __name__ == &amp;#39;__main__&amp;#39;:&#xD;&#xA;    main()&#xD;&#xA;&#xD;&#xA;## 输出&#xD;&#xA;Read 63153 from https://en.wikipedia.org/wiki/Java_(programming_language)&#xD;&#xA;Read 31461 from https://en.wikipedia.org/wiki/Portal:Society&#xD;&#xA;Read 23965 from https://en.wikipedia.org/wiki/Portal:Biography&#xD;&#xA;Read 36312 from https://en.wikipedia.org/wiki/Portal:History&#xD;&#xA;Read 25203 from https://en.wikipedia.org/wiki/Portal:Arts&#xD;&#xA;Read 15160 from https://en.wikipedia.org/wiki/The_C_Programming_Language&#xD;&#xA;Read 28749 from https://en.wikipedia.org/wiki/Portal:Mathematics&#xD;&#xA;Read 29587 from https://en.wikipedia.org/wiki/Portal:Technology&#xD;&#xA;Read 79318 from https://en.wikipedia.org/wiki/PHP&#xD;&#xA;Read 30298 from https://en.wikipedia.org/wiki/Portal:Geography&#xD;&#xA;Read 73914 from https://en.wikipedia.org/wiki/Python_(programming_language)&#xD;&#xA;Read 62218 from https://en.wikipedia.org/wiki/Go_(programming_language)&#xD;&#xA;Read 22318 from https://en.wikipedia.org/wiki/Portal:Science&#xD;&#xA;Read 36800 from https://en.wikipedia.org/wiki/Node.js&#xD;&#xA;Read 67028 from https://en.wikipedia.org/wiki/Computer_science&#xD;&#xA;Download 15 sites in 0.062144195078872144 seconds&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里的Async和await关键字是Asyncio的最新写法，表示这个语句/函数是non-block的，正好对应前面所讲的event loop的概念。如果任务执行的过程需要等待，则将其放入等待状态的列表中，然后继续执行预备状态列表里的任务。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你真的懂Python GIL（全局解释器锁）吗？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/23---%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82python-gil%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%E5%90%97/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/23---%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82python-gil%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%E5%90%97/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;前面几节课，我们学习了Python的并发编程特性，也了解了多线程编程。事实上，Python多线程另一个很重要的话题——GIL（Global Interpreter Lock，即全局解释器锁）却鲜有人知，甚至连很多Python“老司机”都觉得GIL就是一个谜。今天我就来为你解谜，带你一起来看GIL。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一个不解之谜&#34;&gt;一个不解之谜 &lt;a href=&#34;#%e4%b8%80%e4%b8%aa%e4%b8%8d%e8%a7%a3%e4%b9%8b%e8%b0%9c&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;耳听为虚，眼见为实。我们不妨先来看一个例子，让你感受下GIL为什么会让人不明所以。&lt;/p&gt;&#xA;&lt;p&gt;比如下面这段很简单的cpu-bound代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;6dd6d1b&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;def CountDown(n):&#xD;&#xA;    while n &amp;gt; 0:&#xD;&#xA;        n -= 1&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;现在，假设一个很大的数字n = 100000000，我们先来试试单线程的情况下执行CountDown(n)。在我手上这台号称8核的MacBook上执行后，我发现它的耗时为5.4s。&lt;/p&gt;&#xA;&lt;p&gt;这时，我们想要用多线程来加速，比如下面这几行操作：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;7b5b0cc&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;from threading import Thread&#xD;&#xA;&#xD;&#xA;n = 100000000&#xD;&#xA;&#xD;&#xA;t1 = Thread(target=CountDown, args=[n // 2])&#xD;&#xA;t2 = Thread(target=CountDown, args=[n // 2])&#xD;&#xA;t1.start()&#xD;&#xA;t2.start()&#xD;&#xA;t1.join()&#xD;&#xA;t2.join()&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;我又在同一台机器上跑了一下，结果发现，这不仅没有得到速度的提升，反而让运行变慢，总共花了9.6s。&lt;/p&gt;&#xA;&lt;p&gt;我还是不死心，决定使用四个线程再试一次，结果发现运行时间还是9.8s，和2个线程的结果几乎一样。&lt;/p&gt;&#xA;&lt;p&gt;这是怎么回事呢？难道是我买了假的MacBook吗？你可以先自己思考一下这个问题，也可以在自己电脑上测试一下。我当然也要自我反思一下，并且提出了下面两个猜想。&lt;/p&gt;&#xA;&lt;p&gt;第一个怀疑：我的机器出问题了吗？&lt;/p&gt;&#xA;&lt;p&gt;这不得不说也是一个合理的猜想。因此我又找了一个单核CPU的台式机，跑了一下上面的实验。这次我发现，在单核CPU电脑上，单线程运行需要11s时间，2个线程运行也是11s时间。虽然不像第一台机器那样，多线程反而比单线程更慢，但是这两次整体效果几乎一样呀！&lt;/p&gt;&#xA;&lt;p&gt;看起来，这不像是电脑的问题，而是Python的线程失效了，没有起到并行计算的作用。&lt;/p&gt;&#xA;&lt;p&gt;顺理成章，我又有了第二个怀疑：Python的线程是不是假的线程？&lt;/p&gt;&#xA;&lt;p&gt;Python的线程，的的确确封装了底层的操作系统线程，在Linux系统里是Pthread（全称为POSIX Thread），而在Windows系统里是Windows Thread。另外，Python的线程，也完全受操作系统管理，比如协调何时执行、管理内存资源、管理中断等等。&lt;/p&gt;&#xA;&lt;p&gt;所以，虽然Python的线程和C++的线程本质上是不同的抽象，但它们的底层并没有什么不同。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么有gil&#34;&gt;为什么有GIL？ &lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9c%89gil&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;看来我的两个猜想，都不能解释开头的这个未解之谜。那究竟谁才是“罪魁祸首”呢？事实上，正是我们今天的主角，也就是GIL，导致了Python线程的性能并不像我们期望的那样。&lt;/p&gt;&#xA;&lt;p&gt;GIL，是最流行的Python解释器CPython中的一个技术术语。它的意思是全局解释器锁，本质上是类似操作系统的Mutex。每一个Python线程，在CPython解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。&lt;/p&gt;&#xA;&lt;p&gt;当然，CPython会做一些小把戏，轮流执行Python线程。这样一来，用户看到的就是“伪并行”——Python线程在交错执行，来模拟真正并行的线程。&lt;/p&gt;&#xA;&lt;p&gt;那么，为什么CPython需要GIL呢？这其实和CPython的实现有关。下一节我们会讲Python的内存管理机制，今天先稍微提一下。&lt;/p&gt;&#xA;&lt;p&gt;CPython使用引用计数来管理内存，所有Python脚本中创建的实例，都会有一个引用计数，来记录有多少个指针指向它。当引用计数只有0时，则会自动释放内存。&lt;/p&gt;&#xA;&lt;p&gt;什么意思呢？我们来看下面这个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;da9d59d&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import sys&#xD;&#xA;&amp;gt;&amp;gt;&amp;gt; a = []&#xD;&#xA;&amp;gt;&amp;gt;&amp;gt; b = a&#xD;&#xA;&amp;gt;&amp;gt;&amp;gt; sys.getrefcount(a)&#xD;&#xA;3&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这个例子中，a的引用计数是3，因为有a、b和作为参数传递的getrefcount这三个地方，都引用了一个空列表。&lt;/p&gt;</description>
    </item>
    <item>
      <title>带你解析 Python 垃圾回收机制</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/24---%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90-python-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/24---%E5%B8%A6%E4%BD%A0%E8%A7%A3%E6%9E%90-python-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;众所周知，我们当代的计算机都是图灵机架构。图灵机架构的本质，就是一条无限长的纸带，对应着我们今天的存储器。在工程学的演化中，逐渐出现了寄存器、易失性存储器（内存）和永久性存储器（硬盘）等产品。其实，这本身来自一个矛盾：速度越快的存储器，单位价格也越昂贵。因此，妥善利用好每一寸高速存储器的空间，永远是系统设计的一个核心。&lt;/p&gt;&#xA;&lt;p&gt;回到 Python 应用层。&lt;/p&gt;&#xA;&lt;p&gt;我们知道，Python 程序在运行的时候，需要在内存中开辟出一块空间，用于存放运行时产生的临时变量；计算完成后，再将结果输出到永久性存储器中。如果数据量过大，内存空间管理不善就很容易出现 OOM（out of memory），俗称爆内存，程序可能被操作系统中止。&lt;/p&gt;&#xA;&lt;p&gt;而对于服务器，这种设计为永不中断的系统来说，内存管理则显得更为重要，不然很容易引发内存泄漏。什么是内存泄漏呢？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这里的泄漏，并不是说你的内存出现了信息安全问题，被恶意程序利用了，而是指程序本身没有设计好，导致程序未能释放已不再使用的内存。&lt;/li&gt;&#xA;&lt;li&gt;内存泄漏也不是指你的内存在物理上消失了，而是意味着代码在分配了某段内存后，因为设计错误，失去了对这段内存的控制，从而造成了内存的浪费。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;那么，Python 又是怎么解决这些问题的？换句话说，对于不会再用到的内存空间，Python 是通过什么机制来回收这些空间的呢？&lt;/p&gt;&#xA;&lt;h2 id=&#34;计数引用&#34;&gt;计数引用 &lt;a href=&#34;#%e8%ae%a1%e6%95%b0%e5%bc%95%e7%94%a8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我们反复提过好几次， Python 中一切皆对象。因此，你所看到的一切变量，本质上都是对象的一个指针。&lt;/p&gt;&#xA;&lt;p&gt;那么，怎么知道一个对象，是否永远都不能被调用了呢？&lt;/p&gt;&#xA;&lt;p&gt;我们上节课提到过的，也是非常直观的一个想法，就是当这个对象的引用计数（指针数）为 0 的时候，说明这个对象永不可达，自然它也就成为了垃圾，需要被回收。&lt;/p&gt;&#xA;&lt;p&gt;我们来看一个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;4624972&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;import os&#xD;&#xA;import psutil&#xD;&#xA;&#xD;&#xA;# 显示当前 python 程序占用的内存大小&#xD;&#xA;def show_memory_info(hint):&#xD;&#xA;    pid = os.getpid()&#xD;&#xA;    p = psutil.Process(pid)&#xD;&#xA;    &#xD;&#xA;    info = p.memory_full_info()&#xD;&#xA;    memory = info.uss / 1024. / 1024&#xD;&#xA;    print(&amp;#39;{} memory used: {} MB&amp;#39;.format(hint, memory))&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;9e44ab1&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;def func():&#xD;&#xA;    show_memory_info(&amp;#39;initial&amp;#39;)&#xD;&#xA;    a = [i for i in range(10000000)]&#xD;&#xA;    show_memory_info(&amp;#39;after a created&amp;#39;)&#xD;&#xA;&#xD;&#xA;func()&#xD;&#xA;show_memory_info(&amp;#39;finished&amp;#39;)&#xD;&#xA;&#xD;&#xA;########## 输出 ##########&#xD;&#xA;&#xD;&#xA;initial memory used: 47.19140625 MB&#xD;&#xA;after a created memory used: 433.91015625 MB&#xD;&#xA;finished memory used: 48.109375 MB&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;通过这个示例，你可以看到，调用函数 func()，在列表 a 被创建之后，内存占用迅速增加到了 433 MB：而在函数调用结束后，内存则返回正常。&lt;/p&gt;</description>
    </item>
    <item>
      <title>答疑（二）：GIL与多线程是什么关系呢？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/25---%E7%AD%94%E7%96%91%E4%BA%8Cgil%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E5%91%A2/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/25---%E7%AD%94%E7%96%91%E4%BA%8Cgil%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E5%91%A2/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;不知不觉中，我们又一起完成了第二大章进阶篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。&lt;/p&gt;&#xA;&lt;p&gt;大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很典型的问题，我专门摘录了出来，作为今天的答疑内容，集中回复。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题一列表self-append无限嵌套的原理&#34;&gt;问题一：列表self append无限嵌套的原理 &lt;a href=&#34;#%e9%97%ae%e9%a2%98%e4%b8%80%e5%88%97%e8%a1%a8self-append%e6%97%a0%e9%99%90%e5%b5%8c%e5%a5%97%e7%9a%84%e5%8e%9f%e7%90%86&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/9d6c8c7a5adc13e9119d08dc3f1052a0_2537152258966179338.png&#34; alt=&#34;&#34; width=&#34;1534&#34; height=&#34;950&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;先来回答第一个问题，两个同学都问到了，下面这段代码中的x，为什么是无限嵌套的列表？&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;57e6c6c&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;x = [1]&#xD;&#xA;x.append(x)&#xD;&#xA;x&#xD;&#xA;[1, [...]]&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;我们可以将上述操作画一个图，便于你更直观地理解：&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/001a607f3f29f68975be3e706711325f_15951824152869646095.png&#34; alt=&#34;&#34; width=&#34;764&#34; height=&#34;298&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;这里，x指向一个列表，列表的第一个元素为1；执行了append操作后，第二个元素又反过来指向x，即指向了x所指向的列表，因此形成了一个无限嵌套的循环：[1, [1, [1, [1, …]]]]。&lt;/p&gt;&#xA;&lt;p&gt;不过，虽然x是无限嵌套的列表，但x.append(x)的操作，并不会递归遍历其中的每一个元素。它只是扩充了原列表的第二个元素，并将其指向x，因此不会出现stack overflow的问题，自然不会报错。&lt;/p&gt;&#xA;&lt;p&gt;至于第二点，为什么len(x)返回的是2？我们还是来看x，虽然它是无限嵌套的列表，但x的top level只有2个元素组成，第一个元素为1，第二个元素为指向自身的列表，因此len(x)返回2。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题二装饰器的宏观理解&#34;&gt;问题二：装饰器的宏观理解 &lt;a href=&#34;#%e9%97%ae%e9%a2%98%e4%ba%8c%e8%a3%85%e9%a5%b0%e5%99%a8%e7%9a%84%e5%ae%8f%e8%a7%82%e7%90%86%e8%a7%a3&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/17fcf8a9ef8685025fb5f792bc26116f_15718258501903038907.png&#34; alt=&#34;&#34; width=&#34;1498&#34; height=&#34;384&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;再来看第二个问题，胡峣同学对装饰器的疑问。事实上，装饰器的作用与意义，在于其可以通过自定义的函数或类，在不改变原函数的基础上，改变原函数的一些功能。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;4b814b5&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;Decorators is to modify the behavior of the function through a wrapper so we don&amp;#39;t have to actually modify the function.&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;装饰器将额外增加的功能，封装在自己的装饰器函数或类中；如果你想要调用它，只需要在原函数的顶部，加上@decorator即可。显然，这样做可以让你的代码得到高度的抽象、分离与简化。&lt;/p&gt;&#xA;&lt;p&gt;光说概念可能还是有点抽象，我们可以想象下面这样一个场景，从真实例子来感受装饰器的魅力。在一些社交网站的后台，有无数的操作在调用之前，都需要先检查用户是否登录，比如在一些帖子里发表评论、发表状态等等。&lt;/p&gt;&#xA;&lt;p&gt;如果你不知道装饰器，用常规的方法来编程，写出来的代码大概是下面这样的：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;bc1a1aa&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;# 发表评论&#xD;&#xA;def post_comment(request, ...):&#xD;&#xA;    if not authenticate(request):&#xD;&#xA;        raise Exception(&amp;#39;U must log in first&amp;#39;)&#xD;&#xA;    ...&#xD;&#xA;    &#xD;&#xA;# 发表状态&#xD;&#xA;def post_moment(request, ...):&#xD;&#xA;    if not authenticate(request):&#xD;&#xA;        raise Exception(&amp;#39;U must log in first&amp;#39;)&#xD;&#xA;    ...&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;显然，这样重复调用认证函数authenticate()的步骤，就显得非常冗余了。更好的解决办法，就是将认证函数authenticate()单独分离出来，写成一个装饰器，就像我们下面这样的写法。这样一来，代码便得到了高度的优化：&lt;/p&gt;</description>
    </item>
    <item>
      <title>活都来不及干了，还有空注意代码风格？！</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/26---%E6%B4%BB%E9%83%BD%E6%9D%A5%E4%B8%8D%E5%8F%8A%E5%B9%B2%E4%BA%86%E8%BF%98%E6%9C%89%E7%A9%BA%E6%B3%A8%E6%84%8F%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/26---%E6%B4%BB%E9%83%BD%E6%9D%A5%E4%B8%8D%E5%8F%8A%E5%B9%B2%E4%BA%86%E8%BF%98%E6%9C%89%E7%A9%BA%E6%B3%A8%E6%84%8F%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</guid>
      <description>&lt;p&gt;你好，我是蔡元楠，是极客时间《大规模数据处理实战》的作者。今天是我第二次受邀来我们专栏分享了，很高兴再次见到你。今天我分享的主题是：活都来不及干了，还有空注意代码风格吗？！&lt;/p&gt;&#xA;&lt;p&gt;许多来Google参观的人，用完洗手间后，都会惊奇而略带羞涩地问：“你们马桶前面的门上，贴着的Python编程规范，是用来搞笑的吗？”&lt;/p&gt;&#xA;&lt;p&gt;这事儿还真不是搞笑，Google对编码规范的要求极其严格。今天，我们就来聊聊编程规范这件事儿。&lt;/p&gt;&#xA;&lt;p&gt;对于编程规范（style guide） 的认知，很多人可能只停留在第一阶段：知道编程规范有用，整个公司都要求使用驼峰式命名。而后面的阶段，比如为什么和怎么做，就并不了解了。&lt;/p&gt;&#xA;&lt;p&gt;但在Google，对于编程规范的信仰，可能超出很多人的想象，我给你简单介绍几点。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每一个语言都有专门的委员会（Style Committee）制定全公司强制的编程规范，和负责在编程风格争议时的仲裁人（Style Arbiters）。&lt;/li&gt;&#xA;&lt;li&gt;在每个语言相应的编程规范群里，每天都有大量的讨论和辩论。新达成的共识会被写出“大字报”张贴在厕所里，以至于每个人甚至来访者都能用坐着的时候那零碎的5分钟阅读。&lt;/li&gt;&#xA;&lt;li&gt;每一个代码提交，类似于Git里diff的概念，都需要至少两次代码评审（code review），一次针对业务逻辑，一次针对可读性（readability review）。所谓的可读性评审，着重在代码风格规范上。只有通过考核的人，才能够成为可读性评审人（readability reviewer）。&lt;/li&gt;&#xA;&lt;li&gt;有大量的开发自动化工具，确保以上的准则得到强制实施。例如，代码提交前会有linter做静态规则检查，不通过是无法提交代码的。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;看到这里，不知道你有怎样的感受？我自己十分认同这样的工程师文化，所以今天，我会给你介绍清楚两点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Python的编程规范为什么重要，这对于业务开发来说，究竟有没有帮助？&lt;/li&gt;&#xA;&lt;li&gt;有哪些流程和工具，可以整合到已有的开发流程中，让你的编程规范强制自动执行呢？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在讲解过程中，我会适时引用两个条例来举例，分别是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;《8号Python增强规范》（Python Enhacement Proposal #8），以下简称PEP8；&lt;/li&gt;&#xA;&lt;li&gt;《Google Python 风格规范》（Google Python Style Guide），以下简称Google Style，这是源自Google内部的风格规范。公开发布的社区版本，是为了让Google旗下所有Python开源项目的编程风格统一。（&lt;a href=&#34;http://google.github.io/styleguide/pyguide.html&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;http://google.github.io/styleguide/pyguide.html&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;相对来说，Google Style是比PEP8更严格的一个编程规范。因为PEP8的受众是个人和小团队开发者，而Google Style能够胜任大团队，企业级，百万行级别代码库。他们的内容，后面我也会简单说明。&lt;/p&gt;</description>
    </item>
    <item>
      <title>学会合理分解代码，提高代码可读性</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/27---%E5%AD%A6%E4%BC%9A%E5%90%88%E7%90%86%E5%88%86%E8%A7%A3%E4%BB%A3%E7%A0%81%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/27---%E5%AD%A6%E4%BC%9A%E5%90%88%E7%90%86%E5%88%86%E8%A7%A3%E4%BB%A3%E7%A0%81%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/</guid>
      <description>&lt;p&gt;你好，我是景霄。今天我们不讲任何技术知识点，继续来一起聊聊代码哲学。&lt;/p&gt;&#xA;&lt;p&gt;有句话说得好，好的代码本身就是一份文档。同样功能的一份程序，一个组件，一套系统，让不同的人来写，写出来的代码却是千差万别。&lt;/p&gt;&#xA;&lt;p&gt;有些人的设计风格和代码风格犹如热刀切黄油，从顶层到底层的代码看下来酣畅淋漓，注释详尽而又精简；深入到细节代码，无需注释也能理解清清楚楚。&lt;/p&gt;&#xA;&lt;p&gt;而有些人，代码勉勉强强能跑起来，遇到稍微复杂的情况可能就会出 bug；深入到代码中 debug，则发现处处都是魔术数、函数堆在一起。一个文件上千行，设计模式又是混淆不堪，让人实在很难阅读，更别提修改和迭代开发。&lt;/p&gt;&#xA;&lt;p&gt;Guido van Rossum（吉多·范罗苏姆，Python创始人 ）说过，代码的阅读频率远高于编写代码的频率。毕竟，即使是在编写代码的时候，你也需要对代码进行反复阅读和调试，来确认代码能够按照期望运行。&lt;/p&gt;&#xA;&lt;p&gt;话不多说，进入正题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;pep-8-规范&#34;&gt;PEP 8 规范 &lt;a href=&#34;#pep-8-%e8%a7%84%e8%8c%83&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;上节课我们简单提起过 PEP 8 ，今天我们继续来详细解读。&lt;/p&gt;&#xA;&lt;p&gt;PEP是 Python Enhancement Proposal 的缩写，翻译过来叫“Python 增强规范”。正如我们写文章，会有句式、标点、段落格式、开头缩进等标准的规范一样，Python 书写自然也有一套较为官方的规范。PEP 8 就是这样一种规范，它存在的意义，就是让 Python 更易阅读，换句话，增强代码可读性。&lt;/p&gt;&#xA;&lt;p&gt;事实上，Pycharm 已经内置了 PEP 8 规范检测器，它会自动对编码不规范的地方进行检查，然后指出错误，并推荐修改方式。下面这张图就是其界面。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/23f0288a5ba4388f69e5a1c3a59eb55f_14765839775648429237.png&#34; alt=&#34;&#34; width=&#34;1734&#34; height=&#34;1306&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;因此，在学习今天的内容时，我推荐你使用 Pycharm IDE 进行代码检查，看一下自己的代码格式哪里有问题。尤其对于初学者，从某些程度来说，代码规范甚至是比代码准确更重要的事情，因为实际工作中，代码可读性的重要性一定比你想象的多得多。&lt;/p&gt;&#xA;&lt;h3 id=&#34;缩进规范&#34;&gt;缩进规范 &lt;a href=&#34;#%e7%bc%a9%e8%bf%9b%e8%a7%84%e8%8c%83&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;首先，我们来看代码块内的缩进。&lt;/p&gt;&#xA;&lt;p&gt;Python 和 C++ / Java 最大的不同在于，后者完全使用大括号来区分代码块，而前者依靠不同行和不同的缩进来进行分块。有一个很有名的比赛，叫作 &lt;a href=&#34;http://www.ioccc.org/years-spoiler.html&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;C 语言混乱代码大赛&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;，其中有很多非常精彩的作品，你能看到书写的代码排成各种形状，有的是一幅画，或者一个卡通头像，但是能执行出惊人的结果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何合理利用assert？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/28---%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8assert/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/28---%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8assert/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;相信你平时在写代码时，肯定或多或少看到过assert的存在。我也曾在日常的code review中，被一些同事要求增加assert语句，让代码更加健壮。&lt;/p&gt;&#xA;&lt;p&gt;不过，尽管如此，我发现在很多情况下，assert还是很容易被忽略，人们似乎对这么一个“不起眼”的东西并不关心。但事实上，这个看似“不起眼”的东西，如果能用好，对我们的程序大有裨益。&lt;/p&gt;&#xA;&lt;p&gt;说了这么多，那么究竟什么是assert，我们又该如何合理地使用assert呢？今天这节课，我就带你一起来学习它的用法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是assert&#34;&gt;什么是assert？ &lt;a href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afassert&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Python的assert语句，可以说是一个debug的好工具，主要用于测试一个条件是否满足。如果测试的条件满足，则什么也不做，相当于执行了pass语句；如果测试条件不满足，便会抛出异常AssertionError，并返回具体的错误信息（optional）。&lt;/p&gt;&#xA;&lt;p&gt;它的具体语法是下面这样的：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;f2faa9e&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;assert_stmt ::=  &amp;#34;assert&amp;#34; expression [&amp;#34;,&amp;#34; expression]&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;我们先来看一个简单形式的&lt;code&gt;assert expression&lt;/code&gt;，比如下面这个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;bfac6c8&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;assert 1 == 2&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;它就相当于下面这两行代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;757e4b6&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;if __debug__:&#xD;&#xA;    if not expression: raise AssertionError&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;再来看&lt;code&gt;assert expression1, expression2&lt;/code&gt;的形式，比如下面这个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;c4aeb3d&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;assert 1 == 2,  &amp;#39;assertion is wrong&amp;#39;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;它就相当于下面这两行代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;edfb348&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;if __debug__:&#xD;&#xA;    if not expression1: raise AssertionError(expression2)&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里的&lt;code&gt;__debug__&lt;/code&gt;是一个常数。如果Python程序执行时附带了&lt;code&gt;-O&lt;/code&gt;这个选项，比如&lt;code&gt;Python test.py -O&lt;/code&gt;，那么程序中所有的assert语句都会失效，常数&lt;code&gt;__debug__&lt;/code&gt;便为False；反之&lt;code&gt;__debug__&lt;/code&gt;则为True。&lt;/p&gt;&#xA;&lt;p&gt;不过，需要注意的是，直接对常数&lt;code&gt;__debug__&lt;/code&gt;赋值是非法的，因为它的值在解释器开始运行时就已经决定了，中途无法改变。&lt;/p&gt;&#xA;&lt;p&gt;此外，一定记住，不要在使用assert时加入括号，比如下面这个例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;f86353e&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;assert(1 == 2, &amp;#39;This should fail&amp;#39;)&#xD;&#xA;# 输出&#xD;&#xA;&amp;lt;ipython-input-8-2c057bd7fe24&amp;gt;:1: SyntaxWarning: assertion is always true, perhaps remove parentheses?&#xD;&#xA;  assert(1 == 2, &amp;#39;This should fail&amp;#39;)&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;如果你按照这样来写，无论表达式对与错（比如这里的1 == 2显然是错误的），assert检查永远不会fail，程序只会给你SyntaxWarning。&lt;/p&gt;</description>
    </item>
    <item>
      <title>巧用上下文管理器和With语句精简代码</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/29---%E5%B7%A7%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8Cwith%E8%AF%AD%E5%8F%A5%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/29---%E5%B7%A7%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8Cwith%E8%AF%AD%E5%8F%A5%E7%B2%BE%E7%AE%80%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;我想你对Python中的with语句一定不陌生，在专栏里它也曾多次出现，尤其是在文件的输入输出操作中，不过我想，大部分人可能习惯了它的使用，却并不知道隐藏在其背后的“秘密”。&lt;/p&gt;&#xA;&lt;p&gt;那么，究竟with语句要怎么用，与之相关的上下文管理器（context manager）是什么，它们之间又有着怎样的联系呢？这节课，我就带你一起揭开它们的神秘面纱。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是上下文管理器&#34;&gt;什么是上下文管理器？ &lt;a href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%8a%e4%b8%8b%e6%96%87%e7%ae%a1%e7%90%86%e5%99%a8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在任何一门编程语言中，文件的输入输出、数据库的连接断开等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，我们必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻者使得系统处理缓慢，重则会使系统崩溃。&lt;/p&gt;&#xA;&lt;p&gt;光说这些概念，你可能体会不到这一点，我们可以看看下面的例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;1d387b5&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;for x in range(10000000): &#xD;&#xA;    f = open(&amp;#39;test.txt&amp;#39;, &amp;#39;w&amp;#39;)&#xD;&#xA;    f.write(&amp;#39;hello&amp;#39;) &lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里我们一共打开了10000000个文件，但是用完以后都没有关闭它们，如果你运行该段代码，便会报错：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;1d123f8&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;OSError: [Errno 23] Too many open files in system: &amp;#39;test.txt&amp;#39;&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这就是一个典型的资源泄露的例子。因为程序中同时打开了太多的文件，占据了太多的资源，造成系统崩溃。&lt;/p&gt;&#xA;&lt;p&gt;为了解决这个问题，不同的编程语言都引入了不同的机制。而在Python中，对应的解决方式便是上下文管理器（context manager）。上下文管理器，能够帮助你自动分配并且释放资源，其中最典型的应用便是with语句。所以，上面代码的正确写法应该如下所示：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;1ae19bc&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;for x in range(10000000):&#xD;&#xA;    with open(&amp;#39;test.txt&amp;#39;, &amp;#39;w&amp;#39;) as f:&#xD;&#xA;        f.write(&amp;#39;hello&amp;#39;)&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这样，我们每次打开文件&lt;code&gt;“test.txt”&lt;/code&gt;，并写入&lt;code&gt;‘hello’&lt;/code&gt;之后，这个文件便会自动关闭，相应的资源也可以得到释放，防止资源泄露。当然，with语句的代码，也可以用下面的形式表示：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;ad04a64&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;f = open(&amp;#39;test.txt&amp;#39;, &amp;#39;w&amp;#39;)&#xD;&#xA;try:&#xD;&#xA;    f.write(&amp;#39;hello&amp;#39;)&#xD;&#xA;finally:&#xD;&#xA;    f.close()&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;要注意的是，最后的finally block尤其重要，哪怕在写入文件时发生错误异常，它也可以保证该文件最终被关闭。不过与with语句相比，这样的代码就显得冗余了，并且还容易漏写，因此我们一般更倾向于使用with语句。&lt;/p&gt;&#xA;&lt;p&gt;另外一个典型的例子，是Python中的threading.lock类。举个例子，比如我想要获取一个锁，执行相应的操作，完成后再释放，那么代码就可以写成下面这样：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;e0d244b&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;some_lock = threading.Lock()&#xD;&#xA;some_lock.acquire()&#xD;&#xA;try:&#xD;&#xA;    ...&#xD;&#xA;finally:&#xD;&#xA;    some_lock.release()&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;而对应的with语句，同样非常简洁：&lt;/p&gt;</description>
    </item>
    <item>
      <title>真的有必要写单元测试吗？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/30---%E7%9C%9F%E7%9A%84%E6%9C%89%E5%BF%85%E8%A6%81%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%90%97/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/30---%E7%9C%9F%E7%9A%84%E6%9C%89%E5%BF%85%E8%A6%81%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%90%97/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;说到unit test（即单元测试，下文统一用中文称呼），大部分人的反应估计有这么两种：要么就是，单元测试啊，挺简单的呀，做不做无所谓吧；要么就是，哎呀，项目进度太赶，单元测试拖一拖之后再来吧。&lt;/p&gt;&#xA;&lt;p&gt;显然，这两种人，都没有正确认识到单元测试的价值，也没能掌握正确的单元测试方法。你是不是觉得自己只要了解Python的各个feature，能够编写出符合规定功能的程序就可以了呢？&lt;/p&gt;&#xA;&lt;p&gt;其实不然，完成产品的功能需求只是很基础的一部分，如何保证所写代码的稳定、高效、无误，才是我们工作的关键。而学会合理地使用单元测试，正是帮助你实现这一目标的重要路径。&lt;/p&gt;&#xA;&lt;p&gt;我们总说，测试驱动开发（TDD）。今天我就以Python为例，教你设计编写Python的单元测试代码，带你熟悉并掌握这一重要技能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是单元测试&#34;&gt;什么是单元测试？ &lt;a href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;单元测试，通俗易懂地讲，就是编写测试来验证某一个模块的功能正确性，一般会指定输入，验证输出是否符合预期。&lt;/p&gt;&#xA;&lt;p&gt;实际生产环境中，我们会对每一个模块的所有可能输入值进行测试。这样虽然显得繁琐，增加了额外的工作量，但是能够大大提高代码质量，减小bug发生的可能性，也更方便系统的维护。&lt;/p&gt;&#xA;&lt;p&gt;说起单元测试，就不得不提 &lt;a href=&#34;https://docs.python.org/3/library/unittest.html&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;Python unittest库&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;，它提供了我们需要的大多数工具。我们来看下面这个简单的测试，从代码中了解其使用方法：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;b5565ab&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;import unittest&#xD;&#xA;&#xD;&#xA;# 将要被测试的排序函数&#xD;&#xA;def sort(arr):&#xD;&#xA;    l = len(arr)&#xD;&#xA;    for i in range(0, l):&#xD;&#xA;        for j in range(i &amp;#43; 1, l):&#xD;&#xA;            if arr[i] &amp;gt;= arr[j]:&#xD;&#xA;                tmp = arr[i]&#xD;&#xA;                arr[i] = arr[j]&#xD;&#xA;                arr[j] = tmp&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 编写子类继承unittest.TestCase&#xD;&#xA;class TestSort(unittest.TestCase):&#xD;&#xA;&#xD;&#xA;   # 以test开头的函数将会被测试&#xD;&#xA;   def test_sort(self):&#xD;&#xA;        arr = [3, 4, 1, 5, 6]&#xD;&#xA;        sort(arr)&#xD;&#xA;        # assert 结果跟我们期待的一样&#xD;&#xA;        self.assertEqual(arr, [1, 3, 4, 5, 6])&#xD;&#xA;&#xD;&#xA;if __name__ == &amp;#39;__main__&amp;#39;:&#xD;&#xA;    ## 如果在Jupyter下，请用如下方式运行单元测试&#xD;&#xA;    unittest.main(argv=[&amp;#39;first-arg-is-ignored&amp;#39;], exit=False)&#xD;&#xA;    &#xD;&#xA;    ## 如果是命令行下运行，则：&#xD;&#xA;    ## unittest.main()&#xD;&#xA;    &#xD;&#xA;## 输出&#xD;&#xA;..&#xD;&#xA;----------------------------------------------------------------------&#xD;&#xA;Ran 2 tests in 0.002s&#xD;&#xA;&#xD;&#xA;OK&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里，我们创建了一个排序函数的单元测试，来验证排序函数的功能是否正确。代码里我做了非常详细的注释，相信你能够大致读懂，我再来介绍一些细节。&lt;/p&gt;</description>
    </item>
    <item>
      <title>pdb &amp; cProfile：调试和性能分析的法宝</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/31---pdb--cprofile%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E6%B3%95%E5%AE%9D/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/31---pdb--cprofile%E8%B0%83%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E6%B3%95%E5%AE%9D/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;在实际生产环境中，对代码进行调试和性能分析，是一个永远都逃不开的话题。调试和性能分析的主要场景，通常有这么三个：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一是代码本身有问题，需要我们找到root cause并修复；&lt;/li&gt;&#xA;&lt;li&gt;二是代码效率有问题，比如过度浪费资源，增加latency，因此需要我们debug；&lt;/li&gt;&#xA;&lt;li&gt;三是在开发新的feature时，一般都需要测试。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在遇到这些场景时，究竟应该使用哪些工具，如何正确的使用这些工具，应该遵循什么样的步骤等等，就是这节课我们要讨论的话题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;用pdb进行代码调试&#34;&gt;用pdb进行代码调试 &lt;a href=&#34;#%e7%94%a8pdb%e8%bf%9b%e8%a1%8c%e4%bb%a3%e7%a0%81%e8%b0%83%e8%af%95&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&#34;pdb的必要性&#34;&gt;pdb的必要性 &lt;a href=&#34;#pdb%e7%9a%84%e5%bf%85%e8%a6%81%e6%80%a7&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;首先，我们来看代码的调试。也许不少人会有疑问：代码调试？说白了不就是在程序中使用print()语句吗？&lt;/p&gt;&#xA;&lt;p&gt;没错，在程序中相应的地方打印，的确是调试程序的一个常用手段，但这只适用于小型程序。因为你每次都得重新运行整个程序，或是一个完整的功能模块，才能看到打印出来的变量值。如果程序不大，每次运行都非常快，那么使用print()，的确是很方便的。&lt;/p&gt;&#xA;&lt;p&gt;但是，如果我们面对的是大型程序，运行一次的调试成本很高。特别是对于一些tricky的例子来说，它们通常需要反复运行调试、追溯上下文代码，才能找到错误根源。这种情况下，仅仅依赖打印的效率自然就很低了。&lt;/p&gt;&#xA;&lt;p&gt;我们可以想象下面这个场景。比如你最常使用的极客时间App，最近出现了一个bug，部分用户无法登陆。于是，后端工程师们开始debug。&lt;/p&gt;&#xA;&lt;p&gt;他们怀疑错误的代码逻辑在某几个函数中，如果使用print()语句debug，很可能出现的场景是，工程师们在他们认为的10个最可能出现bug的地方，都使用print()语句，然后运行整个功能块代码（从启动到运行花了5min），看打印出来的结果值，是不是和预期相符。&lt;/p&gt;&#xA;&lt;p&gt;如果结果值和预期相符，并能直接找到错误根源，显然是最好的。但实际情况往往是，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;要么与预期并不相符，需要重复以上步骤，继续debug；&lt;/li&gt;&#xA;&lt;li&gt;要么虽说与预期相符，但前面的操作只是缩小了错误代码的范围，所以仍得继续添加print()语句，再一次运行相应的代码模块（又要5min），进行debug。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;你可以看到，这样的效率就很低下了。哪怕只是遇到稍微复杂一点的case，两、三个工程师一下午的时间可能就没了。&lt;/p&gt;&#xA;&lt;p&gt;可能又有人会说，现在很多的IDE不都有内置的debug工具吗？&lt;/p&gt;&#xA;&lt;p&gt;这话说的也没错。比如我们常用的Pycharm，可以很方便地在程序中设置断点。这样程序只要运行到断点处，便会自动停下，你就可以轻松查看环境中各个变量的值，并且可以执行相应的语句，大大提高了调试的效率。&lt;/p&gt;&#xA;&lt;p&gt;看到这里，你不禁会问，既然问题都解决了，那为什么还要学习pdb呢？其实在很多大公司，产品的创造与迭代，往往需要很多编程语言的支持；并且，公司内部也会开发很多自己的接口，尝试把尽可能多的语言给结合起来。&lt;/p&gt;&#xA;&lt;p&gt;这就使得，很多情况下，单一语言的IDE，对混合代码并不支持UI形式的断点调试功能，或是只对某些功能模块支持。另外，考虑到不少代码已经挪到了类似Jupyter的Notebook中，往往就要求开发者使用命令行的形式，来对代码进行调试。&lt;/p&gt;&#xA;&lt;p&gt;而Python的pdb，正是其自带的一个调试库。它为Python程序提供了交互式的源代码调试功能，是命令行版本的IDE断点调试器，完美地解决了我们刚刚讨论的这个问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何使用pdb&#34;&gt;如何使用pdb &lt;a href=&#34;#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8pdb&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;了解了pdb的重要性与必要性后，接下来，我们就一起来看看，pdb在Python中到底应该如何使用。&lt;/p&gt;&#xA;&lt;p&gt;首先，要启动pdb调试，我们只需要在程序中，加入&lt;code&gt;“import pdb”&lt;/code&gt;和&lt;code&gt;“pdb.set_trace()”&lt;/code&gt;这两行代码就行了，比如下面这个简单的例子：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;7d57554&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;a = 1&#xD;&#xA;b = 2&#xD;&#xA;import pdb&#xD;&#xA;pdb.set_trace()&#xD;&#xA;c = 3&#xD;&#xA;print(a &amp;#43; b &amp;#43; c)&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;当我们运行这个程序时时，它的输出界面是下面这样的，表示程序已经运行到了&lt;code&gt;“pdb.set_trace()”&lt;/code&gt;这行，并且暂停了下来，等待用户输入。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;2edcd9f&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;&amp;gt; /Users/jingxiao/test.py(5)&amp;lt;module&amp;gt;()&#xD;&#xA;-&amp;gt; c = 3&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这时，我们就可以执行，在IDE断点调试器中可以执行的一切操作，比如打印，语法是&lt;code&gt;&amp;quot;p &amp;lt;expression&amp;gt;&amp;quot;&lt;/code&gt;：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;22b7a96&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;(pdb) p a&#xD;&#xA;1&#xD;&#xA;(pdb) p b&#xD;&#xA;2&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;你可以看到，我打印的是a和b的值，分别为1和2，与预期相符。为什么不打印c呢？显然，打印c会抛出异常，因为程序目前只运行了前面几行，此时的变量c还没有被定义：&lt;/p&gt;</description>
    </item>
    <item>
      <title>答疑（三）：如何选择合适的异常处理方式？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/32---%E7%AD%94%E7%96%91%E4%B8%89%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/32---%E7%AD%94%E7%96%91%E4%B8%89%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;不知不觉中，我们又一起完成了第三大章规范篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。&lt;/p&gt;&#xA;&lt;p&gt;大部分留言，我都在相对应的文章中回复过了。而一些手机上不方便回复，或是很有价值很典型的问题，我专门摘录了出来，作为今天的答疑内容，集中回复。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题一应该使用哪种异常处理方式&#34;&gt;问题一：应该使用哪种异常处理方式？ &lt;a href=&#34;#%e9%97%ae%e9%a2%98%e4%b8%80%e5%ba%94%e8%af%a5%e4%bd%bf%e7%94%a8%e5%93%aa%e7%a7%8d%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e6%96%b9%e5%bc%8f&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/c766890764672c7c924092d9dfd0c942_15948676533447665727.png&#34; alt=&#34;&#34; width=&#34;1418&#34; height=&#34;368&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;第一个问题是code2同学的疑惑。下面这两种处理的风格，哪一种风格更有效、更优雅？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一种，在代码中对数据进行检测，并直接处理与抛出异常。&lt;/li&gt;&#xA;&lt;li&gt;第二种，在异常处理代码中进行处理。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其实，第一种方法，可以翻译成下面的“if…elif…”语句：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;db89e55&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;if [condition1]:&#xD;&#xA;    raise Exception1(&amp;#39;exception 1&amp;#39;)&#xD;&#xA;elif [condition2]:&#xD;&#xA;    raise Exception2(&amp;#39;exception 2&amp;#39;)&#xD;&#xA;...&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;而第二种方法，则对应着下面异常处理的代码：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;9498dee&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;try:&#xD;&#xA;    ...&#xD;&#xA;except Exception as e:&#xD;&#xA;    ...&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这两种方法很大的一个区别是，第一种方法一旦抛出异常，那么程序就会终止；而在第二种方法中，如果抛出异常，会被程序捕获（catch），程序还会继续运行。这也是我们选择这两种方法的重要依据。当然，在实际工作中，到底使用哪一种方法，还是取决于具体的场景。&lt;/p&gt;&#xA;&lt;p&gt;比方说，一个模块的功能是对输入进行检测，如果输入不合法，则弹出对话框进行提示，并终止程序。那么，这种情况下，使用第一种方法更加合理。&lt;/p&gt;&#xA;&lt;p&gt;但是，如果换成一个产品的服务器端，它需要应对各种可能发生的情况，以保证服务器不崩溃。比如在连接数据库时，如果网络异常，无法连接，那就需要捕获（catch）这个异常（exception），进行记录，并同时保证其他功能不受影响。这种情况下，我们通常会选择第二种方式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题二先写出能跑起来的代码后期再优化可以吗&#34;&gt;问题二：先写出能跑起来的代码，后期再优化可以吗？ &lt;a href=&#34;#%e9%97%ae%e9%a2%98%e4%ba%8c%e5%85%88%e5%86%99%e5%87%ba%e8%83%bd%e8%b7%91%e8%b5%b7%e6%9d%a5%e7%9a%84%e4%bb%a3%e7%a0%81%e5%90%8e%e6%9c%9f%e5%86%8d%e4%bc%98%e5%8c%96%e5%8f%af%e4%bb%a5%e5%90%97&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/d5efddbe80757e61e33596ce41440bb0_16511151776403916683.png&#34; alt=&#34;&#34; width=&#34;1436&#34; height=&#34;586&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;第二个问题，夜路破晓同学提到了很多程序员传授的“经验之谈”，即先写出能跑起来的代码，后期再优化。很明显，这种认知是错误的。我们从一开始写代码时，就必须对功能和规范这两者双管齐下。&lt;/p&gt;&#xA;&lt;p&gt;代码功能完整和规范完整的优先级是不分先后的，应该是同时进行的。如果你一开始只注重代码的功能完整，而不关注其质量、规范，那么规范问题很容易越积越多。这样就会导致产品的bug越来越多，相应的代码库越发难以维护，到最后不得已只能推倒重来。&lt;/p&gt;&#xA;&lt;p&gt;我在Facebook工作时就遇到过这样的情况，参与过类似的项目。当时，某些功能模块因为赶时间，code review很宽松，代码写得很不规范，留下了隐患。时间一长，bug越来越多，legacy越来越多。到最后，万分无奈的情况下，我们几个工程师专门立项，花了三个多月时间，重写了这一模块的代码，才解决了这个问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题三代码中写多少注释才合适&#34;&gt;问题三：代码中写多少注释才合适？ &lt;a href=&#34;#%e9%97%ae%e9%a2%98%e4%b8%89%e4%bb%a3%e7%a0%81%e4%b8%ad%e5%86%99%e5%a4%9a%e5%b0%91%e6%b3%a8%e9%87%8a%e6%89%8d%e5%90%88%e9%80%82&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/f22b2ec07051b244ed4a852189745671_9907758784014734650.png&#34; alt=&#34;&#34; width=&#34;1464&#34; height=&#34;364&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;第三个问题，小侠龙旋风同学留言说，自己的同事要求代码中有70%的注释，这显然有点过了。但是反过来说，如果你的代码中没有注释或者注释很少，仅凭规范的变量名肯定是远远不够的。&lt;/p&gt;&#xA;&lt;p&gt;通常来说，我们会在类的开头、函数的开头或者是某一个功能块的开头加上一段描述性的注释，来说明这段代码的功能，并指明所有的输入和输出。除此之外，我们也要求在一些比较tricky的代码上方加上注释，帮助阅读者理解代码的含义。&lt;/p&gt;&#xA;&lt;p&gt;总的来说，代码中到底需要有多少注释，其实并没有一个统一的要求，还是要根据代码量和代码的复杂度来决定。不过，我们平常书写时，只要满足这样的规范就可以了。&lt;/p&gt;&#xA;&lt;p&gt;另外，必须提醒一点，如果在写好之后修改了代码，那么代码对应的注释一定也要做出相应的修改，不然很容易造成“文不对题”的现象，给别人也给你自己带来困扰。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题四项目的api文档重要吗&#34;&gt;问题四：项目的API文档重要吗？ &lt;a href=&#34;#%e9%97%ae%e9%a2%98%e5%9b%9b%e9%a1%b9%e7%9b%ae%e7%9a%84api%e6%96%87%e6%a1%a3%e9%87%8d%e8%a6%81%e5%90%97&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/fc59ac08ab33764afa439056e75acac5_16577885413540222888.png&#34; alt=&#34;&#34; width=&#34;1450&#34; height=&#34;374&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;第四个问题，是未来已来同学的留言。他提到了项目的API文档的问题，这一点说得非常好，在这里我也简单介绍一下。&lt;/p&gt;&#xA;&lt;p&gt;我在专栏中主要讲的是代码的规范问题，但很多情况下，光有规范的代码还是远远不够的。因为一个系统，一个产品，甚至一个功能模块的代码，都有可能非常复杂。少则几千行，动辄几十万行，尤其是对于刚加入的新人来说，在ramp up阶段光看代码可能就是一个噩梦了。&lt;/p&gt;&#xA;&lt;p&gt;因此，在这方面做得比较规范的公司，通常也会要求书写文档。项目的文档，主要是对相应的系统、产品或是功能模块做一个概述，有助于后人理解。以一个service为例，其对应的文档通常会包括下面几部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一点，系统的概述，包括各个组成部分以及工作流程的介绍；&lt;/li&gt;&#xA;&lt;li&gt;第二点，每个组成部分的具体介绍，包括必要性、设计原理等等；&lt;/li&gt;&#xA;&lt;li&gt;第三点，系统的performance，包括latency等等参数；&lt;/li&gt;&#xA;&lt;li&gt;第四点主要说明如何对系统的各个部分进行修改，主要给出相应的code pointer及对应的测试方案。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这些内容，也希望屏幕前的你能够牢记。&lt;/p&gt;&#xA;&lt;p&gt;今天我主要回答这些问题，同时也欢迎你继续在留言区写下疑问和感想，我会持续不断地解答。希望每一次的留言和答疑，都能给你带来新的收获和价值。&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>带你初探量化世界</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/33---%E5%B8%A6%E4%BD%A0%E5%88%9D%E6%8E%A2%E9%87%8F%E5%8C%96%E4%B8%96%E7%95%8C/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/33---%E5%B8%A6%E4%BD%A0%E5%88%9D%E6%8E%A2%E9%87%8F%E5%8C%96%E4%B8%96%E7%95%8C/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;在2000 年顶峰时期，高盛雇佣了 600 名交易员为机构客户买卖现金股票。可如今，这个数字只有 2 名（Ref. 经济学人）。到了2009 年，金融危机余音未散，专家面对股票和证券交易中越来越多的机器参与提出了警告，因为机器的崛起，逐渐导致了手操交易工作的消失。&lt;/p&gt;&#xA;&lt;p&gt;很久之前，瑞银集团（UBS）的交易大厅是下面这样的：&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/3814a699e324b7958a08c793a5d58df7_11205272950835505534.png&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;335&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;8 年之后，交易大厅就已经只有这些人了：&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/59390119c9f7cb17ca9642bf2d30b3af_11422850684459795440.jpg&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;377&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;事实上，随着数据处理技术的飞速发展，和量化交易模型研究理论的逐渐成熟，现金股票交易、债券市场、期货市场以及投行的相当一部分业务，都在朝着自动化的方向迈进。&lt;/p&gt;&#xA;&lt;p&gt;而发展到2017 年，WannyCry 席卷全球，随之而来的比特币，在短短几个月内从小众玩家走入了公众视野，币价也是一飞冲天，很多炒币的人赚得盆满钵满。更有一部分人，将金融业的量化策略应用其中，无论是搬砖（套利），还是波段，在不成熟的市场初期都赚了个爽快。&lt;/p&gt;&#xA;&lt;p&gt;这节课开始，我们就来探索一下量化的世界。作为我们 Python 专栏的综合实践模块，希望你能在这一部分内容中，收获自己独特的东西。&lt;/p&gt;&#xA;&lt;h2 id=&#34;交易是什么&#34;&gt;交易是什么？ &lt;a href=&#34;#%e4%ba%a4%e6%98%93%e6%98%af%e4%bb%80%e4%b9%88&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;市场，是人类有史以来最伟大的发明之一。亚当·斯密在国富论中，用“看不见的手”这个概念，生动形象地阐释了市场和理性人之间是如何交互，最终让整个社会受益的。&lt;/p&gt;&#xA;&lt;p&gt;而市场的核心，是交换。人类发展最开始是物物交换，原始的“以物易物”的方式产生于货币诞生之前。不过，这种方式非常低效，不便于流通交换，经常会出现的情况是，要走很长的交换链条才能拿到自己想要的物品。于是，一般等价物出现了，社会分工也逐渐出现了。人们把自己生产的商品换成一般等价物，然后再换成自己需要的其他商品。&lt;/p&gt;&#xA;&lt;p&gt;而交换的核心，就是买和卖。当买卖双方对价格预期相等的时候，交易达成。随着金融和技术的发展，逐渐出现了股票、债券、期权、期货等越来越多的金融工具，金融衍生品也朝着复杂的方向发展。&lt;/p&gt;&#xA;&lt;p&gt;在我们经常听到的投资银行中，量化基金交易员这种角色，所做的事情，就是在这些复杂的衍生品基础上，分析投资标的的价值，然后以某种策略来管理持有仓位，进行买进和卖出。&lt;/p&gt;&#xA;&lt;p&gt;为什么交易能赚钱，是很多人疑惑不解的地方。市场究竟有没有规律可循呢？可以肯定是有的，但虽有迹可循却无法可依。交易的多样性和人性的复杂性，使得金融数据的噪音极大，我们无法简单地从某一两个因子来确定地推导行情变化。&lt;/p&gt;&#xA;&lt;p&gt;所以交易员这个行业本身，对自身素质要求是极高的。除了要具备扎实的专业素养（包括金融功底、数理逻辑、分析能力、决策能力），对心理素质的要求也非常高。这种直接和钱打交道、并直面人性深处欲望的行业，也因此吸引了无数高手的参与，很多人因此暴富，也有不少人破产，一无所有。&lt;/p&gt;&#xA;&lt;p&gt;那么，有什么办法可以规避这种，因为心理素质原因带来的风险呢？&lt;/p&gt;&#xA;&lt;h2 id=&#34;量化交易&#34;&gt;量化交易 &lt;a href=&#34;#%e9%87%8f%e5%8c%96%e4%ba%a4%e6%98%93&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;回答这个问题之前，我先插一句题外话。刚接触量化交易的朋友，都很容易被这几个词绕晕：量化交易（Quantitative Trading）、程序化交易（Program Trading）、算法交易（Algo-Trading）、高频交易（High Frequency Trading）和自动化交易平台（Automated Trading System）。&lt;/p&gt;&#xA;&lt;p&gt;虽然我遇到过不少行业内的人也混用这词，但是作为初学者来说，厘清这些术语还是很有帮助的。至少，在别人说出这些高大上的词时，我们心里不用犯怵了。&lt;/p&gt;&#xA;&lt;p&gt;先来看程序化交易，它通常用计算机程序代替交易员，来具体执行金融产品的买卖。比如，一个基金经理需要卖出大量股票。如果直接挂一个大的卖单，可能会影响市场，那就用计算机程序拆分成小单慢慢执行。所以，量化交易的下层通常是程序交易。&lt;/p&gt;&#xA;&lt;p&gt;而算法交易通常用于高频交易中。它指的是，通过算法快速判定买卖的时间点，快速买卖多个产品。&lt;/p&gt;&#xA;&lt;p&gt;量化交易则通常是指使用数学、统计甚至机器学习的方法，去找寻合适的买卖时机。所以，在这个维度的定义之下，算法交易、高频交易还有统计套利（Statistical Arbitrage）都可以算作量化交易。&lt;/p&gt;&#xA;&lt;p&gt;简单而言，我们可以认为量化交易的涵盖范围最大。因此，&lt;strong&gt;当你不确定用哪个词的时候，用量化交易就行了。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;回到我们刚刚的问题，规避心理素质原因带来的风险的方法，自然就是量化交易了。量化交易的好处显而易见。最直观来看，计算机不眠不休，不需要交易员实时操盘，满足了人们“躺着挣钱”的愿景。当然，这只是美好的想象，真要这么做的话，不久之后就要回工地搬砖了。现实场景中，成熟的量化交易也需要有人蹲守，适时干预，防止算法突然失效造成巨额的交易亏损。&lt;/p&gt;&#xA;&lt;p&gt;在数字货币领域的交易，这一点更加显著。数字货币的交易在全球许多交易所进行，和股票不同，一支股票可能只在少数几个交易所交易，而一种数字货币可以在所有的交易所同时进行交易。同时，因为没有股市的开盘、收盘限制，数字货币的交易通常是 7 x 24 小时不眠不休，比前世的 “996 福报”凶残多了。要是真有交易员能在这个市场活下来，我们尊称一声“神仙”也不为过了。&lt;/p&gt;&#xA;&lt;p&gt;多交易所交易，也意味着全球数字货币市场每时每刻都是紧密相连的。一个市场、一个局部的巨大变动，都会影响所有的市场。比如，2017年朝鲜氢弹炸了的当天，新闻还没出来，隔壁韩国、日本的比特币价格马上拉升了一波；再比如，当比特币的负面消息半夜里传出来的时候，其价格也马上跟着暴跌一波。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/bfae52c5cc5252e006652d73a1e1b502_6857135837077103714.png&#34; alt=&#34;&#34; width=&#34;1600&#34; height=&#34;805&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;2019年6月比特币在全球头部交易所的价格&lt;/p&gt;&#xA;&lt;p&gt;因此，我们经常看到比特币的价格波动巨大。很有可能今天还是财富自由状态，明天的财富就没那么自由了。显然，在这种市场中交易，人力很难持久支撑，而量化交易就很合适了。&lt;/p&gt;&#xA;&lt;p&gt;通常的电子盘交易（比如股票，数字货币），是通过券商或者软件，直接把买卖请求发送给交易所；而算法交易的底层，就是让程序来自动实现这类操作。券商或者交易所，通常也会提供API接口给投资者。比如，盈透证券（Interactive Broker）的接口，就可以支持股票、期权的行情数据获取和交易；而 Gemini、OKCoin等交易所，也提供了对应的接口进行数字货币行情获取和交易。&lt;/p&gt;&#xA;&lt;p&gt;Gemini交易所的&lt;a href=&#34;https://api.gemini.com/v1/pubticker/btcusd&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;公开行情API&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;，就可以通过下面这种简单的HTTP GET请求，来获取最近的比特币（BTC）对美元（USD）的价格和最近的成交量。&lt;/p&gt;</description>
    </item>
    <item>
      <title>RESTful &amp; Socket：搭建交易执行层核心</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/34---restful--socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/34---restful--socket%E6%90%AD%E5%BB%BA%E4%BA%A4%E6%98%93%E6%89%A7%E8%A1%8C%E5%B1%82%E6%A0%B8%E5%BF%83/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;上一节，我们简单介绍了量化交易的历史、严谨的定义和它的基本组成结构。有了这些高层次的基本知识，接下来我们就分模块，开始讲解量化交易系统中具体的部分。&lt;/p&gt;&#xA;&lt;p&gt;从这节课开始，我们将实打实地从代码出发，一步步设计出一套清晰完整、易于理解的量化交易系统。&lt;/p&gt;&#xA;&lt;p&gt;一个量化交易系统，可以说是一个黑箱。这个黑箱连接交易所获取到的数据，通过策略运算，然后再连接交易所进行下单操作。正如我们在输入输出那节课说的那样，黑箱的特性是输入和输出。每一个设计网络交互的同学，都需要在大脑中形成清晰的交互状态图：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;知道包是怎样在网络间传递的；&lt;/li&gt;&#xA;&lt;li&gt;知道每一个节点是如何处理不同的输入包，然后输出并分发给下一级的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在你搞不明白的时候，可以先在草稿纸上画出交互拓扑图，标注清楚每个节点的输入和输出格式，然后想清楚网络是怎么流动的。这一点，对网络编程至关重要。&lt;/p&gt;&#xA;&lt;p&gt;现在，我假设你对网络编程只有很基本的了解。所以接下来，我将先从 REST 的定义讲起，然后过渡到具体的交互方式——如何通过 Python 和交易所进行交互，从而执行下单、撤单、查询订单等网络交互方式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;rest-简介&#34;&gt;REST 简介 &lt;a href=&#34;#rest-%e7%ae%80%e4%bb%8b&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;什么是 REST API？什么是 Socket？有过网络编程经验的同学，一定对这两个词汇不陌生。&lt;/p&gt;&#xA;&lt;p&gt;REST的全称是表征层状态转移（REpresentational State Transfer），本意是指一种操作资源方法。不过，你不用纠结于这个绕口的名字。换种方式来说，REST的实质可以理解为：通过URL定位资源，用GET、POST、PUT、DELETE等动词来描述操作。而满足REST要求的接口，就被称为RESTful的接口。&lt;/p&gt;&#xA;&lt;p&gt;为了方便你更容易理解这些概念，这里我举个例子来类比。小明同学不是很聪明但很懂事，每天会在他的妈妈下班回来后给妈妈泡茶。刚开始，他的妈妈会发出这样的要求：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;用红色杯子，去厨房泡一杯放了糖的37.5度的普洱茶。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;可是小明同学不够聪明，很难理解这个定语很多的句子。于是，他妈妈为了让他更简单明白需要做的事情，把这个指令设计成了更简洁的样子：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;泡厨房的茶，要求如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;类型=普洱；&lt;/li&gt;&#xA;&lt;li&gt;杯子=红色；&lt;/li&gt;&#xA;&lt;li&gt;放糖=True；&lt;/li&gt;&#xA;&lt;li&gt;温度=37.5度。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这里的“茶”就是资源，“&lt;strong&gt;厨房的茶&lt;/strong&gt;”就是资源的地址（URI）；“&lt;strong&gt;泡&lt;/strong&gt;”是动词；后面的要求，都是接口参数。这样的一个接口，就是小明提供的一个REST接口。&lt;/p&gt;&#xA;&lt;p&gt;如果小明是一台机器，那么解析这个请求就会非常容易；而我们作为维护者，查看小明的代码也很简单。当小明把这个接口暴露到网上时，这就是一个RESTful的接口。&lt;/p&gt;&#xA;&lt;p&gt;总的来说，RESTful接口通常以HTTP GET和POST形式出现。但并非所有的GET、POST请求接口，都是RESTful的接口。&lt;/p&gt;&#xA;&lt;p&gt;这话可能有些拗口，我们举个例子来看。上节课中，我们获取了Gemini交易所中，BTC对USD价格的ticker接口：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;27c2a07&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;GET https://api.gemini.com/v1/pubticker/btcusd&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这里的“GET”是动词，后边的URI是“Ticker”这个资源的地址。所以，这是一个RESTful的接口。&lt;/p&gt;&#xA;&lt;p&gt;但下面这样的接口，就不是一个严格的RESTful接口：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;bc7b3d5&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;POST https://api.restful.cn/accounts/delete/:username&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;因为URI中包含动词“delete”（删除），所以这个URI并不是&lt;strong&gt;指向一个资源&lt;/strong&gt;。如果要修改成严格的RESTful接口，我们可以把它改成下面这样：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;2807b6f&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;DELETE https://api.rest.cn/accounts/:username&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;然后，我们带着这个观念去看Gemini的取消订单接口：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;5c6c368&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;POST https://api.gemini.com/v1/order/cancel&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/c6851d2560b5f67f29c750cyy018738f_4858532728230426345.png&#34; alt=&#34;&#34; width=&#34;1132&#34; height=&#34;614&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;你会发现，这个接口不够“RESTful”的地方有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;动词设计不准确，接口使用“POST”而不是重用HTTP动词“DELETE”；&lt;/li&gt;&#xA;&lt;li&gt;URI里包含动词cancel；&lt;/li&gt;&#xA;&lt;li&gt;ID代表的订单是&lt;strong&gt;资源&lt;/strong&gt;，但订单ID是放在&lt;strong&gt;参数列表&lt;/strong&gt;而不是&lt;strong&gt;URI&lt;/strong&gt;里的，因此URI并没有指向资源。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以严格来说，这不是一个RESTful的接口。&lt;/p&gt;&#xA;&lt;p&gt;此外，如果我们去检查Gemini的其他私有接口（Private，私有接口是指需要附加身份验证信息才能访问的接口），我们会发现，那些接口的设计都不是严格RESTful的。不仅如此，大部分的交易所，比如Bitmex、Bitfinex、OKCoin等等，它们提供的“REST接口”，也都不是严格RESTful的。这些接口之所以还能被称为“REST接口”，是因为他们大部分满足了REST接口的另一个重要要求：&lt;strong&gt;无状态&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;无状态的意思是，每个REST请求都是独立的，不需要服务器在会话（Session）中缓存中间状态来完成这个请求。简单来说，如果服务器A接收到请求的时候宕机了，而此时把这个请求发送给交易所的服务器B，也能继续完成，那么这个接口就是无状态的。&lt;/p&gt;&#xA;&lt;p&gt;这里，我再给你举一个简单的有状态的接口的例子。服务器要求，在客户端请求取消订单的时候，必须发送两次不一样的HTTP请求。并且，第一次发送让服务器“等待取消”；第二次发送“确认取消”。那么，就算这个接口满足了RESTful的动词、资源分离原则，也不是一个REST接口。&lt;/p&gt;&#xA;&lt;p&gt;当然，对于交易所的REST接口，你并不需要过于纠结“RESTful”这个概念，否则很容易就被这些名词给绕晕了。你只需要把握住最核心的一点：&lt;strong&gt;一个HTTP请求完成一次完整操作&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;交易所-api-简介&#34;&gt;交易所 API 简介 &lt;a href=&#34;#%e4%ba%a4%e6%98%93%e6%89%80-api-%e7%ae%80%e4%bb%8b&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;现在，你对 REST 和 Web Socket 应该有一个大致了解了吧。接下来，我们就开始做点有意思的事情。&lt;/p&gt;</description>
    </item>
    <item>
      <title>RESTful &amp; Socket：行情数据对接和抓取</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/35---restful--socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/35---restful--socket%E8%A1%8C%E6%83%85%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E5%92%8C%E6%8A%93%E5%8F%96/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;上一节课，我们介绍了交易所的交易模式，数字货币交易所RESTful接口的常见概念，以及如何调用RESTful接口进行订单操作。众所周知，买卖操作的前提，是你需要已知市场的最新情况。这节课里，我将介绍交易系统底层另一个最重要的部分，行情数据的对接和抓取。&lt;/p&gt;&#xA;&lt;p&gt;行情数据，最重要的是实时性和有效性。市场的情况瞬息万变，合适的买卖时间窗口可能只有几秒。在高频交易里，合适的买卖机会甚至在毫秒级别。要知道，一次从北京发往美国的网络请求，即使是光速传播，都需要几百毫秒的延迟。更别提用Python这种解释型语言，建立HTTP连接导致的时间消耗。&lt;/p&gt;&#xA;&lt;p&gt;经过上节课的学习，你对交易应该有了基本的了解，这也是我们今天学习的基础。接下来，我们先从交易所撮合模式讲起，然后介绍行情数据有哪些；之后，我将带你基于Websocket的行情数据来抓取模块。&lt;/p&gt;&#xA;&lt;h2 id=&#34;行情数据&#34;&gt;行情数据 &lt;a href=&#34;#%e8%a1%8c%e6%83%85%e6%95%b0%e6%8d%ae&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;回顾上一节我们提到的，交易所是一个买方、卖方之间的公开撮合平台。买卖方把需要/可提供的商品数量和愿意出/接受的价格提交给交易所，交易所按照公平原则进行撮合交易。&lt;/p&gt;&#xA;&lt;p&gt;那么撮合交易是怎么进行的呢？假设你是一个人肉比特币交易所，大量的交易订单往你这里汇总，你应该如何选择才能让交易公平呢？&lt;/p&gt;&#xA;&lt;p&gt;显然，最直观的操作就是，把买卖订单分成两个表，按照价格由高到低排列。下面的图，就是买入和卖出的委托表。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/6bade6ffe3b8d439b7826cbe6d84a22d_5490320541604005221.png&#34; alt=&#34;&#34; width=&#34;1282&#34; height=&#34;388&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/0d7f5bcbb766097b84b7ad36d2b26a4c_6584661382134149794.png&#34; alt=&#34;&#34; width=&#34;1272&#34; height=&#34;344&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;如果最高的买入价格小于最低的卖出价格，那就不会有任何交易发生。这通常是你看到的委托列表的常态。&lt;/p&gt;&#xA;&lt;p&gt;如果最高的买入价格和最低的卖出价格相同，那么就尝试进行撮合。比如BTC在9002.01就会发生撮合，最后按照9002.01的价格，成交0.0330个BTC。当然，交易完成后，小林未完成部分的订单（余下0.1126 - 0.0330 = 0.0796 个 BTC 未卖出），还会继续在委托表里。&lt;/p&gt;&#xA;&lt;p&gt;不过你可能会想，如果买入和卖出的价格有交叉，那么成交价格又是什么呢？事实上，这种情况并不会发生。我们来试想一下下面这样的场景。&lt;/p&gt;&#xA;&lt;p&gt;如果你尝试给一个委托列表里加入一个新买入订单，它的价格比所有已有的最高买入价格高，也比所有的卖出价格高。那么此时，它会直接从最低的卖出价格撮合。等到最低价格的卖出订单吃完了，它便开始吃价格第二低的卖出订单，直到这个买入订单完全成交。反之亦然。所以，委托列表价格不会出现交叉。&lt;/p&gt;&#xA;&lt;p&gt;当然，请注意，这里我说的只是限价订单的交易方式。而对于市价订单，交易规则会有一些轻微的区别，这里我就不详细解释了，主要是让你有个概念。&lt;/p&gt;&#xA;&lt;p&gt;其实说到这里，所谓的“交易所行情”概念就呼之欲出了。交易所主要有两种行情数据：委托账本（Order Book）和活动行情（Tick data）。&lt;/p&gt;&#xA;&lt;p&gt;我们把委托表里的具体用户隐去，相同价格的订单合并，就得到了下面这种委托账本。我们主要观察右边的数字部分，其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上半部分里，第一列红色数字代表BTC的卖出价格，中间一列数字是这个价格区间的订单BTC总量，最右边一栏是从最低卖出价格到当前价格区间的积累订单量。&lt;/li&gt;&#xA;&lt;li&gt;中间的大字部分，9994.10 USD是当前的市场价格，也就是上一次成交交易的价格。&lt;/li&gt;&#xA;&lt;li&gt;下面绿色部分的含义与上半部分类似，不过指的是买入委托和对应的数量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/740e88e95dcab334652f8761ca58171e_9742101143092685912.png&#34; alt=&#34;&#34; width=&#34;932&#34; height=&#34;964&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;Gemini的委托账本，来自&lt;a href=&#34;https://cryptowat.ch&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;https://cryptowat.ch&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pandas &amp; Numpy：策略与回测系统</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/36---pandas--numpy%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/36---pandas--numpy%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%B5%8B%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;p&gt;大家好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;上节课，我们介绍了交易所的数据抓取，特别是orderbook和tick数据的抓取。今天这节课，我们考虑的是，怎么在这些历史数据上测试一个交易策略。&lt;/p&gt;&#xA;&lt;p&gt;首先我们要明确，对于很多策略来说，我们上节课抓取的密集的orderbook和tick数据，并不能简单地直接使用。因为数据量太密集，包含了太多细节；而且长时间连接时，网络随机出现的不稳定，会导致丢失部分tick数据。因此，我们还需要进行合适的清洗、聚合等操作。&lt;/p&gt;&#xA;&lt;p&gt;此外，为了进行回测，我们需要一个交易策略，还需要一个测试框架。目前已存在很多成熟的回测框架，但是为了Python学习，我决定带你搭建一个简单的回测框架，并且从中简单一窥Pandas的优势。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ohlcv数据&#34;&gt;OHLCV数据 &lt;a href=&#34;#ohlcv%e6%95%b0%e6%8d%ae&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;了解过一些股票交易的同学，可能知道K线这种东西。K线又称“蜡烛线”，是一种反映价格走势的图线。它的特色在于，一个线段内记录了多项讯息，相当易读易懂且实用有效，因此被广泛用于股票、期货、贵金属、数字货币等行情的技术分析。下面便是一个K线示意图。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/470a68b8eaff3807efd89bc616e5659b_9959644298253739982.png&#34; alt=&#34;&#34; width=&#34;730&#34; height=&#34;320&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;K线示意图&lt;/p&gt;&#xA;&lt;p&gt;其中，每一个小蜡烛，都代表着当天的开盘价（Open）、最高价（High）、最低价（Low）和收盘价（Close），也就是我画的第二张图表示的这样。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/58ce87e32aa4655211da02ce88223757_12544149186058738492.png&#34; alt=&#34;&#34; width=&#34;1200&#34; height=&#34;1200&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;K线的“小蜡烛” &amp;ndash; OHLC&lt;/p&gt;&#xA;&lt;p&gt;类似的，除了日K线之外，还有周K线、小时K线、分钟K线等等。那么这个K线是怎么计算来的呢？&lt;/p&gt;&#xA;&lt;p&gt;我们以小时K线图为例，还记得我们当时抓取的tick数据吗？也就是每一笔交易的价格和数量。那么，如果从上午10:00开始，我们开始积累tick的交易数据，以10:00开始的第一个交易作为Open数据，11:00前的最后一笔交易作为Close值，并把这一个小时最低和最高的成交价格分别作为High和Low的值，我们就可以绘制出这一个小时对应的“小蜡烛”形状了。&lt;/p&gt;&#xA;&lt;p&gt;如果再加上这一个小时总的成交量（Volumn），就得到了OHLCV数据。&lt;/p&gt;&#xA;&lt;p&gt;所以，如果我们一直抓取着tick底层原始数据，我们就能在上层聚合出1分钟K线、小时K线以及日、周k线等等。如果你对这一部分操作有兴趣，可以把此作为今天的课后作业来实践。&lt;/p&gt;&#xA;&lt;p&gt;接下来，我们将使用Gemini从2015年到2019年7月这个时间内，BTC对USD每个小时的OHLCV数据，作为策略和回测的输入。你可以在&lt;a href=&#34;https://github.com/caunion/simple_backtesting/blob/master/BTCUSD_GEMINI.csv&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;这里&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;下载数据。&lt;/p&gt;&#xA;&lt;p&gt;数据下载完成后，我们可以利用Pandas读取，比如下面这段代码。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;b5576e2&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;def assert_msg(condition, msg):&#xD;&#xA;    if not condition:&#xD;&#xA;        raise Exception(msg)&#xD;&#xA;    &#xD;&#xA;def read_file(filename):&#xD;&#xA;    # 获得文件绝对路径&#xD;&#xA;    filepath = path.join(path.dirname(__file__), filename)&#xD;&#xA;    &#xD;&#xA;    # 判定文件是否存在&#xD;&#xA;    assert_msg(path.exists(filepath), &amp;#34;文件不存在&amp;#34;)&#xD;&#xA;    &#xD;&#xA;    # 读取CSV文件并返回&#xD;&#xA;    return pd.read_csv(filepath,&#xD;&#xA;                       index_col=0, &#xD;&#xA;                       parse_dates=True,&#xD;&#xA;                       infer_datetime_format=True)&#xD;&#xA;&#xD;&#xA;BTCUSD = read_file(&amp;#39;BTCUSD_GEMINI.csv&amp;#39;)&#xD;&#xA;assert_msg(BTCUSD.__len__() &amp;gt; 0, &amp;#39;读取失败&amp;#39;)&#xD;&#xA;print(BTCUSD.head())&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;########## 输出 ##########&#xD;&#xA;Time                 Symbol      Open      High       Low     Close     Volume&#xD;&#xA;Date                                                                          &#xD;&#xA;2019-07-08 00:00:00  BTCUSD  11475.07  11540.33  11469.53  11506.43  10.770731&#xD;&#xA;2019-07-07 23:00:00  BTCUSD  11423.00  11482.72  11423.00  11475.07  32.996559&#xD;&#xA;2019-07-07 22:00:00  BTCUSD  11526.25  11572.74  11333.59  11423.00  48.937730&#xD;&#xA;2019-07-07 21:00:00  BTCUSD  11515.80  11562.65  11478.20  11526.25  25.323908&#xD;&#xA;2019-07-07 20:00:00  BTCUSD  11547.98  11624.88  11423.94  11515.80  63.211972&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这段代码提供了两个工具函数。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kafka &amp; ZMQ：自动化交易流水线</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/37---kafka--zmq%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E6%98%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/37---kafka--zmq%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E6%98%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;在进行这节课的学习前，我们先来回顾一下，前面三节课，我们学了些什么。&lt;/p&gt;&#xA;&lt;p&gt;第 34 讲，我们介绍了如何通过 RESTful API 在交易所下单；第 35 讲，我们讲解了如何通过 Websocket ，来获取交易所的 orderbook 数据；第 36 讲，我们介绍了如何实现一个策略，以及如何对策略进行历史回测。&lt;/p&gt;&#xA;&lt;p&gt;事实上，到这里，一个简单的、可以运作的量化交易系统已经成型了。你可以对策略进行反复修改，期待能得到不错的 PnL。但是，对于一个完善的量化交易系统来说，只有基本骨架还是不够的。&lt;/p&gt;&#xA;&lt;p&gt;在大型量化交易公司，系统一般是分布式运行的，各个模块独立在不同的机器上，然后互相连接来实现。即使是个人的交易系统，在进行诸如高频套利等算法时，也需要将执行层布置在靠近交易所的机器节点上。&lt;/p&gt;&#xA;&lt;p&gt;所以，从今天这节课开始，我们继续回到 Python 的技术栈，从量化交易系统这个角度切入，为你讲解如何实现分布式系统之间的复杂协作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;中间件&#34;&gt;中间件 &lt;a href=&#34;#%e4%b8%ad%e9%97%b4%e4%bb%b6&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我们先来介绍一下中间件这个概念。中间件，是将技术底层工具和应用层进行连接的组件。它要实现的效果则是，让我们这些需要利用服务的工程师，不必去关心底层的具体实现。我们只需要拿着中间件的接口来用就好了。&lt;/p&gt;&#xA;&lt;p&gt;这个概念听起来并不难理解，我们再举个例子让你彻底明白。比如拿数据库来说，底层数据库有很多很多种，从关系型数据库 MySQL 到非关系型数据库 NoSQL，从分布式数据库 Spanner 到内存数据库 Redis，不同的数据库有不同的使用场景，也有着不同的优缺点，更有着不同的调用方式。那么中间件起什么作用呢？&lt;/p&gt;&#xA;&lt;p&gt;中间件，等于在这些不同的数据库上加了一层逻辑，这一层逻辑专门用来和数据库打交道，而对外只需要暴露同一个接口即可。这样一来，上层的程序员调用中间件接口时，只需要让中间件指定好数据库即可，其他参数完全一致，极大地方便了上层的开发；同时，下层技术栈在更新换代的时候，也可以做到和上层完全分离，不影响程序员的使用。&lt;/p&gt;&#xA;&lt;p&gt;它们之间的逻辑关系，你可以参照下面我画的这张图。我习惯性把中间件的作用调侃为：没有什么事情是加一层解决不了的；如果有，那就加两层。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/f49f221a8191d8fa95eeea146bbbf550_2885422834794561149.png&#34; alt=&#34;&#34; width=&#34;968&#34; height=&#34;628&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;当然，这只是其中一个例子，也只是中间件的一种形式。事实上，比如在阿里，中间件主要有分布式关系型数据库 DRDS、消息队列和分布式服务这么三种形式。而我们今天，主要会用到消息队列，因为它非常符合量化交易系统的应用场景，即事件驱动模型。&lt;/p&gt;&#xA;&lt;h2 id=&#34;消息队列&#34;&gt;消息队列 &lt;a href=&#34;#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;那么，什么是消息队列呢？一如其名，消息，即互联网信息传递的个体；而队列，学过算法和数据结构的你，应该很清楚这个 FIFO（先进先出）的数据结构吧。（如果算法基础不太牢，建议你可以学习极客时间平台上王争老师的“数据结构与算法之美”专栏，&lt;a href=&#34;https://time.geekbang.org/column/article/41330&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;第 09讲&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;即为队列知识）&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL：日志和数据存储系统</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/38---mysql%E6%97%A5%E5%BF%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/38---mysql%E6%97%A5%E5%BF%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;p&gt;你好，我是景霄。今天这节课，我们来聊聊日志和存储系统。&lt;/p&gt;&#xA;&lt;p&gt;在互联网公司中，日志系统是一个非常重要的技术底层。在每一次重要的交互行为中，关键信息都会被记录下来存档，以供日后线下分析，或者线上实时分析。这些数据，甚至可以说是硅谷互联网大公司的命脉所在。&lt;/p&gt;&#xA;&lt;p&gt;有了它们，你才能建立机器学习模型来预测用户的行为，从而可以精确描绘用户画像，然后针对性地使用推荐系统、分类器，将用户进一步留下，并精准推送广告来盈利。&lt;/p&gt;&#xA;&lt;p&gt;在量化交易中，日志同样有着非常重要的作用。一如前面所讲，我们重要的数据有：行情数据、策略信号、执行情况、仓位信息等等非常多的信息。&lt;/p&gt;&#xA;&lt;p&gt;对于简单的、小规模的数据，例如 orderbook 信息，我们完全可以把数据存在 txt、csv 文件中，这样做简单高效。不过，缺点是，随着数据量上升，一个文件将会变得非常大，检索起来也不容易。这时，一个很直观的方式出现了，我们可以把每天的数据存在一个文件中，这样就暂时缓解了尴尬。&lt;/p&gt;&#xA;&lt;p&gt;但是，随着数据量的上升，或者是你的算法逐渐来到高频交易领域时，简单地把数据存在文件上，已经不足以满足新的需求，更无法应对分布式量化交易系统的需求。于是，一个显而易见的想法就是，我们可以把日志存在数据库系统中。&lt;/p&gt;&#xA;&lt;p&gt;这节课，我们就以 MySQL 这种传统型关系数据库为例，讲解一下数据库在日志中的运用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;快速理解mysql&#34;&gt;快速理解MySQL &lt;a href=&#34;#%e5%bf%ab%e9%80%9f%e7%90%86%e8%a7%a3mysql&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;担心一些同学没有数据库的基础，我先来简单介绍一下 MySQL 数据库。&lt;/p&gt;&#xA;&lt;p&gt;MySQL 属于典型的关系型数据库（RDBMS），所谓的关系型数据库，就是指建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法，来处理数据库中的数据。基本上任何学习资料都会告诉你，它有着下面这几个特征：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据是以表格的形式出现的；&lt;/li&gt;&#xA;&lt;li&gt;每一行是各种记录名称；&lt;/li&gt;&#xA;&lt;li&gt;每一列是记录名称所对应的数据域；&lt;/li&gt;&#xA;&lt;li&gt;许多的行和列，组成一张表单；&lt;/li&gt;&#xA;&lt;li&gt;若干的表单，组成数据库（database）这个整体。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;不过，抛开这些抽象的特征不谈，你首先需要掌握的，是下面这些术语的概念。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据库，是一些关联表的集合；而数据表则是数据的矩阵。在一个数据库中，数据表看起来就像是一个简单的电子表格。&lt;/li&gt;&#xA;&lt;li&gt;在数据表中，每一列包含的是相同类型的数据；每一行则是一组相关的数据。&lt;/li&gt;&#xA;&lt;li&gt;主键也是数据表中的一个列，只不过，这一列的每行元素都是唯一的，且一个数据表中只能包含一个主键；而外键则用于关联两个表。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;除此之外，你还需要了解索引。索引是对数据库表中一列或多列的值进行排序的一种结构。使用索引，我们可以快速访问数据库表中的特定信息。一般来说，你可以对很多列设置索引，这样在检索指定列的时候，就大大加快了速度，当然，代价是插入数据会变得更慢。&lt;/p&gt;&#xA;&lt;p&gt;至于操作 MySQL，一般用的是结构化查询语言SQL。SQL是一种典型的领域专用语言（domain-specific language，简称DSL），这里我就不做过多介绍了，如果你感兴趣，可以学习极客时间平台上的“&lt;a href=&#34;https://time.geekbang.org/column/intro/192&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;SQL必知必会&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;”专栏。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Django：搭建监控平台</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/39---django%E6%90%AD%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/39---django%E6%90%AD%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;通过前几节课的学习，相信你对量化交易系统已经有了一个最基本的认知，也能通过自己的代码，搭建一个简单的量化交易系统来进行盈利。&lt;/p&gt;&#xA;&lt;p&gt;前面几节课，我们的重点在后台代码、中间件、分布式系统和设计模式上。这节课，我们重点来看前端交互。&lt;/p&gt;&#xA;&lt;p&gt;监控和运维，是互联网工业链上非常重要的一环。监控的目的就是防患于未然。通过监控，我们能够及时了解到企业网络的运行状态。一旦出现安全隐患，你就可以及时预警，或者是以其他方式通知运维人员，让运维监控人员有时间处理和解决隐患，避免影响业务系统的正常使用，将一切问题的根源扼杀在摇篮当中。&lt;/p&gt;&#xA;&lt;p&gt;在硅谷互联网大公司中，监控和运维被称为 SRE，是公司正常运行中非常重要的一环。作为 billion 级别的 Facebook，内部自然也有着大大小小、各种各样的监控系统和运维工具，有的对标业务数据，有的对标服务器的健康状态，有的则是面向数据库和微服务的控制信息。&lt;/p&gt;&#xA;&lt;p&gt;不过，万变不离其宗，运维工作最重要的就是维护系统的稳定性。除了熟悉运用各种提高运维效率的工具来辅助工作外，云资源费用管理、安全管理、监控等，都需要耗费不少精力和时间。运维监控不是一朝一夕得来的，而是随着业务发展的过程中同步和发展的。&lt;/p&gt;&#xA;&lt;p&gt;作为量化实践内容的最后一节，今天我们就使用 Django 这个 Web 框架，来搭建一个简单的量化监控平台。&lt;/p&gt;&#xA;&lt;h2 id=&#34;django-简介和安装&#34;&gt;Django 简介和安装 &lt;a href=&#34;#django-%e7%ae%80%e4%bb%8b%e5%92%8c%e5%ae%89%e8%a3%85&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Django 是用 Python 开发的一个免费开源的 Web 框架，可以用来快速搭建优雅的高性能网站。它采用的是“MVC”的框架模式，即模型 M、视图 V 和控制器 C。&lt;/p&gt;&#xA;&lt;p&gt;Django 最大的特色，在于将网页和数据库中复杂的关系，转化为 Python 中对应的简单关系。它的设计目的，是使常见的Web开发任务变得快速而简单。Django是开源的，不是商业项目或者科研项目，并且集中力量解决Web开发中遇到的一系列问题。所以，Django 每天都会在现有的基础上进步，以适应不断更迭的开发需求。这样既节省了开发时间，也提高了后期维护的效率。&lt;/p&gt;&#xA;&lt;p&gt;说了这么多，接下来，我们通过上手使用进一步来了解。先来看一下，如何安装和使用 Django。你可以先按照下面代码块的内容来操作，安装Django ：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;a64617f&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;pip3 install Django&#xD;&#xA;django-admin --version&#xD;&#xA;&#xD;&#xA;########## 输出 ##########&#xD;&#xA;&#xD;&#xA;2.2.3&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;接着，我们来创建一个新的 Django 项目：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;28d7776&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;django-admin startproject TradingMonitor&#xD;&#xA;cd TradingMonitor/&#xD;&#xA;python3 manage.py migrate&#xD;&#xA;&#xD;&#xA;########## 输出 ##########&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;fedb629&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;  Applying contenttypes.0001_initial... OK&#xD;&#xA;  Applying auth.0001_initial... OK&#xD;&#xA;  Applying admin.0001_initial... OK&#xD;&#xA;  Applying admin.0002_logentry_remove_auto_add... OK&#xD;&#xA;  Applying admin.0003_logentry_add_action_flag_choices... OK&#xD;&#xA;  Applying contenttypes.0002_remove_content_type_name... OK&#xD;&#xA;  Applying auth.0002_alter_permission_name_max_length... OK&#xD;&#xA;  Applying auth.0003_alter_user_email_max_length... OK&#xD;&#xA;  Applying auth.0004_alter_user_username_opts... OK&#xD;&#xA;  Applying auth.0005_alter_user_last_login_null... OK&#xD;&#xA;  Applying auth.0006_require_contenttypes_0002... OK&#xD;&#xA;  Applying auth.0007_alter_validators_add_error_messages... OK&#xD;&#xA;  Applying auth.0008_alter_user_username_max_length... OK&#xD;&#xA;  Applying auth.0009_alter_user_last_name_max_length... OK&#xD;&#xA;  Applying auth.0010_alter_group_name_max_length... OK&#xD;&#xA;  Applying auth.0011_update_proxy_permissions... OK&#xD;&#xA;  Applying sessions.0001_initial... OK&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;这时，你能看到文件系统大概是下面这样的：&lt;/p&gt;</description>
    </item>
    <item>
      <title>总结：Python中的数据结构与算法全景</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/40---%E6%80%BB%E7%BB%93python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A8%E6%99%AF/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/40---%E6%80%BB%E7%BB%93python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A8%E6%99%AF/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;不知不觉中，我们又一起完成了量化交易实战篇的学习。我非常高兴看到很多同学一直在坚持积极地学习，并且留下了很多高质量的留言，值得我们互相思考交流。也有一些同学反复推敲，指出了文章中一些表达不严谨或是不当的地方，我也表示十分感谢。&lt;/p&gt;&#xA;&lt;p&gt;实战篇的主要用意，是通过一个完整的技术领域，讲明白 Python 在这个领域中如何发挥作用。所以，我们在每节课都会梳理一个小知识点；同时，也在第 36 讲中，我用大量篇幅讲解了策略和回测系统，作为量化交易中最重要内容的解释。&lt;/p&gt;&#xA;&lt;p&gt;对于本章答疑，因为不断有同学留言询问Python中数据结构和算法相关的问题，我在这里也简单说一下。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/4b72bbef1367976a203bd29a36b09d80_15535868541143327263.png&#34; alt=&#34;&#34; width=&#34;882&#34; height=&#34;301&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;首先，希望你明白，我们Python 专栏的定位是有一定计算机知识基础的进阶课程，重点在 Python 的核心知识点上，默认你对基础的算法和数据结构有一定的了解。因此，在语法和技术知识点的讲解过程中，我会综合性地穿插不少数据结构的基本知识，但并不会进行深入地讲解。涉及到数据结构中的关键名词和难点，自然都会有所提及，但还是希望你有一定的自学能力来掌握。&lt;/p&gt;&#xA;&lt;p&gt;不过，为了进一步方便你理解Python的数据结构和算法，加深对 Python 基础内容的掌握，我在这里总结了一个综合性的提纲。如果你在这方面有所欠缺，可以参考性地借鉴学习一下。当然，有时间和精力的话，我最鼓励的是你可以通过 Python 把所有数据结构和算法实现一下。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基础数据结构数组堆栈队列链表&#34;&gt;基础数据结构：数组，堆，栈，队列，链表 &lt;a href=&#34;#%e5%9f%ba%e7%a1%80%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%95%b0%e7%bb%84%e5%a0%86%e6%a0%88%e9%98%9f%e5%88%97%e9%93%be%e8%a1%a8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;数组自不必多说，Python 中的基础数组，满足 O(1) 的随机查找，和 O(n) 的随机插入。&lt;/p&gt;&#xA;&lt;p&gt;堆，严格来讲，是一种特殊的二叉树，满足 O(nlogn) 的随机插入和删除，以及 O(1) 时间复杂度拿到最大值或者最小值。堆可以用来实现优先队列，还可以在项目中实现多任务调度，有着非常广泛的应用。&lt;/p&gt;&#xA;&lt;p&gt;栈，是一种先进后出的数据结构，入栈和出栈操作都是 O(1) 时间复杂度。&lt;/p&gt;&#xA;&lt;p&gt;队列和栈对应，不过功能刚好相反，它是一种先进先出的数据结构，一如其名，先排队者先服务。入队和出队也是 O(1) 的时间复杂度。栈和队列都能用数组来实现，但是对空间的规划需要注意，特别是用数组实现的队列，我们通常用的是循环队列。&lt;/p&gt;&#xA;&lt;p&gt;链表则是另一种线性表，和数组的不同是，它不支持随机访问，你不能通过下标来获取链表的元素。链表的元素通过指针相连，单链表中元素可以指向后者，双链表则是让相邻的元素互相连接。&lt;/p&gt;&#xA;&lt;p&gt;这些基础数据结构，在 Python 中都有很好的库和包支持，从使用上来说都非常方便，但我仍然希望你对原理能有一定的了解，这样，处理起复杂问题也能得心应手不胆怯。&lt;/p&gt;&#xA;&lt;h2 id=&#34;进阶数据结构无向图有向图树dag-图字典树哈希表&#34;&gt;进阶数据结构：无向图，有向图，树，DAG 图，字典树，哈希表 &lt;a href=&#34;#%e8%bf%9b%e9%98%b6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%97%a0%e5%90%91%e5%9b%be%e6%9c%89%e5%90%91%e5%9b%be%e6%a0%91dag-%e5%9b%be%e5%ad%97%e5%85%b8%e6%a0%91%e5%93%88%e5%b8%8c%e8%a1%a8&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;无向图，是由顶点和边组成的数据结构，一条边连接两个顶点（如果两个顶点是一个，这条边称为自环）。一如其名，“无向”，所以它的边没有指向性。&lt;/p&gt;&#xA;&lt;p&gt;有向图，和无向图一样都是“图”这种数据结构，不同的是有向图的边有指向性，方向为一个顶点指向另一个顶点。&lt;/p&gt;&#xA;&lt;p&gt;树这种数据结构，则可以分为有根树和无根树。前者中，最常见的就是我们的二叉树，从顶点开始一级级向下，每个父结点最多有两个子结点。至于无根树，则是一种特殊的无向图，无环连通的无向图被称为无根树，它有很多特别的性质和优点，在离散数学中应用广泛。&lt;/p&gt;&#xA;&lt;p&gt;DAG 图，也叫做有向无环图，是一种特殊应用的数据结构，在图的动态规划问题中出现甚多。遍历 DAG 图的方式，也就是我们常说的拓扑排序，是一种图算法。DAG 可以认为是链表的图版本，如果说区块链是链表，那么区块链 3.0 时代可能就是 DAG 图。&lt;/p&gt;&#xA;&lt;p&gt;字典树，又被称为 Trie 树，是一种边为字符的有向图，它在字符串处理中有着非常强大的应用。广为人知的 AC 自动机，就是用 Trie 树来解决多模式字符串匹配问题。Trie 树在工业界也常被拿来做搜索提示，例如你在百度中搜索 “极客时”，就会自动跳出 “极客时间”。&lt;/p&gt;&#xA;&lt;p&gt;哈希表，这一定是程序员应用最广、自觉最简单的一个数据结构，比如 Python 的 dict() 就可以拿来即用，简单而自然。不过，哈希表其实有着非常深刻的内涵，冲突算法、哈希算法、扩容算法，都很值得我们去深究一下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>硅谷一线互联网公司的工作体验</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/41---%E7%A1%85%E8%B0%B7%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/41---%E7%A1%85%E8%B0%B7%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%BD%93%E9%AA%8C/</guid>
      <description>&lt;p&gt;你好， 我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;前面四个版块，我们一起由浅入深地学习了Python这门语言，而最后一个版块，我想与你分享一些我的技术与工作见闻，谈谈我的领悟与理解。&lt;/p&gt;&#xA;&lt;p&gt;首先，我想带你去了解一下，硅谷Top互联网公司的工作体验与文化，这里就以我工作的Facebook为例。&lt;/p&gt;&#xA;&lt;h2 id=&#34;扁平化的管理制度&#34;&gt;扁平化的管理制度 &lt;a href=&#34;#%e6%89%81%e5%b9%b3%e5%8c%96%e7%9a%84%e7%ae%a1%e7%90%86%e5%88%b6%e5%ba%a6&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;硅谷的一线互联网公司，都会实行扁平化的管理制度，当然FB也不例外。在这里，虽然也有上下级之分，比如 Software Engineer -&amp;gt; Engineering Manager -&amp;gt; Director -&amp;gt; VP，但是我们大家的思想中，并没有严格上下级这样的概念。&lt;/p&gt;&#xA;&lt;p&gt;公司鼓励每个人积极发表自己的观点。比如，一个应届毕业生，因为一个问题和自己的老板，乃至老板的老板据理力争，这样的场景也是很常见的。&lt;/p&gt;&#xA;&lt;p&gt;另外，公司每隔一段时间便会组织一次Q&amp;amp;A，我们大家可以向CEO、CTO等提问。比如你想了解某个产品的发展方向，公司目前的侧重点，甚至是一些敏感的问题，都可以提问。&lt;/p&gt;&#xA;&lt;p&gt;同时，公司的领导，哪怕是上到CEO、CTO、COO这样的高层，都没有自己的单独办公室，都是和我们一起坐在开放的区域内办公，这样即拉近了距离，也是为了方便交流和讨论。&lt;/p&gt;&#xA;&lt;h2 id=&#34;开放式的讨论平台&#34;&gt;开放式的讨论平台 &lt;a href=&#34;#%e5%bc%80%e6%94%be%e5%bc%8f%e7%9a%84%e8%ae%a8%e8%ae%ba%e5%b9%b3%e5%8f%b0&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;第二点是开放式的讨论平台。我一直觉得这个方式非常好，也很喜欢。FB用的是自己开发的workplace，相当于一个开放的社区，里面会有不同的群组，无论你有什么问题，都可以去相应的群组提问，那里会有各个领域的高手来帮你解答。&lt;/p&gt;&#xA;&lt;p&gt;举个例子，如果你有Python相关的问题，便可以去Python的群组问；你如果有Spark的问题，就去Spark 群组问。&lt;/p&gt;&#xA;&lt;p&gt;很多时候，各个组开发的产品，都会涉及很多的跨组合作，要用到其他组开发的一些API、算法、框架等等。这样，在使用的时候就难免会遇到一些问题，这个时候我们大家通常便会在对应的群组中提问。问题解决后也保存了下来，之后再有人遇到相同的问题时，便能直接搜索到对应的帖子及答案，大大提高了办公的效率。&lt;/p&gt;&#xA;&lt;p&gt;除了上述Q&amp;amp;A形式的群组外，我们也会有很多其他形式的群组。比如，自己工作组内的群组，用于发布一些重要消息及技术交流；A/B测试的群组，用于大家讨论某个实验的结果等等。当然，还有很多非技术的群组，比如足球俱乐部、篮球俱乐部等用于休闲娱乐的平台。&lt;/p&gt;&#xA;&lt;p&gt;在有了这么一个生态系统后，员工可以很方便地获取到自己想要的信息，也大大方便了公司内部员工的交流，可以算是一举多得的事情了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;数据驱动为中心&#34;&gt;数据驱动为中心 &lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%e4%b8%ba%e4%b8%ad%e5%bf%83&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;FB是一个典型的数据驱动型的公司，一切都以数据为依据，这样实际上极大地提高了工程师的地位。比如，在决定一个实验要不要最终发起时，我们都会首先关注各项指标，是不是能带来正向影响，是不是提高了用户的体验等等。&lt;/p&gt;&#xA;&lt;p&gt;再比如，每次提出一个新项目时，我们都需要做大量的数据分析与调研，然后与组内的同事及上级领导 review 后再做决定。这样，每次绩效考核时，证明自己最好的依据，便是自己发起的实验对指标的提升等等。这样的一种策略，对于公司及个人的发展都更为有利。&lt;/p&gt;&#xA;&lt;p&gt;举一个反例，之前的Snapchat，就是一个典型的不以数据驱动为中心的公司。他们产品的发布、改变，大多依赖一些产品经理和设计师的主观臆断，这样实际上是很偏颇的。后来的结局我们也都知道了，产品变得越来越不受用户喜欢，股价大跌，而我大部分在那里工作的同学，也都纷纷离职了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;bootcamp&#34;&gt;Bootcamp &lt;a href=&#34;#bootcamp&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Bootcamp是FB中很著名的一个项目，所有入职FB的员工，在正式进入具体的工作组之前，都会参加4-10周的Bootcamp；而每个员工也会分配一个导师，帮助其了解FB的技术栈、文化以及吃喝玩乐等等。&lt;/p&gt;&#xA;&lt;p&gt;Bootcamp的前两周，通常会安排不少的课程，帮助新员工了解FB的内部工具。之后就会进入选组阶段，组和员工之间进行双向选择，形式通常是“聊天+做组内的项目”，这样双方都能对彼此有更深入的了解。&lt;/p&gt;&#xA;&lt;p&gt;在Bootcamp期间，特别是对于应届毕业生来说，你可以尝试各种不同的方向，这对于未来的职业发展是非常有裨益的。公司也鼓励Bootcamp的员工参加各种娱乐活动，增进交流，而且这期间的吃喝玩乐都可以报销。我身边的每个同事都会有这样的感受：Bootcamp真是在公司最舒服的日子了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;鼓励工程师更换工作方向&#34;&gt;鼓励工程师更换工作方向 &lt;a href=&#34;#%e9%bc%93%e5%8a%b1%e5%b7%a5%e7%a8%8b%e5%b8%88%e6%9b%b4%e6%8d%a2%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%90%91&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在FB，无论是内部换组，还是更换工作方向都是非常普遍的现象。很多工程师在一个组做的时间久了，就会想尝试一些新的方向，这在公司是非常鼓励的。&lt;/p&gt;&#xA;&lt;p&gt;方法也很简单，一般来说让你去新组做几个任务，或者花一个月的时间做一个Hackamonth就可以了。这种形式是对双方的考量，新组会对工程师的能力有一个大概的了解；而工程师也会对新组的工作、技术有所掌握，并进一步判断自己是否感兴趣。&lt;/p&gt;&#xA;&lt;p&gt;因此，在FB，你会看到很多全栈工程师，比如我就是其中一个，对移动端、服务器端以及机器学习都有所涉猎。显然，这样的制度，非常有利于工程师的全面发展。&lt;/p&gt;&#xA;&lt;h2 id=&#34;福利政策&#34;&gt;福利政策 &lt;a href=&#34;#%e7%a6%8f%e5%88%a9%e6%94%bf%e7%ad%96&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;FB的福利，应该可以算是全球互联网公司中最好之一了。公司为了留住人才，提供了很多外人看来非比寻常的福利。&lt;/p&gt;&#xA;&lt;p&gt;首先从工位说起，其装备都是业内顶级标准。电脑是可以自己随意选配的，比如你可以随意选配7000多美金的iMac Pro，显示器也可以随意选配价值1000多美金的4K屏幕。至于可升降桌子和椅子，都是Herman Miller 标配，桌椅总价在2000美金以上。&lt;/p&gt;&#xA;&lt;p&gt;在技术交流方面，除了正常的学习培训外，公司还鼓励员工每年外出参加一次会议，比如机器学习方向的ICML、KDD等等，给予全程报销。&lt;/p&gt;&#xA;&lt;p&gt;另外，公司包一日三餐，包括内部的零食、甜品等全部免费。我们拥有一年21天带薪休假，女性还拥有6个月的带薪产假，同时提供免费的健身房、游泳池等，每年还会提供 720美金的健身私教报销等等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;写在最后&#34;&gt;写在最后 &lt;a href=&#34;#%e5%86%99%e5%9c%a8%e6%9c%80%e5%90%8e&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;以上就是我在FB工作的主要工作体验。其实，在硅谷工作，不仅仅有技术上的收获，比如你可以直接接触到业内顶级大牛，了解到最新最前沿的技术；还有很多认知和思维方式上的影响，比如对于流程、合作、开源等的思考。&lt;/p&gt;&#xA;&lt;p&gt;接下来的几篇文章，我会继续讲述，关于技术研发我这些年的工作经验和总结，以及对于职业方向的认识和思考。欢迎你在留言区和我一起讨论交流这些问题，经验分享和交流，是每个技术人成长必不可少的环节。&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>细数技术研发的注意事项</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/42---%E7%BB%86%E6%95%B0%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/42---%E7%BB%86%E6%95%B0%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;技术研发一直以来都是各大公司的核心部分之一，其质量的好坏直接影响到了产品的质量以及用户对产品的体验。如何建立一套规范、健全的开发体系，就显得尤为重要。今天我就和你聊聊技术研发的注意事项。&lt;/p&gt;&#xA;&lt;h2 id=&#34;选择合适的编程语言&#34;&gt;选择合适的编程语言 &lt;a href=&#34;#%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;比如我们正在开发一个系统，首先，根据具体的需求，我们需要对系统的各个部分选择合适的编程语言。一般来说，infra这层我们更偏向于使用C++，而纯的服务器端则是以Python、Java、PHP等等为主。以搜索引擎为例，下面我画了一个它的简略架构图：&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/72caf6b3be8758651e6071bd49cb24d5_8763783103075327919.png&#34; alt=&#34;&#34; width=&#34;1418&#34; height=&#34;590&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;/p&gt;&#xA;&lt;p&gt;你可以看到，大概的工作流程是：用户在客户端（client）输入一个查询（query），发送请求（request）到达服务器端（server-side）；服务器端首先向NLP service发请求，并对请求进行分析，等到拿到各项信号（signal）后，再向后端（backend）发送请求；后端会做特征抽取（feature extraction），利用ML 模型进行结果的检索（candidate retrieval）、排序，最后再把结果返回给服务器端和客户端。&lt;/p&gt;&#xA;&lt;p&gt;这里的NLP Service和后端，我们都会使用C++。因为这部分的处理最为复杂和耗时，都涉及到了特征抽取和model serving，对延迟（latency）的要求极高，只有C/C++这类语言才能满足需求。&lt;/p&gt;&#xA;&lt;p&gt;而服务器端或者叫中间层（middle tier），我们则会使用Python、Java、PHP等语言。因为这部分并没有特别复杂的处理和对延迟的高需求，主要是以一些业务逻辑为主；并且，对程序员来说，使用这种高级语言也更容易上手和调试。&lt;/p&gt;&#xA;&lt;h2 id=&#34;合理使用缓存&#34;&gt;合理使用缓存 &lt;a href=&#34;#%e5%90%88%e7%90%86%e4%bd%bf%e7%94%a8%e7%bc%93%e5%ad%98&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;缓存（cache）在实际工程中十分重要，可以想像，如果没了缓存，我们今天所用的绝大多数产品估计都会崩溃。缓存为我们节约了大量的CPU 容量（capacity）和延迟。&lt;/p&gt;&#xA;&lt;p&gt;还是以刚刚的搜索引擎系统为例，我们在客户端、服务器端和后端都会设置缓存。在客户端，我们一般会缓存用户的搜索记录，比如当你点击搜索框时，自动弹出的建议关键词的前几个，就可以是缓存的结果。这不需要向服务器端发请求，可以直接从客户端下载。&lt;/p&gt;&#xA;&lt;p&gt;而在服务器端，我们也会设置缓存来存储一些搜索结果。这样，如果同一个用户多次发送相同的请求，就不需要再向后端请求，直接从缓存里面拿结果就可以了，快速又高效。&lt;/p&gt;&#xA;&lt;p&gt;同样的，后端也需要缓存。比如在model serving这块儿，我们通常会有几个小时的缓存，不然每次提供实时的在线服务时，对CPU的负荷很大，延迟也会很高。&lt;/p&gt;&#xA;&lt;p&gt;总而言之，如果没了缓存，容易造成很多问题。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务器负荷迅速飙升，崩溃的几率大大增加。&lt;/li&gt;&#xA;&lt;li&gt;端对端的延迟迅速飙升，请求超时的概率大大增加。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;但是不是缓存越多就越好呢？显然也不是。&lt;/p&gt;&#xA;&lt;p&gt;第一，通常来说，缓存比较昂贵，所以在使用上，我们都会有一个限度，不能无限制索取。&lt;/p&gt;&#xA;&lt;p&gt;第二，缓存不是万能的，过度增加缓存，也会损害用户的产品体验。比如搜索结果的retrieval和排序这两块，理想状况下，肯定是做实时的model serving最好，因为这样对用户的个性化推荐更准确和实时。之所以会对model有几个小时的缓存，更多的是出于性能的考虑，但如果把缓存从几小时改为几天，显然不合适，无疑会对用户的产品体验造成极大的负面影响。&lt;/p&gt;&#xA;&lt;p&gt;因此，缓存到底取多久、取多少，往往是用户对产品参与度和性能的一个权衡，需要根据一些具体的分析以及A/B测试做出决定。&lt;/p&gt;&#xA;&lt;h2 id=&#34;健全的日志记录系统&#34;&gt;健全的日志记录系统 &lt;a href=&#34;#%e5%81%a5%e5%85%a8%e7%9a%84%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e7%b3%bb%e7%bb%9f&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;健全的日志记录系统也是尤其关键的一点。大型公司的系统，往往由成千十万个小系统组合而来，如果发生故障，比如Google、Facebook的某项服务突然宕机了，我们就需要以最快的速度找出原因并做出修复。这靠的是什么呢？靠的正是健全的日志记录系统，使得我们能够方便地分解错误原因，一层一层追溯，直到找到根源。&lt;/p&gt;&#xA;&lt;p&gt;一般来说，在线上环境中，我们需要两种类型的日志记录模式。&lt;/p&gt;&#xA;&lt;p&gt;一种是实时logging，考虑到服务器的压力，通常会做降采样（downsampling），比如log实际流量的1%。这样的好处是，可以及时跟踪各项指标，如果有情况，立即触发警报（alert）。&lt;/p&gt;&#xA;&lt;p&gt;比如，某天的中午12点，一位工程师push了一段会造成服务器奔溃的代码进入产品，实时logging检测到异常，发出警报，这时有关人员便会进行排查。如果发现这个代码的push时间和警报触发时间一致，就能够最快地恢复（revert），最小化其带来的负面影响。&lt;/p&gt;&#xA;&lt;p&gt;同时，实时logging也有利于我们进行各种线上实验。比如，ML组的A/B测试常常需要调参，我们的通常做法，就是每隔几小时查看实时 logging的table，根据各项指标，适度调整参数。&lt;/p&gt;&#xA;&lt;p&gt;第二种是每天更新一次也就是daily的 full logging，有助于我们统计一些信息，进行分析，比如做成仪表板（dashboard），方便查看每天的各项指标，来跟踪进度。此外，full logging的table，也常常用于ML组的训练数据（training data）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;profiling必不可少&#34;&gt;Profiling必不可少 &lt;a href=&#34;#profiling%e5%bf%85%e4%b8%8d%e5%8f%af%e5%b0%91&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;关于profile，之前我们也提到过，在实际开发中是非常重要的一项功能，能够帮助开发人员详细了解系统每个部分的效率，并加以提高。&lt;/p&gt;&#xA;&lt;p&gt;在线上环境中，我们通常会在许多必要的地方加上profile的代码，这样我们就能够知道这段代码的延迟是多少，哪个部分的延迟特别严重等等，然后对症下药。&lt;/p&gt;&#xA;&lt;p&gt;如果没有profile，很容易导致开发人员随意增加功能而不进行优化，这样以来，随着时间的推移，系统越来越冗余，延迟也会越来越高。因此，一个成熟的系统，一定会有profile的代码，帮助开发人员随时监控内部的各项指标变化。&lt;/p&gt;&#xA;&lt;h2 id=&#34;testtesttest&#34;&gt;test、test、test &lt;a href=&#34;#testtesttest&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这一点，我也已经在前面的文章中强调过了，测试（test）一定不能少。无论是单元测试（unit test）、集成测试（integration test）还是其他，都是保证代码质量、减小bug发生概率的一个有效手段。&lt;/p&gt;&#xA;&lt;p&gt;在真正规范的公司或是小组里，开发人员如果新增或改变了一个功能而不写测试，是过不了代码评审的。因此，测试一定要写，尤其是系统复杂了以后，很多工程师都要在上面开发各种不同的新功能，很难保证各个部分不受影响，测试便是一种很好的解决方法。&lt;/p&gt;&#xA;&lt;p&gt;除了日常开发中所写的测试外，在代码push到线上之前，最好还要加一层测试。还是以刚刚的搜索引擎系统为例，我所知道的，Google或者Facebook的代码在push的过程中，都会有专门的service，去模拟不同的用户发送请求，然后看返回的响应是不是符合要求。如果出错，就会阻止代码的push，这也就告诉了开发人员，他们所写的代码可能存在问题，需要再次检查。&lt;/p&gt;&#xA;&lt;h2 id=&#34;写在最后&#34;&gt;写在最后 &lt;a href=&#34;#%e5%86%99%e5%9c%a8%e6%9c%80%e5%90%8e&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;关于技术研发的注意事项，我主要强调这些内容。事实上，日常开发工作中，很多的细节都值得特别关注，而对于易错的地方，用系统化的流程解决不失为一个高效的方案。那么，在你的日常工作中，有哪些特别留心的地方值得分享，或者有哪些疑惑的地方想要交流吗？欢迎在留言区写下你的想法。&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>Q&amp;A：聊一聊职业发展和选择</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/43---qa%E8%81%8A%E4%B8%80%E8%81%8A%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E5%92%8C%E9%80%89%E6%8B%A9/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/43---qa%E8%81%8A%E4%B8%80%E8%81%8A%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E5%92%8C%E9%80%89%E6%8B%A9/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;在前面几节课中，我分享了在FB工作的一些经验和感想，不少同学都提出了自己的困惑，也希望我能给出一些职业发展方面的建议。综合这些问题，我主要选取了下面三个主题，来说说职业发展、职业选择方面我的看法。&lt;/p&gt;&#xA;&lt;h3 id=&#34;q程序员的岗位主要有哪些类型我该如何选择&#34;&gt;Q：程序员的岗位主要有哪些类型？我该如何选择？ &lt;a href=&#34;#q%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e5%b2%97%e4%bd%8d%e4%b8%bb%e8%a6%81%e6%9c%89%e5%93%aa%e4%ba%9b%e7%b1%bb%e5%9e%8b%e6%88%91%e8%af%a5%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;A：无论是在求职阶段，还是正式进入公司工作后，你都会发现，工程师普遍按技术的不同，分为下面几个岗位。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;前端：包括移动（Android、iOS）以及Web前端（JavaScript、CSS）开发。&lt;/li&gt;&#xA;&lt;li&gt;后端（服务器端）：主要是服务器端的开发，简单来说，就是输入为请求，输出为响应，发送给客户端。&lt;/li&gt;&#xA;&lt;li&gt;算法：主要涉及到的是机器学习，比如推荐系统如何更好地实现个性化推荐，搜索引擎返回的结果如何才能更符合地用户的需求等等。&lt;/li&gt;&#xA;&lt;li&gt;架构：涉及系统架构，偏底层，语言以C++为主。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;从薪酬的角度来看，普遍来说：算法 &amp;gt; 架构 &amp;gt; 后端 &amp;gt; 前端。当然，这主要是由市场的供需关系决定的。&lt;/p&gt;&#xA;&lt;p&gt;就拿算法岗来说，国内市场普遍缺少算法人才，也是因为这个岗位的培养难度更大，需要投入更大的精力。在顶尖互联网公司，参与核心产品研发的算法工程师们，工作三年，年收入100-200W人民币是很常见的。&lt;/p&gt;&#xA;&lt;p&gt;不过，我这里所说的算法人才，绝不是指类似在校生那种，看过几篇论文，写过一些MATLAB，在学校做过几个科研项目的程度。算法工作岗位需要的算法能力，是你必须身体力行，有某些产品线的实践经历。还需要你真正了解市场，比如今日头条的推荐算法是怎样的，Google搜索引擎是怎么工作的，头条里的广告排序又是怎么做的等等。&lt;/p&gt;&#xA;&lt;p&gt;再来说说架构，这也是目前一个热门的方向。我一直认为这是一个很偏工程、很硬核的领域，发展前景也相当不错，可以说是一个产品的基石。就拿刚刚提到的推荐系统来说，广告的定位和排序系统背后，都需要强有力的架构支撑。因此，这一行也可以称得上是人才紧缺，是企业舍得花高薪聘请的对象之一。&lt;/p&gt;&#xA;&lt;p&gt;与算法不同的是，这个领域不会涉及很深的数学知识，工程师的主要关注点，在于如何提高系统性能，包括如何使系统高扩展、减小系统的延迟和所需CPU的容量等等。架构师需要很强的编程能力，常用的语言是C++；当然，最重要的还是不断积累大型项目中获得的第一手经验，对常见的问题有最principle的处理方式。&lt;/p&gt;&#xA;&lt;p&gt;最后说说后端和前端，这是绝大多数程序员从事的岗位，也是我刚进公司时的选择。也许比起前两个岗位，不少人会认为，后端、前端工程师的薪酬较低，没有什么发展前景。这其实大错特错了！从一个产品的角度出发，你可以没有算法工程师、没有架构师，但是你能缺少后端和前端的开发人员吗？显然是不可能的。&lt;/p&gt;&#xA;&lt;p&gt;后端和前端，相当于是一个产品的框架。框架搭好了，才会有机器学习、算法等的锦上添花。诚然，这两年来看，后端和前端没有前两者那么热门（还是市场供需关系的问题），但这并不代表，这些岗位没有发展前景，或者你就可以小看其技术含量。&lt;/p&gt;&#xA;&lt;p&gt;比起算法和架构，后端、前端确实门槛更低些，但是其工作依然存在很高的技术含量。比如对一个产品或者其中的某些部件来说，如何设计搭建前后端的开发框架结构，使系统更加合理、可维护性更高，就是很多资深的开发工程师正在做的事。&lt;/p&gt;&#xA;&lt;p&gt;前面聊了这么多，最后回到最根本的问题上：到底如何选择呢？&lt;/p&gt;&#xA;&lt;p&gt;这里我给出的建议是：首先以自己的兴趣为出发点，因为只有自己感兴趣的东西，你才能做到最好。比如，一些人就是对前端感兴趣，那么为啥偏要去趟机器学习这趟浑水呢？当然不少人可能没有明确的偏好，那么这种情况下，我建议你尽可能多地去尝试，这是了解自己兴趣最好的方法。&lt;/p&gt;&#xA;&lt;p&gt;另外，从广义的角度来看，计算机这门技术存在着study deep和study broad这两个方向，你得想清楚你属于哪类。所谓的study deep，就意味着数十年专攻一个领域，励志成为某个领域的专家；而study broad，便是类似于全栈工程师，对一个产品、系统的end to end都有一个了解，能够随时胜任任意角色的工作，这一点在初创公司身上体现得最为明显。&lt;/p&gt;&#xA;&lt;h3 id=&#34;q如何成为一个全栈工程师&#34;&gt;Q：如何成为一个全栈工程师？ &lt;a href=&#34;#q%e5%a6%82%e4%bd%95%e6%88%90%e4%b8%ba%e4%b8%80%e4%b8%aa%e5%85%a8%e6%a0%88%e5%b7%a5%e7%a8%8b%e5%b8%88&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;A：相信屏幕前的不少同学是在创业公司工作的，刚刚也提到了，创业公司里全栈工程师的需求尤为突出。那么，如何成为一个优秀的全栈工程师呢？&lt;/p&gt;&#xA;&lt;p&gt;简单来说，最好的方法就是“尽可能地多接触、多实践不同领域的项目”。身体力行永远是学习新知识、提高能力的最好办法。&lt;/p&gt;&#xA;&lt;p&gt;当然，在每个领域的初始阶段，你可能会感觉到异常艰难，比如从未接触过前端的人被要求写一个页面，一时间内显然会不知从何下手。这个时候，我建议你可以先从“依葫芦画瓢”开始，通过阅读别人相似的代码，并在此基础上加以修改，完成你要实现的功能。时间久了，你看的多了，用的多了，理解自然就越来越深，动起手来也就越来越熟练了。&lt;/p&gt;&#xA;&lt;p&gt;有条件的同学，比如工作在类似于FB这种文化的公司，可以通过在公司内部换组的方式，去接触不同的项目。这自然是最好不过了，因为和特定领域的人合作，永远比一个人单干强得多，你能够迅速学到更多的东西。&lt;/p&gt;&#xA;&lt;p&gt;不过，没这种条件的同学也不必绝望，你还可以利用业余时间“充电“，自己做一些项目来培养和加强别的领域的能力。毕竟，对于成年人来说，自学才是精进自己的主要方式。&lt;/p&gt;&#xA;&lt;p&gt;这样，到了最后，你应该达到的结果便是，自己一个人能够扛起整条产品线的开发，也对系统的整个工作流程有一个全面而深入的理解。&lt;/p&gt;&#xA;&lt;h3 id=&#34;q学完本专栏后在python领域我该如何继续进阶呢&#34;&gt;Q：学完本专栏后，在Python领域我该如何继续进阶呢？ &lt;a href=&#34;#q%e5%ad%a6%e5%ae%8c%e6%9c%ac%e4%b8%93%e6%a0%8f%e5%90%8e%e5%9c%a8python%e9%a2%86%e5%9f%9f%e6%88%91%e8%af%a5%e5%a6%82%e4%bd%95%e7%bb%a7%e7%bb%ad%e8%bf%9b%e9%98%b6%e5%91%a2&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;A：在我看来，这个专栏的主要目的，是带你掌握Python这门语言的常见基本和高阶用法。接下来的进阶，便是Python本身在各种不同方向的运用，拿后端开发这个方向来说，比如，如何搭建大型系统的后台便是你需要掌握的。一个好的后端，自然离不开：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;合理的系统、框架设计；&lt;/li&gt;&#xA;&lt;li&gt;简约高效的代码质量；&lt;/li&gt;&#xA;&lt;li&gt;稳健齐全的单元测试；&lt;/li&gt;&#xA;&lt;li&gt;出色的性能表现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;具体来说，你搭建的系统后端是不是易于拓展呢？比如过半年后，有了新的产品需求，需要增加新的功能。那么，在你的框架下，是否可以尽可能少地改动来实现新的功能，而不需要把某部分推倒重来呢？&lt;/p&gt;&#xA;&lt;p&gt;再比如，你搭建的系统是不是符合可维护性高、可靠性高、单元测试齐全的要求，从而不容易在线上发生bug呢？&lt;/p&gt;&#xA;&lt;p&gt;总之，在某一领域到了进阶的阶段，你需要关注的，绝不仅仅只是某些功能的实现，更需要你考虑所写代码的性能、质量，甚至于整个系统的设计等等。&lt;/p&gt;&#xA;&lt;p&gt;虽然讲了这么多东西，但最后我想说的是，三百六十行，行行出状元。对于计算机行业，乃至整个职场来说，每一个领域都没有优劣之分，每个领域你都可以做得很牛逼，前提是你不懈地学习、实践和思考。&lt;/p&gt;&#xA;&lt;p&gt;那么，对于职业选择和发展，你又是如何看待和理解的呢？欢迎留言和我一起交流探讨，也希望屏幕前的一直不懈学习的你，能找到属于自己的方向，不断前进和创新，实现自己的人生理想。&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>加餐 - 带你上手SWIG：一份清晰好用的SWIG编程实践指南</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/44---%E5%8A%A0%E9%A4%90---%E5%B8%A6%E4%BD%A0%E4%B8%8A%E6%89%8Bswig%E4%B8%80%E4%BB%BD%E6%B8%85%E6%99%B0%E5%A5%BD%E7%94%A8%E7%9A%84swig%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/44---%E5%8A%A0%E9%A4%90---%E5%B8%A6%E4%BD%A0%E4%B8%8A%E6%89%8Bswig%E4%B8%80%E4%BB%BD%E6%B8%85%E6%99%B0%E5%A5%BD%E7%94%A8%E7%9A%84swig%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;p&gt;你好，我是卢誉声，Autodesk 数据平台和计算平台资深软件工程师，也是《移动平台深度神经网络实战》和《分布式实时处理系统：原理架构与实现》的作者，主要从事C/C++、JavaScript开发工作和平台架构方面的研发工作，对SWIG也有比较深的研究。很高兴受极客时间邀请来做本次分享，今天，我们就来聊一聊SWIG这个话题。&lt;/p&gt;&#xA;&lt;p&gt;我们都知道，Python 是一门易于上手并实验友好的胶水语言。现在有很多机器学习开发或研究人员，都选择Python作为主力编程语言；流行的机器学习框架也都会提供Python语言的支持作为调用接口和工具。因此，相较于学习成本更高的C++来说，把Python作为进入机器学习世界的首选编程语言，就再合适不过了。&lt;/p&gt;&#xA;&lt;p&gt;不过，像TensorFlow或PyTorch这样的机器学习框架的核心，是使用Python编写的吗？&lt;/p&gt;&#xA;&lt;p&gt;显然不是。这里面的原因比较多，但最为显著的一个原因就是“性能”。通过C++编写的机器学习框架内核，加上编译器的优化能力，为系统提供了接近于机器码执行的效率。这种得天独厚的优势，让C++在机器学习的核心领域站稳了脚跟。我们前面所说的TensorFlow和PyTorch的核心，便都是使用C/C++开发的。其中，TensorFlow的内核，就是由高度优化的C++代码和CUDA编写而成。&lt;/p&gt;&#xA;&lt;p&gt;因此，我们可以理解为，TensorFlow通过Python来描述模型，而实际的运算则是由高性能C++代码执行的。而且，在绝大多数情况下，不同操作之间传递的数据，并不会拷贝回Python代码的执行空间。机器学习框架，正是通过这样的方式确保了计算性能，同时兼顾了对框架易用性方面的考虑。&lt;/p&gt;&#xA;&lt;p&gt;因此，当Python和C++结合使用的时候，Python本身的性能瓶颈就不那么重要了。它足够胜任我们给它的任务就可以了，至于对计算有更高要求的任务，就交给C++来做吧！&lt;/p&gt;&#xA;&lt;p&gt;今天，我们就来讨论下，如何通过SWIG对C++程序进行Python封装。我会先带你编写一段Python脚本，来执行一个简单的机器学习任务；接着，尝试将计算密集的部分改写成C++程序，再通过SWIG对其进行封装。最后的结果就是，Python把计算密集的任务委托给C++执行。&lt;/p&gt;&#xA;&lt;p&gt;我们会对性能做一个简单比较，并在这个过程中，讲解使用SWIG的方法。同时，在今天这节课的最后，我会为你提供一个学习路径，作为日后提高的参考。&lt;/p&gt;&#xA;&lt;p&gt;明确了今天的学习目的，也就是使用SWIG来实现Python对C++代码的调用，那么，我们今天的内容，其实可以看成一份&lt;strong&gt;关于SWIG的编程实践指南&lt;/strong&gt;。学习这份指南之前，我们先来简单了解一下SWIG。&lt;/p&gt;&#xA;&lt;h2 id=&#34;swig-是什么&#34;&gt;SWIG 是什么？ &lt;a href=&#34;#swig-%e6%98%af%e4%bb%80%e4%b9%88&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;SWIG，是一款能够连接C/C++与多种高级编程语言（我们在这里特别强调Python）的软件开发工具。SWIG支持多种不同类型的目标语言，这其中，支持的常见脚本语言包括JavaScript、Perl、PHP、Tcl、Ruby和Python等，支持的高级编程语言则包括C#、D、Go语言、Java（包括对Android的支持）、Lua、OCaml、Octave、Scilab和R。&lt;/p&gt;&#xA;&lt;p&gt;我们通常使用SWIG来创建高级解释或编译型的编程环境和接口，它也常被用来当作C/C++编写原型的测试工具。一个典型的应用场景，便是解析和创建C/C++接口，生成胶水代码供像Python这样的高级编程语言调用。近期发布的4.0.0版本，更是带来了对C++的显著改进和支持，这其中包括（不局限于）下面几点。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;针对C#、Java和Ruby而改进的STL包装器。&lt;/li&gt;&#xA;&lt;li&gt;针对Java、Python和Ruby，增加C++11标准下的STL容器的支持。&lt;/li&gt;&#xA;&lt;li&gt;改进了对C++11和C++14代码的支持。&lt;/li&gt;&#xA;&lt;li&gt;修正了C++中对智能指针shared_ptr的一系列bug修复。&lt;/li&gt;&#xA;&lt;li&gt;一系列针对C预处理器的极端case修复。&lt;/li&gt;&#xA;&lt;li&gt;一系列针对成员函数指针问题的修复。&lt;/li&gt;&#xA;&lt;li&gt;低支持的Python版本为2.7、3.2-3.7。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;使用python实现pca算法&#34;&gt;使用Python实现PCA算法 &lt;a href=&#34;#%e4%bd%bf%e7%94%a8python%e5%ae%9e%e7%8e%b0pca%e7%ae%97%e6%b3%95&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;借助于SWIG，我们可以简单地实现用Python调用C/C++库，甚至可以用Python继承和使用C++类。接下来，我们先来看一个你十分熟悉的使用Python编写的PCA（Principal Component Analysis，主成分分析）算法。&lt;/p&gt;&#xA;&lt;p&gt;因为我们今天的目标不是讲解PCA算法，所以如果你对这个算法还不是很熟悉，也没有关系，我会直接给出具体的代码，我们把焦点放在如何使用SWIG上就可以了。下面，我先给出代码清单1。&lt;/p&gt;&#xA;&lt;p&gt;代码清单1，基于Python编写的PCA算法 &lt;code&gt;testPCAPurePython.py&lt;/code&gt; ：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;  &#xA;  &#xA;  &#xA;&#xA;  &#xA;&#xA;  &lt;div class=&#34;prism-codeblock &#34;&gt;&#xA;  &lt;pre id=&#34;453513b&#34; class=&#34;language- &#34;&gt;&#xA;  &lt;code&gt;import numpy as np&#xD;&#xA;&#xD;&#xA;def compute_pca(data):&#xD;&#xA;    m = np.mean(data, axis=0)&#xD;&#xA;    datac = np.array([obs - m for obs in data])&#xD;&#xA;    T = np.dot(datac, datac.T)&#xD;&#xA;    [u,s,v] = np.linalg.svd(T)&#xD;&#xA;&#xD;&#xA;    pcs = [np.dot(datac.T, item) for item in u.T ]&#xD;&#xA;&#xD;&#xA;     pcs = np.array([d / np.linalg.norm(d) for d in pcs])&#xD;&#xA;&#xD;&#xA;     return pcs, m, s, T, u&#xD;&#xA;&#xD;&#xA; def compute_projections(I,pcs,m):&#xD;&#xA;     projections = []&#xD;&#xA;     for i in I:&#xD;&#xA;         w = []&#xD;&#xA;         for p in pcs:&#xD;&#xA;             w.append(np.dot(i - m, p))&#xD;&#xA;         projections.append(w)&#xD;&#xA;     return projections&#xD;&#xA;&#xD;&#xA; def reconstruct(w, X, m,dim = 5):&#xD;&#xA;     return np.dot(w[:dim],X[:dim,:]) &amp;#43; m&#xD;&#xA;&#xD;&#xA; def normalize(samples, maxs = None):&#xD;&#xA;     if not maxs:&#xD;&#xA;         maxs = np.max(samples)&#xD;&#xA;     return np.array([np.ravel(s) / maxs for s in samples])&lt;/code&gt;&#xA;  &lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;现在，我们保存这段编写好的代码，并通过下面的命令来执行：&lt;/p&gt;</description>
    </item>
    <item>
      <title>结课测试 - 关于Python的这些知识，你都掌握了吗？</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/45---%E7%BB%93%E8%AF%BE%E6%B5%8B%E8%AF%95---%E5%85%B3%E4%BA%8Epython%E7%9A%84%E8%BF%99%E4%BA%9B%E7%9F%A5%E8%AF%86%E4%BD%A0%E9%83%BD%E6%8E%8C%E6%8F%A1%E4%BA%86%E5%90%97/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/45---%E7%BB%93%E8%AF%BE%E6%B5%8B%E8%AF%95---%E5%85%B3%E4%BA%8Epython%E7%9A%84%E8%BF%99%E4%BA%9B%E7%9F%A5%E8%AF%86%E4%BD%A0%E9%83%BD%E6%8E%8C%E6%8F%A1%E4%BA%86%E5%90%97/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;《Python核心技术与实战》这门课程已经完结一段时间了，在完结的这段时间里，我依然会收到很多留言，很感谢你一直以来的认真学习和支持！&lt;/p&gt;&#xA;&lt;p&gt;为了帮助你检验自己的学习效果，我特别给你准备了一套结课测试题。这套测试题共有20道题目，包括5道单选题和15道多选题，满分 100 分。&lt;/p&gt;&#xA;&lt;p&gt;还等什么，点击下面按钮开始测试吧！&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://time.geekbang.org/quiz/intro?act_id=157&amp;exam_id=348&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/28d1be62669b4f3cc01c36466bf811a4_5096059377289861715.png&#34; alt=&#34;&#34; width=&#34;1142&#34; height=&#34;201&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>结束语 - 技术之外的几点成长建议</title>
      <link>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/46---%E7%BB%93%E6%9D%9F%E8%AF%AD---%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96%E7%9A%84%E5%87%A0%E7%82%B9%E6%88%90%E9%95%BF%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Mon, 04 Aug 2025 11:25:06 +0800</pubDate>
      <guid>http://localhost:1313/docs/python/python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/46---%E7%BB%93%E6%9D%9F%E8%AF%AD---%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96%E7%9A%84%E5%87%A0%E7%82%B9%E6%88%90%E9%95%BF%E5%BB%BA%E8%AE%AE/</guid>
      <description>&lt;p&gt;你好，我是景霄。&lt;/p&gt;&#xA;&lt;p&gt;不知不觉，专栏上线已经4个月了，终于到了和你们说再见的时候，心中既有兴奋，又有不舍。说兴奋，是因为自己坚持完成了40多篇文章的写作，这对我而言是一项体力与脑力的“马拉松”，颇有成就感；说不舍，是因为你们的热情远超乎我当时的想象，和你们一起交流学习真的很高兴，收获也很大。&lt;/p&gt;&#xA;&lt;p&gt;这里也非常感谢极客时间能提供这个平台，让我得以和一万多的学员分享经验。当然，虽然课程结束了，但是技术人的学习并未终止，最后我还想再着重强调这么几点。&lt;/p&gt;&#xA;&lt;h2 id=&#34;计算机科学是一门需要实践的学科&#34;&gt;计算机科学是一门需要实践的学科 &lt;a href=&#34;#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e6%98%af%e4%b8%80%e9%97%a8%e9%9c%80%e8%a6%81%e5%ae%9e%e8%b7%b5%e7%9a%84%e5%ad%a6%e7%a7%91&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;无论是对于Python这门课程，还是其他语言，或是计算机的其他领域，我认为实践永远是至关重要的。计算机科学是一门偏向工程的学科，所以一定要&lt;strong&gt;多实践，多写代码，多交流，多思考&lt;/strong&gt;。实际生活中，我见过不少同学虽然看了很多的书籍，但是代码功底非常差，这是一个很严重的问题。&lt;/p&gt;&#xA;&lt;p&gt;那么，怎么提高呢？答案就是，请尽可能地参与更多的项目。俗话说“实践出真知”，说的正是这个道理。当你做的东西多了以后，你就会发现，很多的知识都会自然而然地串接起来，感觉自己的任督二脉似乎被打通了一般。&lt;/p&gt;&#xA;&lt;h2 id=&#34;选择适合自己的职业方向&#34;&gt;选择适合自己的职业方向 &lt;a href=&#34;#%e9%80%89%e6%8b%a9%e9%80%82%e5%90%88%e8%87%aa%e5%b7%b1%e7%9a%84%e8%81%8c%e4%b8%9a%e6%96%b9%e5%90%91&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;关于职业方向的问题，我还是那句话，&lt;strong&gt;对于尚不清晰自己兴趣所在的同学，最好的办法就是多尝试&lt;/strong&gt;，因为在尝试的过程中，你就会发现自己的特长，发现自己的喜好，从而坚定不移、一步一步地走下去。&lt;/p&gt;&#xA;&lt;p&gt;当然，我了解到很多同学都是转行做程序员，以前都不是学计算机的，所以，很多人首先都会遇到“找工作”或者“跳槽”的难题。这种情况下，请不要气馁或是放弃。我也不完全算是科班出身的，我身边好多同事都不是科班出身，但是几年以后，你就会发现，好多当年非科班出身的同学，干得甚至比科班出身的都要好。因此，只要你坚定信念，不要放弃，风雨之后必有彩虹。&lt;/p&gt;&#xA;&lt;h2 id=&#34;能用代码解决的问题都不是问题&#34;&gt;能用代码解决的问题都不是问题 &lt;a href=&#34;#%e8%83%bd%e7%94%a8%e4%bb%a3%e7%a0%81%e8%a7%a3%e5%86%b3%e7%9a%84%e9%97%ae%e9%a2%98%e9%83%bd%e4%b8%8d%e6%98%af%e9%97%ae%e9%a2%98&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这句话，主要送给有一定工作经验的朋友。其实，有了一定的积累后，你就会发现，能用代码解决的问题都不是问题。职场上，要想出类拔萃，除了能在技术上独当一面，&lt;strong&gt;如何与他人进行沟通交流，如何正确地处理同事间的关系，都是你额外需要学习的东西&lt;/strong&gt;。实际工作中，我也见过不少人，代码能力天赋异禀，但是沟通交流不行，这同样也会阻碍你向上晋升。&lt;/p&gt;&#xA;&lt;p&gt;就拿一个很简单的例子来说。如果你和周围的同事合作一个项目，你觉得他有一样东西做得不好，你会直接说诸如“你很傻”，“你这样做大错特错”的话吗？你如果这样说了，那可真的是“大错特错了”。事实上，我们通常的一个措辞是，“我觉得你这里做得很好，不过，如果你可以……的话，那就更好了”。&lt;/p&gt;&#xA;&lt;p&gt;说了这么多，最后，还是要感谢你的订阅，感谢你的一路陪伴，祝你的生活学习一帆风顺，永远幸福！课程虽然已经结束，但是你仍然可以留言，我会尽可能多地一一回复，让你的学习没有遗憾。&lt;/p&gt;&#xA;&lt;p&gt;结束不是终点，而是更高阶旅程的重新启航。最后的最后，我们专栏的编辑同学，特意为你准备了一份&lt;strong&gt;毕业调查问卷&lt;/strong&gt;，希望你能抽出两三分钟时间，写下你的学习经历和感受。这既是你课程学习的仪式感，作为你这几个月学习的记录和总结；也是我后续为你优化课程的重要参考资料，很有价值。感谢你的反馈，学习不停，精进不止！&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://jinshuju.net/f/40SCVf&#34; rel=&#34;external&#34; target=&#34;_blank&#34;&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;&#xA;&#xA;&#xA;  &#xA;    &#xA;      &lt;img src=&#34;http://localhost:1313/b1bd25655f8d05d12f719877b4d15946_11444300385840776799.jpg&#34; alt=&#34;&#34; width=&#34;1142&#34; height=&#34;801&#34; loading=&#34;lazy&#34;&gt;&#xA;    &#xA;  &#xA;&lt;svg width=&#34;16&#34; height=&#34;16&#34; viewBox=&#34;0 0 24 24&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path fill=&#34;currentColor&#34; d=&#34;M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z&#34;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
  </channel>
</rss>
